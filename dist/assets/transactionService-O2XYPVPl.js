import{z as s}from"./index-Cb_Vey4A.js";class d{static async getUserTransactions(n,t){try{let a=s.from("transactions").select("*").eq("user_id",n).order("created_at",{ascending:!1});t?.type&&(Array.isArray(t.type)?a=a.in("type",t.type):a=a.eq("type",t.type)),t?.status&&(Array.isArray(t.status)?a=a.in("status",t.status):a=a.eq("status",t.status)),t?.currency&&(a=a.eq("currency",t.currency)),t?.blockchain&&(a=a.eq("blockchain",t.blockchain)),t?.startDate&&(a=a.gte("created_at",t.startDate.toISOString())),t?.endDate&&(a=a.lte("created_at",t.endDate.toISOString())),t?.limit&&(a=a.limit(t.limit)),t?.offset&&(a=a.range(t.offset,t.offset+(t.limit||10)-1));const{data:e,error:r}=await a;return{data:e,error:r}}catch(a){return console.error("Error fetching transactions:",a),{data:null,error:a}}}static async getTransactionById(n){try{const{data:t,error:a}=await s.from("transactions").select("*").eq("id",n).maybeSingle();return{data:t,error:a}}catch(t){return console.error("Error fetching transaction:",t),{data:null,error:t}}}static async createTransaction(n){try{const{data:t,error:a}=await s.from("transactions").insert(n).select().single();return{data:t,error:a}}catch(t){return console.error("Error creating transaction:",t),{data:null,error:t}}}static async updateTransactionStatus(n,t,a){try{const e={status:t,updated_at:new Date().toISOString()};t==="completed"&&(e.completed_at=new Date().toISOString()),a&&(e.metadata=a);const{data:r,error:i}=await s.from("transactions").update(e).eq("id",n).select().single();return{data:r,error:i}}catch(e){return console.error("Error updating transaction:",e),{data:null,error:e}}}static async getUserTransactionStats(n){try{const{data:t}=await this.getUserTransactions(n,{status:"completed"});return t?t.reduce((e,r)=>{switch(r.type){case"deposit":e.totalDeposits+=r.amount;break;case"withdrawal":e.totalWithdrawals+=r.amount;break;case"mining_reward":e.totalMiningRewards+=r.amount;break;case"maintenance_payment":e.totalMaintenancePaid+=r.amount;break;case"nft_purchase":case"marketplace_buy":e.totalNFTPurchases+=r.amount;break;case"nft_sale":case"marketplace_sell":e.totalNFTSales+=r.amount;break;case"foundation_donation":e.foundationContributions+=r.amount;break}return e},{totalDeposits:0,totalWithdrawals:0,totalMiningRewards:0,totalMaintenancePaid:0,totalNFTPurchases:0,totalNFTSales:0,foundationContributions:0}):{totalDeposits:0,totalWithdrawals:0,totalMiningRewards:0,totalMaintenancePaid:0,totalNFTPurchases:0,totalNFTSales:0,foundationContributions:0}}catch(t){return console.error("Error calculating transaction stats:",t),{totalDeposits:0,totalWithdrawals:0,totalMiningRewards:0,totalMaintenancePaid:0,totalNFTPurchases:0,totalNFTSales:0,foundationContributions:0}}}static async getRecentTransactions(n){return this.getUserTransactions(n,{limit:10})}static async getPendingTransactions(n){return this.getUserTransactions(n,{status:["pending","processing"],limit:20})}static async cancelTransaction(n){try{const{data:t,error:a}=await this.getTransactionById(n);return a||!t?{data:null,error:a||new Error("Transaction not found")}:t.status!=="pending"&&t.status!=="processing"?{data:null,error:new Error("Transaction cannot be cancelled in current status")}:this.updateTransactionStatus(n,"cancelled")}catch(t){return console.error("Error cancelling transaction:",t),{data:null,error:t}}}static async exportTransactionsToCSV(n,t){const{data:a}=await this.getUserTransactions(n,t);if(!a||a.length===0)return"No transactions found";const e=["Date","Type","Status","Amount","Currency","Blockchain","TX Hash","Description"],r=a.map(o=>[new Date(o.created_at).toLocaleString(),o.type,o.status,o.amount.toString(),o.currency,o.blockchain||"",o.tx_hash||"",o.description]);return[e,...r].map(o=>o.map(c=>`"${c}"`).join(",")).join(`
`)}static getTransactionTypeDisplay(n){return{deposit:"Deposit",withdrawal:"Withdrawal",mining_reward:"Mining Reward",maintenance_payment:"Maintenance Payment",nft_purchase:"NFT Purchase",nft_sale:"NFT Sale",marketplace_buy:"Marketplace Purchase",marketplace_sell:"Marketplace Sale",upgrade:"Miner Upgrade",reinvest:"Auto Reinvest",foundation_donation:"Foundation Donation",referral_bonus:"Referral Bonus",staking_reward:"Staking Reward"}[n]||n}static getTransactionStatusDisplay(n){return{pending:{label:"Pending",color:"yellow"},processing:{label:"Processing",color:"blue"},completed:{label:"Completed",color:"green"},failed:{label:"Failed",color:"red"},cancelled:{label:"Cancelled",color:"gray"}}[n]||{label:n,color:"gray"}}static formatAmount(n,t){return t==="BTC"?`${n.toFixed(8)} BTC`:t==="USD"||t==="USDT"?`$${n.toFixed(2)}`:t==="TYT"?`${n.toLocaleString()} TYT`:`${n} ${t}`}static getBlockchainExplorerUrl(n,t){return{bitcoin:`https://blockchain.info/tx/${t}`,ethereum:`https://etherscan.io/tx/${t}`,polygon:`https://polygonscan.com/tx/${t}`,solana:`https://solscan.io/tx/${t}`,tron:`https://tronscan.org/#/transaction/${t}`,xrp:`https://xrpscan.com/tx/${t}`,ton:`https://tonscan.org/tx/${t}`}[n.toLowerCase()]||null}}export{d as T};
