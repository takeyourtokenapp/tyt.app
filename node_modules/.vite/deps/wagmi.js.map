{
  "version": 3,
  "sources": ["../../wagmi/node_modules/use-sync-external-store/cjs/use-sync-external-store-shim.development.js", "../../wagmi/node_modules/use-sync-external-store/shim/index.js", "../../wagmi/node_modules/use-sync-external-store/cjs/use-sync-external-store-shim/with-selector.development.js", "../../wagmi/node_modules/use-sync-external-store/shim/with-selector.js", "../../wagmi/src/context.ts", "../../wagmi/src/hydrate.ts", "../../wagmi/src/version.ts", "../../wagmi/src/utils/getVersion.ts", "../../wagmi/src/errors/base.ts", "../../wagmi/src/errors/context.ts", "../../wagmi/node_modules/@wagmi/core/src/query/utils.ts", "../../wagmi/node_modules/@wagmi/core/src/query/call.ts", "../../wagmi/node_modules/@wagmi/core/src/query/connect.ts", "../../wagmi/node_modules/@wagmi/core/src/query/deployContract.ts", "../../wagmi/node_modules/@wagmi/core/src/query/disconnect.ts", "../../wagmi/node_modules/@wagmi/core/src/query/estimateFeesPerGas.ts", "../../wagmi/node_modules/@wagmi/core/src/query/estimateGas.ts", "../../wagmi/node_modules/@wagmi/core/src/query/estimateMaxPriorityFeePerGas.ts", "../../wagmi/node_modules/@wagmi/core/src/query/getBalance.ts", "../../wagmi/node_modules/@wagmi/core/src/query/getBlock.ts", "../../wagmi/node_modules/@wagmi/core/src/query/getBlockNumber.ts", "../../wagmi/node_modules/@wagmi/core/src/query/getBlockTransactionCount.ts", "../../wagmi/node_modules/@wagmi/core/src/query/getBytecode.ts", "../../wagmi/node_modules/@wagmi/core/src/query/getCallsStatus.ts", "../../wagmi/node_modules/@wagmi/core/src/query/getCapabilities.ts", "../../wagmi/node_modules/@wagmi/core/src/query/getConnectorClient.ts", "../../wagmi/node_modules/@wagmi/core/src/query/getEnsAddress.ts", "../../wagmi/node_modules/@wagmi/core/src/query/getEnsAvatar.ts", "../../wagmi/node_modules/@wagmi/core/src/query/getEnsName.ts", "../../wagmi/node_modules/@wagmi/core/src/query/getEnsResolver.ts", "../../wagmi/node_modules/@wagmi/core/src/query/getEnsText.ts", "../../wagmi/node_modules/@wagmi/core/src/query/getFeeHistory.ts", "../../wagmi/node_modules/@wagmi/core/src/query/getGasPrice.ts", "../../wagmi/node_modules/@wagmi/core/src/query/getProof.ts", "../../wagmi/node_modules/@wagmi/core/src/query/getStorageAt.ts", "../../wagmi/node_modules/@wagmi/core/src/query/getTransaction.ts", "../../wagmi/node_modules/@wagmi/core/src/query/getTransactionConfirmations.ts", "../../wagmi/node_modules/@wagmi/core/src/query/getTransactionCount.ts", "../../wagmi/node_modules/@wagmi/core/src/query/getTransactionReceipt.ts", "../../wagmi/node_modules/@wagmi/core/src/query/getWalletClient.ts", "../../wagmi/node_modules/@wagmi/core/src/query/infiniteReadContracts.ts", "../../wagmi/node_modules/@wagmi/core/src/query/prepareTransactionRequest.ts", "../../wagmi/node_modules/@wagmi/core/src/query/readContract.ts", "../../wagmi/node_modules/@wagmi/core/src/query/readContracts.ts", "../../wagmi/node_modules/@wagmi/core/src/query/reconnect.ts", "../../wagmi/node_modules/@wagmi/core/src/query/sendCalls.ts", "../../wagmi/node_modules/@wagmi/core/src/query/sendCallsSync.ts", "../../wagmi/node_modules/@wagmi/core/src/query/sendTransaction.ts", "../../wagmi/node_modules/@wagmi/core/src/query/sendTransactionSync.ts", "../../wagmi/node_modules/@wagmi/core/src/query/showCallsStatus.ts", "../../wagmi/node_modules/@wagmi/core/src/query/signMessage.ts", "../../wagmi/node_modules/@wagmi/core/src/query/signTypedData.ts", "../../wagmi/node_modules/@wagmi/core/src/query/simulateContract.ts", "../../wagmi/node_modules/@wagmi/core/src/query/switchChain.ts", "../../wagmi/node_modules/@wagmi/core/src/query/switchConnection.ts", "../../wagmi/node_modules/@wagmi/core/src/query/verifyMessage.ts", "../../wagmi/node_modules/@wagmi/core/src/query/verifyTypedData.ts", "../../wagmi/node_modules/@wagmi/core/src/query/waitForCallsStatus.ts", "../../wagmi/node_modules/@wagmi/core/src/query/waitForTransactionReceipt.ts", "../../wagmi/node_modules/@wagmi/core/src/query/watchAsset.ts", "../../wagmi/node_modules/@wagmi/core/src/query/writeContract.ts", "../../wagmi/src/utils/query.ts", "../../wagmi/src/hooks/useChainId.ts", "../../wagmi/src/hooks/useConfig.ts", "../../wagmi/src/hooks/useBalance.ts", "../../wagmi/src/hooks/useWatchBlocks.ts", "../../wagmi/src/hooks/useBlock.ts", "../../wagmi/src/hooks/useWatchBlockNumber.ts", "../../wagmi/src/hooks/useBlockNumber.ts", "../../wagmi/src/hooks/useBlockTransactionCount.ts", "../../wagmi/src/hooks/useBytecode.ts", "../../wagmi/src/hooks/useCall.ts", "../../wagmi/node_modules/@wagmi/core/src/actions/watchChains.ts", "../../wagmi/src/hooks/useSyncExternalStoreWithTracked.ts", "../../wagmi/src/hooks/useConnection.ts", "../../wagmi/src/hooks/useCallsStatus.ts", "../../wagmi/src/hooks/useCapabilities.ts", "../../wagmi/src/hooks/useChains.ts", "../../wagmi/src/hooks/useClient.ts", "../../wagmi/src/hooks/useConnect.ts", "../../wagmi/src/hooks/useConnectors.ts", "../../wagmi/src/hooks/useConnectionEffect.ts", "../../wagmi/src/hooks/useConnections.ts", "../../wagmi/src/hooks/useConnectorClient.ts", "../../wagmi/src/hooks/useDeployContract.ts", "../../wagmi/src/hooks/useDisconnect.ts", "../../wagmi/src/hooks/useEnsAddress.ts", "../../wagmi/src/hooks/useEnsAvatar.ts", "../../wagmi/src/hooks/useEnsName.ts", "../../wagmi/src/hooks/useEnsResolver.ts", "../../wagmi/src/hooks/useEnsText.ts", "../../wagmi/src/hooks/useEstimateFeesPerGas.ts", "../../wagmi/src/hooks/useEstimateGas.ts", "../../wagmi/src/hooks/useEstimateMaxPriorityFeePerGas.ts", "../../wagmi/src/hooks/useFeeHistory.ts", "../../wagmi/src/hooks/useGasPrice.ts", "../../wagmi/src/hooks/useInfiniteReadContracts.ts", "../../wagmi/src/hooks/usePrepareTransactionRequest.ts", "../../wagmi/src/hooks/useProof.ts", "../../wagmi/src/hooks/usePublicClient.ts", "../../wagmi/src/hooks/useReadContract.ts", "../../wagmi/src/hooks/useReadContracts.ts", "../../wagmi/src/hooks/useReconnect.ts", "../../wagmi/src/hooks/useSendCalls.ts", "../../wagmi/src/hooks/useSendCallsSync.ts", "../../wagmi/src/hooks/useSendTransaction.ts", "../../wagmi/src/hooks/useSendTransactionSync.ts", "../../wagmi/src/hooks/useShowCallsStatus.ts", "../../wagmi/src/hooks/useSignMessage.ts", "../../wagmi/src/hooks/useSignTypedData.ts", "../../wagmi/src/hooks/useSimulateContract.ts", "../../wagmi/src/hooks/useStorageAt.ts", "../../wagmi/src/hooks/useSwitchChain.ts", "../../wagmi/src/hooks/useSwitchConnection.ts", "../../wagmi/src/hooks/useTransaction.ts", "../../wagmi/src/hooks/useTransactionConfirmations.ts", "../../wagmi/src/hooks/useTransactionCount.ts", "../../wagmi/src/hooks/useTransactionReceipt.ts", "../../wagmi/src/hooks/useVerifyMessage.ts", "../../wagmi/src/hooks/useVerifyTypedData.ts", "../../wagmi/src/hooks/useWaitForCallsStatus.ts", "../../wagmi/src/hooks/useWaitForTransactionReceipt.ts", "../../wagmi/src/hooks/useWalletClient.ts", "../../wagmi/src/hooks/useWatchAsset.ts", "../../wagmi/src/hooks/useWatchContractEvent.ts", "../../wagmi/src/hooks/useWatchPendingTransactions.ts", "../../wagmi/src/hooks/useWriteContract.ts"],
  "sourcesContent": ["/**\n * @license React\n * use-sync-external-store-shim.development.js\n *\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n\"use strict\";\n\"production\" !== process.env.NODE_ENV &&\n  (function () {\n    function is(x, y) {\n      return (x === y && (0 !== x || 1 / x === 1 / y)) || (x !== x && y !== y);\n    }\n    function useSyncExternalStore$2(subscribe, getSnapshot) {\n      didWarnOld18Alpha ||\n        void 0 === React.startTransition ||\n        ((didWarnOld18Alpha = !0),\n        console.error(\n          \"You are using an outdated, pre-release alpha of React 18 that does not support useSyncExternalStore. The use-sync-external-store shim will not work correctly. Upgrade to a newer pre-release.\"\n        ));\n      var value = getSnapshot();\n      if (!didWarnUncachedGetSnapshot) {\n        var cachedValue = getSnapshot();\n        objectIs(value, cachedValue) ||\n          (console.error(\n            \"The result of getSnapshot should be cached to avoid an infinite loop\"\n          ),\n          (didWarnUncachedGetSnapshot = !0));\n      }\n      cachedValue = useState({\n        inst: { value: value, getSnapshot: getSnapshot }\n      });\n      var inst = cachedValue[0].inst,\n        forceUpdate = cachedValue[1];\n      useLayoutEffect(\n        function () {\n          inst.value = value;\n          inst.getSnapshot = getSnapshot;\n          checkIfSnapshotChanged(inst) && forceUpdate({ inst: inst });\n        },\n        [subscribe, value, getSnapshot]\n      );\n      useEffect(\n        function () {\n          checkIfSnapshotChanged(inst) && forceUpdate({ inst: inst });\n          return subscribe(function () {\n            checkIfSnapshotChanged(inst) && forceUpdate({ inst: inst });\n          });\n        },\n        [subscribe]\n      );\n      useDebugValue(value);\n      return value;\n    }\n    function checkIfSnapshotChanged(inst) {\n      var latestGetSnapshot = inst.getSnapshot;\n      inst = inst.value;\n      try {\n        var nextValue = latestGetSnapshot();\n        return !objectIs(inst, nextValue);\n      } catch (error) {\n        return !0;\n      }\n    }\n    function useSyncExternalStore$1(subscribe, getSnapshot) {\n      return getSnapshot();\n    }\n    \"undefined\" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ &&\n      \"function\" ===\n        typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart &&\n      __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(Error());\n    var React = require(\"react\"),\n      objectIs = \"function\" === typeof Object.is ? Object.is : is,\n      useState = React.useState,\n      useEffect = React.useEffect,\n      useLayoutEffect = React.useLayoutEffect,\n      useDebugValue = React.useDebugValue,\n      didWarnOld18Alpha = !1,\n      didWarnUncachedGetSnapshot = !1,\n      shim =\n        \"undefined\" === typeof window ||\n        \"undefined\" === typeof window.document ||\n        \"undefined\" === typeof window.document.createElement\n          ? useSyncExternalStore$1\n          : useSyncExternalStore$2;\n    exports.useSyncExternalStore =\n      void 0 !== React.useSyncExternalStore ? React.useSyncExternalStore : shim;\n    \"undefined\" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ &&\n      \"function\" ===\n        typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop &&\n      __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(Error());\n  })();\n", "'use strict';\n\nif (process.env.NODE_ENV === 'production') {\n  module.exports = require('../cjs/use-sync-external-store-shim.production.js');\n} else {\n  module.exports = require('../cjs/use-sync-external-store-shim.development.js');\n}\n", "/**\n * @license React\n * use-sync-external-store-shim/with-selector.development.js\n *\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n\"use strict\";\n\"production\" !== process.env.NODE_ENV &&\n  (function () {\n    function is(x, y) {\n      return (x === y && (0 !== x || 1 / x === 1 / y)) || (x !== x && y !== y);\n    }\n    \"undefined\" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ &&\n      \"function\" ===\n        typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart &&\n      __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(Error());\n    var React = require(\"react\"),\n      shim = require(\"use-sync-external-store/shim\"),\n      objectIs = \"function\" === typeof Object.is ? Object.is : is,\n      useSyncExternalStore = shim.useSyncExternalStore,\n      useRef = React.useRef,\n      useEffect = React.useEffect,\n      useMemo = React.useMemo,\n      useDebugValue = React.useDebugValue;\n    exports.useSyncExternalStoreWithSelector = function (\n      subscribe,\n      getSnapshot,\n      getServerSnapshot,\n      selector,\n      isEqual\n    ) {\n      var instRef = useRef(null);\n      if (null === instRef.current) {\n        var inst = { hasValue: !1, value: null };\n        instRef.current = inst;\n      } else inst = instRef.current;\n      instRef = useMemo(\n        function () {\n          function memoizedSelector(nextSnapshot) {\n            if (!hasMemo) {\n              hasMemo = !0;\n              memoizedSnapshot = nextSnapshot;\n              nextSnapshot = selector(nextSnapshot);\n              if (void 0 !== isEqual && inst.hasValue) {\n                var currentSelection = inst.value;\n                if (isEqual(currentSelection, nextSnapshot))\n                  return (memoizedSelection = currentSelection);\n              }\n              return (memoizedSelection = nextSnapshot);\n            }\n            currentSelection = memoizedSelection;\n            if (objectIs(memoizedSnapshot, nextSnapshot))\n              return currentSelection;\n            var nextSelection = selector(nextSnapshot);\n            if (void 0 !== isEqual && isEqual(currentSelection, nextSelection))\n              return (memoizedSnapshot = nextSnapshot), currentSelection;\n            memoizedSnapshot = nextSnapshot;\n            return (memoizedSelection = nextSelection);\n          }\n          var hasMemo = !1,\n            memoizedSnapshot,\n            memoizedSelection,\n            maybeGetServerSnapshot =\n              void 0 === getServerSnapshot ? null : getServerSnapshot;\n          return [\n            function () {\n              return memoizedSelector(getSnapshot());\n            },\n            null === maybeGetServerSnapshot\n              ? void 0\n              : function () {\n                  return memoizedSelector(maybeGetServerSnapshot());\n                }\n          ];\n        },\n        [getSnapshot, getServerSnapshot, selector, isEqual]\n      );\n      var value = useSyncExternalStore(subscribe, instRef[0], instRef[1]);\n      useEffect(\n        function () {\n          inst.hasValue = !0;\n          inst.value = value;\n        },\n        [value]\n      );\n      useDebugValue(value);\n      return value;\n    };\n    \"undefined\" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ &&\n      \"function\" ===\n        typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop &&\n      __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(Error());\n  })();\n", "'use strict';\n\nif (process.env.NODE_ENV === 'production') {\n  module.exports = require('../cjs/use-sync-external-store-shim/with-selector.production.js');\n} else {\n  module.exports = require('../cjs/use-sync-external-store-shim/with-selector.development.js');\n}\n", "'use client'\n\nimport type { ResolvedRegister, State } from '@wagmi/core'\nimport { createContext, createElement } from 'react'\nimport { Hydrate } from './hydrate.js'\n\nexport const WagmiContext = createContext<\n  ResolvedRegister['config'] | undefined\n>(undefined)\n\nexport type WagmiProviderProps = {\n  config: ResolvedRegister['config']\n  initialState?: State | undefined\n  reconnectOnMount?: boolean | undefined\n}\n\nexport function WagmiProvider(\n  parameters: React.PropsWithChildren<WagmiProviderProps>,\n) {\n  const { children, config } = parameters\n\n  const props = { value: config }\n  return createElement(\n    Hydrate,\n    parameters,\n    createElement(WagmiContext.Provider, props, children),\n  )\n}\n", "'use client'\n\nimport { hydrate, type ResolvedRegister, type State } from '@wagmi/core'\nimport { type ReactElement, useEffect, useRef } from 'react'\n\nexport type HydrateProps = {\n  config: ResolvedRegister['config']\n  initialState?: State | undefined\n  reconnectOnMount?: boolean | undefined\n}\n\nexport function Hydrate(parameters: React.PropsWithChildren<HydrateProps>) {\n  const { children, config, initialState, reconnectOnMount = true } = parameters\n\n  const { onMount } = hydrate(config, {\n    initialState,\n    reconnectOnMount,\n  })\n\n  // Hydrate for non-SSR\n  if (!config._internal.ssr) onMount()\n\n  // Hydrate for SSR\n  const active = useRef(true)\n  // biome-ignore lint/correctness/useExhaustiveDependencies: `queryKey` not required\n  useEffect(() => {\n    if (!active.current) return\n    if (!config._internal.ssr) return\n    onMount()\n    return () => {\n      active.current = false\n    }\n  }, [])\n\n  return children as ReactElement\n}\n", "export const version = '3.3.4'\n", "import { version } from '../version.js'\n\nexport const getVersion = () => `wagmi@${version}`\n", "import { BaseError as CoreError } from '@wagmi/core'\n\nimport { getVersion } from '../utils/getVersion.js'\n\nexport type BaseErrorType = BaseError & { name: 'WagmiError' }\nexport class BaseError extends CoreError {\n  override name = 'WagmiError'\n  override get docsBaseUrl() {\n    return 'https://wagmi.sh/react'\n  }\n  override get version() {\n    return getVersion()\n  }\n}\n", "import { BaseError } from './base.js'\n\nexport type WagmiProviderNotFoundErrorType = WagmiProviderNotFoundError & {\n  name: 'WagmiProviderNotFoundError'\n}\nexport class WagmiProviderNotFoundError extends BaseError {\n  override name = 'WagmiProviderNotFoundError'\n  constructor() {\n    super('`useConfig` must be used within `WagmiProvider`.', {\n      docsPath: '/api/WagmiProvider',\n    })\n  }\n}\n", "import { type QueryKey, replaceEqualDeep } from '@tanstack/query-core'\nimport type { Connector } from '../createConfig.js'\nimport type { Compute, StrictOmit } from '../types/utils.js'\n\nexport function structuralSharing<data>(\n  oldData: data | undefined,\n  newData: data,\n): data {\n  return replaceEqualDeep(oldData, newData)\n}\n\nexport function hashFn(queryKey: QueryKey): string {\n  return JSON.stringify(queryKey, (_, value) => {\n    if (isPlainObject(value))\n      return Object.keys(value)\n        .sort()\n        .reduce((result, key) => {\n          result[key] = value[key]\n          return result\n        }, {} as any)\n    if (typeof value === 'bigint') return value.toString()\n    return value\n  })\n}\n\n// biome-ignore lint/complexity/noBannedTypes: using\nfunction isPlainObject(value: any): value is Object {\n  if (!hasObjectPrototype(value)) {\n    return false\n  }\n\n  // If has modified constructor\n  const ctor = value.constructor\n  if (typeof ctor === 'undefined') return true\n\n  // If has modified prototype\n  const prot = ctor.prototype\n  if (!hasObjectPrototype(prot)) return false\n\n  // If constructor does not have an Object-specific method\n  // biome-ignore lint/suspicious/noPrototypeBuiltins: using\n  if (!prot.hasOwnProperty('isPrototypeOf')) return false\n\n  // Most likely a plain Object\n  return true\n}\n\nfunction hasObjectPrototype(o: any): boolean {\n  return Object.prototype.toString.call(o) === '[object Object]'\n}\n\nexport function filterQueryOptions<\n  type extends Record<string, unknown> & { connector?: Connector | undefined },\n>(\n  options: type,\n): Compute<\n  StrictOmit<type, 'abi' | 'config' | 'connector' | 'query' | 'watch'> &\n    (type extends { connector?: Connector | undefined }\n      ? { connectorUid?: string }\n      : unknown)\n> {\n  // destructuring is super fast\n  // biome-ignore format: no formatting\n  const {\n    // import('@tanstack/query-core').QueryOptions\n    // biome-ignore lint/correctness/noUnusedVariables: tossing\n    _defaulted, behavior, gcTime, initialData, initialDataUpdatedAt, maxPages, meta, networkMode, queryFn, queryHash, queryKey, queryKeyHashFn, retry, retryDelay, structuralSharing,\n\n    // import('@tanstack/query-core').InfiniteQueryObserverOptions\n    // biome-ignore lint/correctness/noUnusedVariables: tossing\n    getPreviousPageParam, getNextPageParam, initialPageParam,\n\n    // import('@tanstack/react-query').UseQueryOptions\n    // biome-ignore lint/correctness/noUnusedVariables: tossing\n    _optimisticResults, enabled, notifyOnChangeProps, placeholderData, refetchInterval, refetchIntervalInBackground, refetchOnMount, refetchOnReconnect, refetchOnWindowFocus, retryOnMount, select, staleTime, suspense, throwOnError,\n\n    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n    // wagmi\n    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n    // biome-ignore lint/correctness/noUnusedVariables: tossing\n    abi, config, connector, query, watch,\n    ...rest\n  } = options\n  if (connector) return { connectorUid: connector?.uid, ...rest } as never\n  return rest as never\n}\n", "import {\n  type CallErrorType,\n  type CallParameters,\n  type CallReturnType,\n  call,\n} from '../actions/call.js'\nimport type { Config } from '../createConfig.js'\nimport type { ScopeKeyParameter } from '../types/properties.js'\nimport type { QueryOptions, QueryParameter } from '../types/query.js'\nimport type { Compute, ExactPartial } from '../types/utils.js'\nimport { filterQueryOptions } from './utils.js'\n\nexport type CallOptions<config extends Config, selectData = CallData> = Compute<\n  ExactPartial<CallParameters<config>> & ScopeKeyParameter\n> &\n  QueryParameter<\n    CallQueryFnData,\n    CallErrorType,\n    selectData,\n    CallQueryKey<config>\n  >\n\nexport function callQueryOptions<config extends Config, selectData = CallData>(\n  config: config,\n  options: CallOptions<config, selectData> = {},\n): CallQueryOptions<config, selectData> {\n  return {\n    ...options.query,\n    queryFn: async (context) => {\n      const [, { scopeKey: _, ...parameters }] = context.queryKey\n      const data = await call(config, {\n        ...parameters,\n      } as CallParameters)\n      return data ?? null\n    },\n    queryKey: callQueryKey(options),\n  }\n}\n\nexport type CallQueryFnData = CallReturnType\n\nexport type CallData = CallQueryFnData\n\nexport function callQueryKey<config extends Config>(\n  options: Compute<\n    ExactPartial<CallParameters<config>> & ScopeKeyParameter\n  > = {},\n) {\n  return ['call', filterQueryOptions(options)] as const\n}\n\nexport type CallQueryKey<config extends Config> = ReturnType<\n  typeof callQueryKey<config>\n>\n\nexport type CallQueryOptions<\n  config extends Config,\n  selectData = CallData,\n> = QueryOptions<\n  CallQueryFnData,\n  CallErrorType,\n  selectData,\n  CallQueryKey<config>\n>\n", "import type { MutateOptions, MutationOptions } from '@tanstack/query-core'\n\nimport {\n  type ConnectErrorType,\n  type ConnectParameters,\n  type ConnectReturnType,\n  connect,\n} from '../actions/connect.js'\nimport type { CreateConnectorFn } from '../connectors/createConnector.js'\nimport type { Config, Connector } from '../createConfig.js'\nimport type { Compute } from '../types/utils.js'\n\nexport function connectMutationOptions<config extends Config>(config: config) {\n  return {\n    mutationFn(variables) {\n      return connect(config, variables)\n    },\n    mutationKey: ['connect'],\n  } as const satisfies MutationOptions<\n    ConnectData<config, Connector | CreateConnectorFn, boolean>,\n    ConnectErrorType,\n    ConnectVariables<config, Connector | CreateConnectorFn, boolean>\n  >\n}\n\nexport type ConnectData<\n  config extends Config,\n  connector extends Connector | CreateConnectorFn,\n  withCapabilities extends boolean,\n> = ConnectReturnType<config, connector, withCapabilities>\n\nexport type ConnectVariables<\n  config extends Config,\n  connector extends Connector | CreateConnectorFn,\n  withCapabilities extends boolean,\n> = ConnectParameters<config, connector, withCapabilities>\n\nexport type ConnectMutate<config extends Config, context = unknown> = <\n  connector extends\n    | config['connectors'][number]\n    | Connector\n    | CreateConnectorFn,\n  withCapabilities extends boolean = false,\n>(\n  variables: ConnectVariables<config, connector, withCapabilities>,\n  options?:\n    | Compute<\n        MutateOptions<\n          ConnectData<config, connector, withCapabilities>,\n          ConnectErrorType,\n          Compute<ConnectVariables<config, connector, withCapabilities>>,\n          context\n        >\n      >\n    | undefined,\n) => void\n\nexport type ConnectMutateAsync<config extends Config, context = unknown> = <\n  connector extends\n    | config['connectors'][number]\n    | Connector\n    | CreateConnectorFn,\n  withCapabilities extends boolean = false,\n>(\n  variables: ConnectVariables<config, connector, withCapabilities>,\n  options?:\n    | Compute<\n        MutateOptions<\n          ConnectData<config, connector, withCapabilities>,\n          ConnectErrorType,\n          Compute<ConnectVariables<config, connector, withCapabilities>>,\n          context\n        >\n      >\n    | undefined,\n) => Promise<ConnectData<config, connector, withCapabilities>>\n", "import type { MutateOptions, MutationOptions } from '@tanstack/query-core'\nimport type { Abi, ContractConstructorArgs } from 'viem'\n\nimport {\n  type DeployContractErrorType,\n  type DeployContractParameters,\n  type DeployContractReturnType,\n  deployContract,\n} from '../actions/deployContract.js'\nimport type { Config } from '../createConfig.js'\nimport type { Compute } from '../types/utils.js'\n\nexport function deployContractMutationOptions<config extends Config>(\n  config: config,\n) {\n  return {\n    mutationFn(variables) {\n      return deployContract(config, variables)\n    },\n    mutationKey: ['deployContract'],\n  } as const satisfies MutationOptions<\n    DeployContractData,\n    DeployContractErrorType,\n    DeployContractVariables<Abi, config, config['chains'][number]['id']>\n  >\n}\n\nexport type DeployContractData = Compute<DeployContractReturnType>\n\nexport type DeployContractVariables<\n  abi extends Abi | readonly unknown[],\n  config extends Config,\n  chainId extends config['chains'][number]['id'],\n  ///\n  allArgs = ContractConstructorArgs<abi>,\n> = DeployContractParameters<abi, config, chainId, allArgs>\n\nexport type DeployContractMutate<config extends Config, context = unknown> = <\n  abi extends Abi | readonly unknown[],\n  chainId extends config['chains'][number]['id'],\n>(\n  variables: DeployContractVariables<abi, config, chainId>,\n  options?:\n    | Compute<\n        MutateOptions<\n          DeployContractData,\n          DeployContractErrorType,\n          Compute<DeployContractVariables<abi, config, chainId>>,\n          context\n        >\n      >\n    | undefined,\n) => void\n\nexport type DeployContractMutateAsync<\n  config extends Config,\n  context = unknown,\n> = <\n  abi extends Abi | readonly unknown[],\n  chainId extends config['chains'][number]['id'],\n>(\n  variables: DeployContractVariables<abi, config, chainId>,\n  options?:\n    | Compute<\n        MutateOptions<\n          DeployContractData,\n          DeployContractErrorType,\n          Compute<DeployContractVariables<abi, config, chainId>>,\n          context\n        >\n      >\n    | undefined,\n) => Promise<DeployContractData>\n", "import type { MutationOptions } from '@tanstack/query-core'\n\nimport {\n  type DisconnectErrorType,\n  type DisconnectParameters,\n  type DisconnectReturnType,\n  disconnect,\n} from '../actions/disconnect.js'\nimport type { Config } from '../createConfig.js'\nimport type { Mutate, MutateAsync } from './types.js'\n\nexport function disconnectMutationOptions<config extends Config>(\n  config: config,\n) {\n  return {\n    mutationFn(variables) {\n      return disconnect(config, variables)\n    },\n    mutationKey: ['disconnect'],\n  } as const satisfies MutationOptions<\n    DisconnectData,\n    DisconnectErrorType,\n    DisconnectVariables\n  >\n}\n\nexport type DisconnectData = DisconnectReturnType\n\nexport type DisconnectVariables = DisconnectParameters | undefined\n\nexport type DisconnectMutate<context = unknown> = Mutate<\n  DisconnectData,\n  DisconnectErrorType,\n  DisconnectVariables,\n  context\n>\n\nexport type DisconnectMutateAsync<context = unknown> = MutateAsync<\n  DisconnectData,\n  DisconnectErrorType,\n  DisconnectVariables,\n  context\n>\n", "import type { FeeValuesType } from 'viem'\n\nimport {\n  type EstimateFeesPerGasErrorType,\n  type EstimateFeesPerGasParameters,\n  type EstimateFeesPerGasReturnType,\n  estimateFeesPerGas,\n} from '../actions/estimateFeesPerGas.js'\nimport type { Config } from '../createConfig.js'\nimport type { ScopeKeyParameter } from '../types/properties.js'\nimport type { QueryOptions, QueryParameter } from '../types/query.js'\nimport type { Compute, ExactPartial } from '../types/utils.js'\nimport { filterQueryOptions } from './utils.js'\n\nexport type EstimateFeesPerGasOptions<\n  type extends FeeValuesType,\n  config extends Config,\n  selectData = EstimateFeesPerGasData<type>,\n> = Compute<\n  ExactPartial<EstimateFeesPerGasParameters<type, config>> & ScopeKeyParameter\n> &\n  QueryParameter<\n    EstimateFeesPerGasQueryFnData<type>,\n    EstimateFeesPerGasErrorType,\n    selectData,\n    EstimateFeesPerGasQueryKey<config, type>\n  >\n\nexport function estimateFeesPerGasQueryOptions<\n  config extends Config,\n  type extends FeeValuesType = 'eip1559',\n  selectData = EstimateFeesPerGasData<type>,\n>(\n  config: config,\n  options: EstimateFeesPerGasOptions<type, config, selectData> = {},\n): EstimateFeesPerGasQueryOptions<type, config, selectData> {\n  return {\n    ...options.query,\n    queryFn: async (context) => {\n      const [, { scopeKey: _, ...parameters }] = context.queryKey\n      return estimateFeesPerGas(config, parameters)\n    },\n    queryKey: estimateFeesPerGasQueryKey(options),\n  }\n}\n\nexport type EstimateFeesPerGasQueryFnData<type extends FeeValuesType> =\n  EstimateFeesPerGasReturnType<type>\n\nexport type EstimateFeesPerGasData<type extends FeeValuesType> =\n  EstimateFeesPerGasQueryFnData<type>\n\nexport function estimateFeesPerGasQueryKey<\n  config extends Config,\n  type extends FeeValuesType = 'eip1559',\n>(\n  options: Compute<\n    ExactPartial<EstimateFeesPerGasParameters<type, config>> & ScopeKeyParameter\n  > = {},\n) {\n  return ['estimateFeesPerGas', filterQueryOptions(options)] as const\n}\n\nexport type EstimateFeesPerGasQueryKey<\n  config extends Config,\n  type extends FeeValuesType,\n> = ReturnType<typeof estimateFeesPerGasQueryKey<config, type>>\n\nexport type EstimateFeesPerGasQueryOptions<\n  type extends FeeValuesType,\n  config extends Config,\n  selectData = EstimateFeesPerGasData<type>,\n> = QueryOptions<\n  EstimateFeesPerGasQueryFnData<type>,\n  EstimateFeesPerGasErrorType,\n  selectData,\n  EstimateFeesPerGasQueryKey<config, type>\n>\n", "import {\n  type EstimateGasErrorType,\n  type EstimateGasParameters,\n  type EstimateGasReturnType,\n  estimateGas,\n} from '../actions/estimateGas.js'\nimport type { Config } from '../createConfig.js'\nimport type { ScopeKeyParameter } from '../types/properties.js'\nimport type { QueryOptions, QueryParameter } from '../types/query.js'\nimport type { Compute, UnionExactPartial } from '../types/utils.js'\nimport { filterQueryOptions } from './utils.js'\n\nexport type EstimateGasOptions<\n  config extends Config,\n  chainId extends config['chains'][number]['id'] | undefined = undefined,\n  selectData = EstimateGasData,\n> = Compute<\n  UnionExactPartial<EstimateGasParameters<config, chainId>> & ScopeKeyParameter\n> &\n  QueryParameter<\n    EstimateGasQueryFnData,\n    EstimateGasErrorType,\n    selectData,\n    EstimateGasQueryKey<config, chainId>\n  >\n\nexport function estimateGasQueryOptions<\n  config extends Config,\n  chainId extends config['chains'][number]['id'] | undefined = undefined,\n  selectData = EstimateGasData,\n>(\n  config: config,\n  options: EstimateGasOptions<config, chainId, selectData> = {} as any,\n): EstimateGasQueryOptions<config, chainId, selectData> {\n  return {\n    ...options.query,\n    enabled: Boolean(\n      (options.account || options.connector) &&\n        (options.query?.enabled ?? true),\n    ),\n    queryFn: async (context) => {\n      const [, { scopeKey: _, ...parameters }] = context.queryKey\n      if (!parameters.account && !options.connector)\n        throw new Error('account or connector is required')\n      return estimateGas(config, {\n        ...(parameters as any),\n        account: parameters.account,\n        connector: options.connector,\n      })\n    },\n    queryKey: estimateGasQueryKey(options),\n  }\n}\n\nexport type EstimateGasQueryFnData = EstimateGasReturnType\n\nexport type EstimateGasData = EstimateGasQueryFnData\n\nexport function estimateGasQueryKey<\n  config extends Config,\n  chainId extends config['chains'][number]['id'] | undefined = undefined,\n>(\n  options: Compute<\n    UnionExactPartial<EstimateGasParameters<config, chainId>> &\n      ScopeKeyParameter\n  > = {} as any,\n) {\n  return ['estimateGas', filterQueryOptions(options)] as const\n}\n\nexport type EstimateGasQueryKey<\n  config extends Config,\n  chainId extends config['chains'][number]['id'] | undefined = undefined,\n> = ReturnType<typeof estimateGasQueryKey<config, chainId>>\n\nexport type EstimateGasQueryOptions<\n  config extends Config,\n  chainId extends config['chains'][number]['id'] | undefined = undefined,\n  selectData = EstimateGasData,\n> = QueryOptions<\n  EstimateGasQueryFnData,\n  EstimateGasErrorType,\n  selectData,\n  EstimateGasQueryKey<config, chainId>\n>\n", "import {\n  type EstimateMaxPriorityFeePerGasErrorType,\n  type EstimateMaxPriorityFeePerGasParameters,\n  type EstimateMaxPriorityFeePerGasReturnType,\n  estimateMaxPriorityFeePerGas,\n} from '../actions/estimateMaxPriorityFeePerGas.js'\nimport type { Config } from '../createConfig.js'\nimport type { ScopeKeyParameter } from '../types/properties.js'\nimport type { QueryOptions, QueryParameter } from '../types/query.js'\nimport type { Compute, ExactPartial } from '../types/utils.js'\nimport { filterQueryOptions } from './utils.js'\n\nexport type EstimateMaxPriorityFeePerGasOptions<\n  config extends Config,\n  selectData = EstimateMaxPriorityFeePerGasData,\n> = Compute<\n  ExactPartial<EstimateMaxPriorityFeePerGasParameters<config>> &\n    ScopeKeyParameter\n> &\n  QueryParameter<\n    EstimateMaxPriorityFeePerGasQueryFnData,\n    EstimateMaxPriorityFeePerGasErrorType,\n    selectData,\n    EstimateMaxPriorityFeePerGasQueryKey<config>\n  >\n\nexport function estimateMaxPriorityFeePerGasQueryOptions<\n  config extends Config,\n  selectData = EstimateMaxPriorityFeePerGasData,\n>(\n  config: config,\n  options: EstimateMaxPriorityFeePerGasOptions<config, selectData> = {},\n): EstimateMaxPriorityFeePerGasQueryOptions<config, selectData> {\n  return {\n    ...options.query,\n    queryFn: async (context) => {\n      const [, { scopeKey: _, ...parameters }] = context.queryKey\n      return estimateMaxPriorityFeePerGas(config, parameters)\n    },\n    queryKey: estimateMaxPriorityFeePerGasQueryKey(options),\n  }\n}\n\nexport type EstimateMaxPriorityFeePerGasQueryFnData =\n  EstimateMaxPriorityFeePerGasReturnType\n\nexport type EstimateMaxPriorityFeePerGasData =\n  EstimateMaxPriorityFeePerGasQueryFnData\n\nexport function estimateMaxPriorityFeePerGasQueryKey<config extends Config>(\n  options: Compute<\n    ExactPartial<EstimateMaxPriorityFeePerGasParameters<config>> &\n      ScopeKeyParameter\n  > = {},\n) {\n  return ['estimateMaxPriorityFeePerGas', filterQueryOptions(options)] as const\n}\n\nexport type EstimateMaxPriorityFeePerGasQueryKey<config extends Config> =\n  ReturnType<typeof estimateMaxPriorityFeePerGasQueryKey<config>>\n\nexport type EstimateMaxPriorityFeePerGasQueryOptions<\n  config extends Config,\n  selectData = EstimateMaxPriorityFeePerGasData,\n> = QueryOptions<\n  EstimateMaxPriorityFeePerGasQueryFnData,\n  EstimateMaxPriorityFeePerGasErrorType,\n  selectData,\n  EstimateMaxPriorityFeePerGasQueryKey<config>\n>\n", "import {\n  type GetBalanceErrorType,\n  type GetBalanceParameters,\n  type GetBalanceReturnType,\n  getBalance,\n} from '../actions/getBalance.js'\nimport type { Config } from '../createConfig.js'\nimport type { ScopeKeyParameter } from '../types/properties.js'\nimport type { QueryOptions, QueryParameter } from '../types/query.js'\nimport type { Compute, ExactPartial } from '../types/utils.js'\nimport { filterQueryOptions } from './utils.js'\n\nexport type GetBalanceOptions<\n  config extends Config,\n  selectData = GetBalanceData,\n> = Compute<ExactPartial<GetBalanceParameters<config>> & ScopeKeyParameter> &\n  QueryParameter<\n    GetBalanceQueryFnData,\n    GetBalanceErrorType,\n    selectData,\n    GetBalanceQueryKey<config>\n  >\n\nexport function getBalanceQueryOptions<\n  config extends Config,\n  selectData = GetBalanceData,\n>(\n  config: config,\n  options: GetBalanceOptions<config, selectData> = {},\n): GetBalanceQueryOptions<config, selectData> {\n  return {\n    ...options.query,\n    enabled: Boolean(options.address && (options.query?.enabled ?? true)),\n    queryFn: async (context) => {\n      const [, { scopeKey: _, ...parameters }] = context.queryKey\n      if (!parameters.address) throw new Error('address is required')\n      const balance = await getBalance(config, {\n        ...(parameters as GetBalanceParameters),\n        address: parameters.address,\n      })\n      return balance ?? null\n    },\n    queryKey: getBalanceQueryKey(options),\n  }\n}\n\nexport type GetBalanceQueryFnData = Compute<GetBalanceReturnType>\n\nexport type GetBalanceData = GetBalanceQueryFnData\n\nexport function getBalanceQueryKey<config extends Config>(\n  options: Compute<\n    ExactPartial<GetBalanceParameters<config>> & ScopeKeyParameter\n  > = {},\n) {\n  return ['balance', filterQueryOptions(options)] as const\n}\n\nexport type GetBalanceQueryKey<config extends Config> = ReturnType<\n  typeof getBalanceQueryKey<config>\n>\n\nexport type GetBalanceQueryOptions<\n  config extends Config,\n  selectData = GetBalanceData,\n> = QueryOptions<\n  GetBalanceQueryFnData,\n  GetBalanceErrorType,\n  selectData,\n  GetBalanceQueryKey<config>\n>\n", "import type { BlockTag } from 'viem'\n\nimport {\n  type GetBlockErrorType,\n  type GetBlockParameters,\n  type GetBlockReturnType,\n  getBlock,\n} from '../actions/getBlock.js'\nimport type { Config } from '../createConfig.js'\nimport type { ScopeKeyParameter } from '../types/properties.js'\nimport type { QueryOptions, QueryParameter } from '../types/query.js'\nimport type { Compute, ExactPartial } from '../types/utils.js'\nimport { filterQueryOptions } from './utils.js'\n\nexport type GetBlockOptions<\n  includeTransactions extends boolean,\n  blockTag extends BlockTag,\n  config extends Config,\n  chainId extends\n    config['chains'][number]['id'] = config['chains'][number]['id'],\n  selectData = GetBlockData<includeTransactions, blockTag, config, chainId>,\n> = Compute<\n  ExactPartial<\n    GetBlockParameters<includeTransactions, blockTag, config, chainId>\n  > &\n    ScopeKeyParameter\n> &\n  QueryParameter<\n    GetBlockQueryFnData<includeTransactions, blockTag, config, chainId>,\n    GetBlockErrorType,\n    selectData,\n    GetBlockQueryKey<includeTransactions, blockTag, config, chainId>\n  >\n\nexport function getBlockQueryOptions<\n  config extends Config,\n  chainId extends config['chains'][number]['id'],\n  includeTransactions extends boolean = false,\n  blockTag extends BlockTag = 'latest',\n  selectData = GetBlockData<includeTransactions, blockTag, config, chainId>,\n>(\n  config: config,\n  options: GetBlockOptions<\n    includeTransactions,\n    blockTag,\n    config,\n    chainId,\n    selectData\n  > = {},\n): GetBlockQueryOptions<\n  includeTransactions,\n  blockTag,\n  config,\n  chainId,\n  selectData\n> {\n  return {\n    ...options.query,\n    queryFn: async (context) => {\n      const [, { scopeKey: _, ...parameters }] = context.queryKey\n      const block = await getBlock(config, parameters as any)\n      return (block ?? null) as any\n    },\n    queryKey: getBlockQueryKey(options),\n  }\n}\n\nexport type GetBlockQueryFnData<\n  includeTransactions extends boolean,\n  blockTag extends BlockTag,\n  config extends Config,\n  chainId extends config['chains'][number]['id'],\n> = GetBlockReturnType<includeTransactions, blockTag, config, chainId>\n\nexport type GetBlockData<\n  includeTransactions extends boolean,\n  blockTag extends BlockTag,\n  config extends Config,\n  chainId extends config['chains'][number]['id'],\n> = GetBlockQueryFnData<includeTransactions, blockTag, config, chainId>\n\nexport function getBlockQueryKey<\n  config extends Config,\n  chainId extends config['chains'][number]['id'],\n  includeTransactions extends boolean = false,\n  blockTag extends BlockTag = 'latest',\n>(\n  options: Compute<\n    ExactPartial<\n      GetBlockParameters<includeTransactions, blockTag, config, chainId>\n    > &\n      ScopeKeyParameter\n  > = {},\n) {\n  return ['block', filterQueryOptions(options)] as const\n}\n\nexport type GetBlockQueryKey<\n  includeTransactions extends boolean,\n  blockTag extends BlockTag,\n  config extends Config,\n  chainId extends config['chains'][number]['id'],\n> = ReturnType<\n  typeof getBlockQueryKey<config, chainId, includeTransactions, blockTag>\n>\n\nexport type GetBlockQueryOptions<\n  includeTransactions extends boolean,\n  blockTag extends BlockTag,\n  config extends Config,\n  chainId extends config['chains'][number]['id'],\n  selectData = GetBlockData<includeTransactions, blockTag, config, chainId>,\n> = QueryOptions<\n  GetBlockQueryFnData<includeTransactions, blockTag, config, chainId>,\n  GetBlockErrorType,\n  selectData,\n  GetBlockQueryKey<includeTransactions, blockTag, config, chainId>\n>\n", "import {\n  type GetBlockNumberErrorType,\n  type GetBlockNumberParameters,\n  type GetBlockNumberReturnType,\n  getBlockNumber,\n} from '../actions/getBlockNumber.js'\nimport type { Config } from '../createConfig.js'\nimport type { ScopeKeyParameter } from '../types/properties.js'\nimport type { QueryOptions, QueryParameter } from '../types/query.js'\nimport type { Compute, ExactPartial } from '../types/utils.js'\nimport { filterQueryOptions } from './utils.js'\n\nexport type GetBlockNumberOptions<\n  config extends Config,\n  chainId extends config['chains'][number]['id'],\n  selectData = GetBlockNumberData,\n> = Compute<\n  ExactPartial<GetBlockNumberParameters<config, chainId>> & ScopeKeyParameter\n> &\n  QueryParameter<\n    GetBlockNumberQueryFnData,\n    GetBlockNumberErrorType,\n    selectData,\n    GetBlockNumberQueryKey<config, chainId>\n  >\n\nexport function getBlockNumberQueryOptions<\n  config extends Config,\n  chainId extends config['chains'][number]['id'],\n  selectData = GetBlockNumberData,\n>(\n  config: config,\n  options: GetBlockNumberOptions<config, chainId, selectData> = {},\n): GetBlockNumberQueryOptions<config, chainId, selectData> {\n  return {\n    ...options.query,\n    gcTime: 0,\n    queryFn: async (context) => {\n      const [, { scopeKey: _, ...parameters }] = context.queryKey\n      const blockNumber = await getBlockNumber(config, parameters)\n      return blockNumber ?? null\n    },\n    queryKey: getBlockNumberQueryKey(options),\n  }\n}\n\nexport type GetBlockNumberQueryFnData = GetBlockNumberReturnType\n\nexport type GetBlockNumberData = GetBlockNumberQueryFnData\n\nexport function getBlockNumberQueryKey<\n  config extends Config,\n  chainId extends config['chains'][number]['id'],\n>(\n  options: Compute<\n    ExactPartial<GetBlockNumberParameters<config, chainId>> & ScopeKeyParameter\n  > = {},\n) {\n  return ['blockNumber', filterQueryOptions(options)] as const\n}\n\nexport type GetBlockNumberQueryKey<\n  config extends Config,\n  chainId extends config['chains'][number]['id'],\n> = ReturnType<typeof getBlockNumberQueryKey<config, chainId>>\n\nexport type GetBlockNumberQueryOptions<\n  config extends Config,\n  chainId extends config['chains'][number]['id'],\n  selectData = GetBlockNumberData,\n> = QueryOptions<\n  GetBlockNumberQueryFnData,\n  GetBlockNumberErrorType,\n  selectData,\n  GetBlockNumberQueryKey<config, chainId>\n>\n", "import {\n  type GetBlockTransactionCountErrorType,\n  type GetBlockTransactionCountParameters,\n  type GetBlockTransactionCountReturnType,\n  getBlockTransactionCount,\n} from '../actions/getBlockTransactionCount.js'\nimport type { Config } from '../createConfig.js'\nimport type { ScopeKeyParameter } from '../types/properties.js'\nimport type { QueryOptions, QueryParameter } from '../types/query.js'\nimport type { ExactPartial, UnionCompute } from '../types/utils.js'\nimport { filterQueryOptions } from './utils.js'\n\nexport type GetBlockTransactionCountOptions<\n  config extends Config,\n  chainId extends config['chains'][number]['id'],\n  selectData = GetBlockTransactionCountData,\n> = UnionCompute<\n  ExactPartial<GetBlockTransactionCountParameters<config, chainId>> &\n    ScopeKeyParameter\n> &\n  QueryParameter<\n    GetBlockTransactionCountQueryFnData,\n    GetBlockTransactionCountErrorType,\n    selectData,\n    GetBlockTransactionCountQueryKey<config, chainId>\n  >\n\nexport function getBlockTransactionCountQueryOptions<\n  config extends Config,\n  chainId extends config['chains'][number]['id'],\n  selectData = GetBlockTransactionCountData,\n>(\n  config: config,\n  options: GetBlockTransactionCountOptions<config, chainId, selectData> = {},\n): GetBlockTransactionCountQueryOptions<config, chainId, selectData> {\n  return {\n    ...options.query,\n    queryFn: async (context) => {\n      const [, { scopeKey: _, ...parameters }] = context.queryKey\n      const blockTransactionCount = await getBlockTransactionCount(\n        config,\n        parameters as any,\n      )\n      return blockTransactionCount ?? null\n    },\n    queryKey: getBlockTransactionCountQueryKey(options),\n  }\n}\n\nexport type GetBlockTransactionCountQueryFnData =\n  GetBlockTransactionCountReturnType\n\nexport type GetBlockTransactionCountData = GetBlockTransactionCountQueryFnData\n\nexport function getBlockTransactionCountQueryKey<\n  config extends Config,\n  chainId extends config['chains'][number]['id'],\n>(\n  options: UnionCompute<\n    ExactPartial<GetBlockTransactionCountParameters<config, chainId>> &\n      ScopeKeyParameter\n  > = {},\n) {\n  return ['blockTransactionCount', filterQueryOptions(options)] as const\n}\n\nexport type GetBlockTransactionCountQueryKey<\n  config extends Config,\n  chainId extends config['chains'][number]['id'],\n> = ReturnType<typeof getBlockTransactionCountQueryKey<config, chainId>>\n\nexport type GetBlockTransactionCountQueryOptions<\n  config extends Config,\n  chainId extends config['chains'][number]['id'],\n  selectData = GetBlockTransactionCountData,\n> = QueryOptions<\n  GetBlockTransactionCountQueryFnData,\n  GetBlockTransactionCountErrorType,\n  selectData,\n  GetBlockTransactionCountQueryKey<config, chainId>\n>\n", "import {\n  type GetBytecodeErrorType,\n  type GetBytecodeParameters,\n  type GetBytecodeReturnType,\n  getBytecode,\n} from '../actions/getBytecode.js'\nimport type { Config } from '../createConfig.js'\nimport type { ScopeKeyParameter } from '../types/properties.js'\nimport type { QueryOptions, QueryParameter } from '../types/query.js'\nimport type { Compute, ExactPartial } from '../types/utils.js'\nimport { filterQueryOptions } from './utils.js'\n\nexport type GetBytecodeOptions<\n  config extends Config,\n  selectData = GetBytecodeData,\n> = Compute<ExactPartial<GetBytecodeParameters<config>> & ScopeKeyParameter> &\n  QueryParameter<\n    GetBytecodeQueryFnData,\n    GetBytecodeErrorType,\n    selectData,\n    GetBytecodeQueryKey<config>\n  >\n\nexport function getBytecodeQueryOptions<\n  config extends Config,\n  selectData = GetBytecodeData,\n>(\n  config: config,\n  options: GetBytecodeOptions<config, selectData> = {},\n): GetBytecodeQueryOptions<config, selectData> {\n  return {\n    ...options.query,\n    enabled: Boolean(options.address && (options.query?.enabled ?? true)),\n    queryFn: async (context) => {\n      const [, { scopeKey: _, ...parameters }] = context.queryKey\n      if (!parameters.address) throw new Error('address is required')\n      const bytecode = await getBytecode(config, {\n        ...(parameters as any),\n        address: parameters.address,\n      })\n      return (bytecode ?? null) as any\n    },\n    queryKey: getBytecodeQueryKey(options),\n  }\n}\n\nexport type GetBytecodeQueryFnData = GetBytecodeReturnType\n\nexport type GetBytecodeData = GetBytecodeQueryFnData\n\nexport function getBytecodeQueryKey<config extends Config>(\n  options: Compute<\n    ExactPartial<GetBytecodeParameters<config>> & ScopeKeyParameter\n  > = {},\n) {\n  return ['getBytecode', filterQueryOptions(options)] as const\n}\n\nexport type GetBytecodeQueryKey<config extends Config> = ReturnType<\n  typeof getBytecodeQueryKey<config>\n>\n\nexport type GetBytecodeQueryOptions<\n  config extends Config,\n  selectData = GetBytecodeData,\n> = QueryOptions<\n  GetBytecodeQueryFnData,\n  GetBytecodeErrorType,\n  selectData,\n  GetBytecodeQueryKey<config>\n>\n", "import {\n  type GetCallsStatusErrorType,\n  type GetCallsStatusParameters,\n  type GetCallsStatusReturnType,\n  getCallsStatus,\n} from '../actions/getCallsStatus.js'\nimport type { Config } from '../createConfig.js'\nimport { filterQueryOptions } from '../query/utils.js'\nimport type { ScopeKeyParameter } from '../types/properties.js'\nimport type { QueryOptions, QueryParameter } from '../types/query.js'\nimport type { Compute } from '../types/utils.js'\n\nexport type GetCallsStatusOptions<selectData = GetCallsStatusData> = Compute<\n  GetCallsStatusParameters & ScopeKeyParameter\n> &\n  QueryParameter<\n    GetCallsStatusQueryFnData,\n    GetCallsStatusErrorType,\n    selectData,\n    GetCallsStatusQueryKey\n  >\n\nexport function getCallsStatusQueryOptions<\n  config extends Config,\n  selectData = GetCallsStatusData,\n>(\n  config: config,\n  options: GetCallsStatusOptions<selectData>,\n): GetCallsStatusQueryOptions<selectData> {\n  return {\n    ...options.query,\n    enabled: Boolean(\n      options.connector?.getProvider && (options.query?.enabled ?? true),\n    ),\n    queryFn: async (context) => {\n      if (!options.connector?.getProvider)\n        throw new Error('connector is required')\n      const [, { connectorUid: _, scopeKey: __, ...parameters }] =\n        context.queryKey\n      const status = await getCallsStatus(config, parameters)\n      return status\n    },\n    queryKey: getCallsStatusQueryKey(options),\n  }\n}\n\nexport type GetCallsStatusQueryFnData = GetCallsStatusReturnType\n\nexport type GetCallsStatusData = GetCallsStatusQueryFnData\n\nexport function getCallsStatusQueryKey(\n  options: Compute<GetCallsStatusParameters & ScopeKeyParameter>,\n) {\n  return ['callsStatus', filterQueryOptions(options)] as const\n}\n\nexport type GetCallsStatusQueryKey = ReturnType<typeof getCallsStatusQueryKey>\n\nexport type GetCallsStatusQueryOptions<selectData = GetCallsStatusData> =\n  QueryOptions<\n    GetCallsStatusQueryFnData,\n    GetCallsStatusErrorType,\n    selectData,\n    GetCallsStatusQueryKey\n  >\n", "import {\n  type GetCapabilitiesErrorType,\n  type GetCapabilitiesParameters,\n  type GetCapabilitiesReturnType,\n  getCapabilities,\n} from '../actions/getCapabilities.js'\nimport type { Config } from '../createConfig.js'\nimport { filterQueryOptions } from '../query/utils.js'\nimport type { ScopeKeyParameter } from '../types/properties.js'\nimport type { QueryOptions, QueryParameter } from '../types/query.js'\nimport type { Compute, ExactPartial } from '../types/utils.js'\n\nexport type GetCapabilitiesOptions<\n  config extends Config = Config,\n  chainId extends config['chains'][number]['id'] | undefined = undefined,\n  selectData = GetCapabilitiesData<config, chainId>,\n> = Compute<\n  ExactPartial<GetCapabilitiesParameters<config, chainId>> & ScopeKeyParameter\n> &\n  QueryParameter<\n    GetCapabilitiesQueryFnData<config, chainId>,\n    GetCapabilitiesErrorType,\n    selectData,\n    GetCapabilitiesQueryKey<config, chainId>\n  >\n\nexport function getCapabilitiesQueryOptions<\n  config extends Config,\n  chainId extends config['chains'][number]['id'] | undefined = undefined,\n  selectData = GetCapabilitiesData<config, chainId>,\n>(\n  config: config,\n  options: GetCapabilitiesOptions<config, chainId, selectData> = {},\n): GetCapabilitiesQueryOptions<config, chainId, selectData> {\n  return {\n    ...options.query,\n    enabled: Boolean(\n      options.connector?.getProvider && (options.query?.enabled ?? true),\n    ),\n    queryFn: async (context) => {\n      if (!options.connector?.getProvider)\n        throw new Error('connector is required')\n      const [, { connectorUid: _, scopeKey: __, ...parameters }] =\n        context.queryKey\n      const capabilities = await getCapabilities(config, parameters)\n      return capabilities\n    },\n    queryKey: getCapabilitiesQueryKey(options),\n  }\n}\n\nexport type GetCapabilitiesQueryFnData<\n  config extends Config = Config,\n  chainId extends config['chains'][number]['id'] | undefined = undefined,\n> = GetCapabilitiesReturnType<config, chainId>\n\nexport type GetCapabilitiesData<\n  config extends Config = Config,\n  chainId extends config['chains'][number]['id'] | undefined = undefined,\n> = GetCapabilitiesQueryFnData<config, chainId>\n\nexport function getCapabilitiesQueryKey<\n  config extends Config,\n  chainId extends config['chains'][number]['id'] | undefined = undefined,\n>(\n  options: Compute<\n    ExactPartial<GetCapabilitiesParameters<config, chainId>> & ScopeKeyParameter\n  > = {},\n) {\n  return ['capabilities', filterQueryOptions(options)] as const\n}\n\nexport type GetCapabilitiesQueryKey<\n  config extends Config,\n  chainId extends config['chains'][number]['id'] | undefined = undefined,\n> = ReturnType<typeof getCapabilitiesQueryKey<config, chainId>>\n\nexport type GetCapabilitiesQueryOptions<\n  config extends Config,\n  chainId extends config['chains'][number]['id'] | undefined = undefined,\n  selectData = GetCapabilitiesData<config, chainId>,\n> = QueryOptions<\n  GetCapabilitiesQueryFnData<config, chainId>,\n  GetCapabilitiesErrorType,\n  selectData,\n  GetCapabilitiesQueryKey<config, chainId>\n>\n", "import {\n  type GetConnectorClientErrorType,\n  type GetConnectorClientParameters,\n  type GetConnectorClientReturnType,\n  getConnectorClient,\n} from '../actions/getConnectorClient.js'\nimport type { Config } from '../createConfig.js'\nimport type { ScopeKeyParameter } from '../types/properties.js'\nimport type { QueryOptions, QueryParameter } from '../types/query.js'\nimport type { Compute, ExactPartial } from '../types/utils.js'\nimport { filterQueryOptions } from './utils.js'\n\nexport type GetConnectorClientOptions<\n  config extends Config,\n  chainId extends config['chains'][number]['id'],\n  selectData = GetConnectorClientData<config, chainId>,\n> = Compute<\n  ExactPartial<GetConnectorClientParameters<config, chainId>> &\n    ScopeKeyParameter\n> &\n  Omit<\n    QueryParameter<\n      GetConnectorClientQueryFnData<config, chainId>,\n      GetConnectorClientErrorType,\n      selectData,\n      GetConnectorClientQueryKey<config, chainId>\n    >,\n    'gcTime' | 'staleTime'\n  >\n\nexport function getConnectorClientQueryOptions<\n  config extends Config,\n  chainId extends config['chains'][number]['id'],\n  selectData = GetConnectorClientData<config, chainId>,\n>(\n  config: config,\n  options: GetConnectorClientOptions<config, chainId, selectData> = {},\n): GetConnectorClientQueryOptions<config, chainId, selectData> {\n  return {\n    ...options.query,\n    enabled: Boolean(\n      options.connector?.getProvider && (options.query?.enabled ?? true),\n    ),\n    gcTime: 0,\n    queryFn: async (context) => {\n      const [, { connectorUid: _, scopeKey: __, ...parameters }] =\n        context.queryKey\n      return getConnectorClient(config, {\n        ...parameters,\n        connector: options.connector,\n      }) as unknown as Promise<GetConnectorClientReturnType<config, chainId>>\n    },\n    queryKey: getConnectorClientQueryKey(options),\n    staleTime: Number.POSITIVE_INFINITY,\n  }\n}\n\nexport type GetConnectorClientQueryFnData<\n  config extends Config,\n  chainId extends config['chains'][number]['id'],\n> = GetConnectorClientReturnType<config, chainId>\n\nexport type GetConnectorClientData<\n  config extends Config,\n  chainId extends config['chains'][number]['id'],\n> = GetConnectorClientQueryFnData<config, chainId>\n\nexport function getConnectorClientQueryKey<\n  config extends Config,\n  chainId extends config['chains'][number]['id'],\n>(\n  options: Compute<\n    ExactPartial<GetConnectorClientParameters<config, chainId>> &\n      ScopeKeyParameter\n  > = {},\n) {\n  return ['connectorClient', filterQueryOptions(options)] as const\n}\n\nexport type GetConnectorClientQueryKey<\n  config extends Config,\n  chainId extends config['chains'][number]['id'],\n> = ReturnType<typeof getConnectorClientQueryKey<config, chainId>>\n\nexport type GetConnectorClientQueryOptions<\n  config extends Config,\n  chainId extends config['chains'][number]['id'],\n  selectData = GetConnectorClientData<config, chainId>,\n> = QueryOptions<\n  GetConnectorClientQueryFnData<config, chainId>,\n  GetConnectorClientErrorType,\n  selectData,\n  GetConnectorClientQueryKey<config, chainId>\n>\n", "import {\n  type GetEnsAddressErrorType,\n  type GetEnsAddressParameters,\n  type GetEnsAddressReturnType,\n  getEnsAddress,\n} from '../actions/getEnsAddress.js'\nimport type { Config } from '../createConfig.js'\nimport type { ScopeKeyParameter } from '../types/properties.js'\nimport type { QueryOptions, QueryParameter } from '../types/query.js'\nimport type { Compute, ExactPartial } from '../types/utils.js'\nimport { filterQueryOptions } from './utils.js'\n\nexport type GetEnsAddressOptions<\n  config extends Config,\n  selectData = GetEnsAddressData,\n> = Compute<ExactPartial<GetEnsAddressParameters<config>> & ScopeKeyParameter> &\n  QueryParameter<\n    GetEnsAddressQueryFnData,\n    GetEnsAddressErrorType,\n    selectData,\n    GetEnsAddressQueryKey<config>\n  >\n\nexport function getEnsAddressQueryOptions<\n  config extends Config,\n  selectData = GetEnsAddressData,\n>(\n  config: config,\n  options: GetEnsAddressOptions<config, selectData> = {},\n): GetEnsAddressQueryOptions<config, selectData> {\n  return {\n    ...options.query,\n    enabled: Boolean(options.name && (options.query?.enabled ?? true)),\n    queryFn: async (context) => {\n      const [, { scopeKey: _, ...parameters }] = context.queryKey\n      if (!parameters.name) throw new Error('name is required')\n      return getEnsAddress(config, { ...parameters, name: parameters.name })\n    },\n    queryKey: getEnsAddressQueryKey(options),\n  }\n}\n\nexport type GetEnsAddressQueryFnData = GetEnsAddressReturnType\n\nexport type GetEnsAddressData = GetEnsAddressQueryFnData\n\nexport function getEnsAddressQueryKey<config extends Config>(\n  options: Compute<\n    ExactPartial<GetEnsAddressParameters<config>> & ScopeKeyParameter\n  > = {},\n) {\n  return ['ensAddress', filterQueryOptions(options)] as const\n}\n\nexport type GetEnsAddressQueryKey<config extends Config> = ReturnType<\n  typeof getEnsAddressQueryKey<config>\n>\n\nexport type GetEnsAddressQueryOptions<\n  config extends Config,\n  selectData = GetEnsAddressData,\n> = QueryOptions<\n  GetEnsAddressQueryFnData,\n  GetEnsAddressErrorType,\n  selectData,\n  GetEnsAddressQueryKey<config>\n>\n", "import {\n  type GetEnsAvatarErrorType,\n  type GetEnsAvatarParameters,\n  type GetEnsAvatarReturnType,\n  getEnsAvatar,\n} from '../actions/getEnsAvatar.js'\nimport type { Config } from '../createConfig.js'\nimport type { ScopeKeyParameter } from '../types/properties.js'\nimport type { QueryOptions, QueryParameter } from '../types/query.js'\nimport type { Compute, ExactPartial } from '../types/utils.js'\nimport { filterQueryOptions } from './utils.js'\n\nexport type GetEnsAvatarOptions<\n  config extends Config,\n  selectData = GetEnsAvatarData,\n> = Compute<ExactPartial<GetEnsAvatarParameters<config>> & ScopeKeyParameter> &\n  QueryParameter<\n    GetEnsAvatarQueryFnData,\n    GetEnsAvatarErrorType,\n    selectData,\n    GetEnsAvatarQueryKey<config>\n  >\n\nexport function getEnsAvatarQueryOptions<\n  config extends Config,\n  selectData = GetEnsAvatarData,\n>(\n  config: config,\n  options: GetEnsAvatarOptions<config, selectData> = {},\n): GetEnsAvatarQueryOptions<config, selectData> {\n  return {\n    ...options.query,\n    enabled: Boolean(options.name && (options.query?.enabled ?? true)),\n    queryFn: async (context) => {\n      const [, { scopeKey: _, ...parameters }] = context.queryKey\n      if (!parameters.name) throw new Error('name is required')\n      return getEnsAvatar(config, { ...parameters, name: parameters.name })\n    },\n    queryKey: getEnsAvatarQueryKey(options),\n  }\n}\n\nexport type GetEnsAvatarQueryFnData = GetEnsAvatarReturnType\n\nexport type GetEnsAvatarData = GetEnsAvatarQueryFnData\n\nexport function getEnsAvatarQueryKey<config extends Config>(\n  options: Compute<\n    ExactPartial<GetEnsAvatarParameters<config>> & ScopeKeyParameter\n  > = {},\n) {\n  return ['ensAvatar', filterQueryOptions(options)] as const\n}\n\nexport type GetEnsAvatarQueryKey<config extends Config> = ReturnType<\n  typeof getEnsAvatarQueryKey<config>\n>\n\nexport type GetEnsAvatarQueryOptions<\n  config extends Config,\n  selectData = GetEnsAvatarData,\n> = QueryOptions<\n  GetEnsAvatarQueryFnData,\n  GetEnsAvatarErrorType,\n  selectData,\n  GetEnsAvatarQueryKey<config>\n>\n", "import {\n  type GetEnsNameErrorType,\n  type GetEnsNameParameters,\n  type GetEnsNameReturnType,\n  getEnsName,\n} from '../actions/getEnsName.js'\nimport type { Config } from '../createConfig.js'\nimport type { ScopeKeyParameter } from '../types/properties.js'\nimport type { QueryOptions, QueryParameter } from '../types/query.js'\nimport type { Compute, ExactPartial } from '../types/utils.js'\nimport { filterQueryOptions } from './utils.js'\n\nexport type GetEnsNameOptions<\n  config extends Config,\n  selectData = GetEnsNameData,\n> = Compute<ExactPartial<GetEnsNameParameters<config>> & ScopeKeyParameter> &\n  QueryParameter<\n    GetEnsNameQueryFnData,\n    GetEnsNameErrorType,\n    selectData,\n    GetEnsNameQueryKey<config>\n  >\n\nexport function getEnsNameQueryOptions<\n  config extends Config,\n  selectData = GetEnsNameData,\n>(\n  config: config,\n  options: GetEnsNameOptions<config, selectData> = {},\n): GetEnsNameQueryOptions<config, selectData> {\n  return {\n    ...options.query,\n    enabled: Boolean(options.address && (options.query?.enabled ?? true)),\n    queryFn: async (context) => {\n      const [, { scopeKey: _, ...parameters }] = context.queryKey\n      if (!parameters.address) throw new Error('address is required')\n      return getEnsName(config, { ...parameters, address: parameters.address })\n    },\n    queryKey: getEnsNameQueryKey(options),\n  }\n}\n\nexport type GetEnsNameQueryFnData = GetEnsNameReturnType\n\nexport type GetEnsNameData = GetEnsNameQueryFnData\n\nexport function getEnsNameQueryKey<config extends Config>(\n  options: Compute<\n    ExactPartial<GetEnsNameParameters<config>> & ScopeKeyParameter\n  > = {},\n) {\n  return ['ensName', filterQueryOptions(options)] as const\n}\n\nexport type GetEnsNameQueryKey<config extends Config> = ReturnType<\n  typeof getEnsNameQueryKey<config>\n>\n\nexport type GetEnsNameQueryOptions<\n  config extends Config,\n  selectData = GetEnsNameData,\n> = QueryOptions<\n  GetEnsNameQueryFnData,\n  GetEnsNameErrorType,\n  selectData,\n  GetEnsNameQueryKey<config>\n>\n", "import {\n  type GetEnsResolverErrorType,\n  type GetEnsResolverParameters,\n  type GetEnsResolverReturnType,\n  getEnsResolver,\n} from '../actions/getEnsResolver.js'\nimport type { Config } from '../createConfig.js'\nimport type { ScopeKeyParameter } from '../types/properties.js'\nimport type { QueryOptions, QueryParameter } from '../types/query.js'\nimport type { Compute, ExactPartial } from '../types/utils.js'\nimport { filterQueryOptions } from './utils.js'\n\nexport type GetEnsResolverOptions<\n  config extends Config,\n  selectData = GetEnsResolverData,\n> = Compute<\n  ExactPartial<GetEnsResolverParameters<config>> & ScopeKeyParameter\n> &\n  QueryParameter<\n    GetEnsResolverQueryFnData,\n    GetEnsResolverErrorType,\n    selectData,\n    GetEnsResolverQueryKey<config>\n  >\n\nexport function getEnsResolverQueryOptions<\n  config extends Config,\n  selectData = GetEnsResolverData,\n>(\n  config: config,\n  options: GetEnsResolverOptions<config, selectData> = {},\n): GetEnsResolverQueryOptions<config, selectData> {\n  return {\n    ...options.query,\n    enabled: Boolean(options.name && (options.query?.enabled ?? true)),\n    queryFn: async (context) => {\n      const [, { scopeKey: _, ...parameters }] = context.queryKey\n      if (!parameters.name) throw new Error('name is required')\n      return getEnsResolver(config, { ...parameters, name: parameters.name })\n    },\n    queryKey: getEnsResolverQueryKey(options),\n  }\n}\n\nexport type GetEnsResolverQueryFnData = GetEnsResolverReturnType\n\nexport type GetEnsResolverData = GetEnsResolverQueryFnData\n\nexport function getEnsResolverQueryKey<config extends Config>(\n  options: Compute<\n    ExactPartial<GetEnsResolverParameters<config>> & ScopeKeyParameter\n  > = {},\n) {\n  return ['ensResolver', filterQueryOptions(options)] as const\n}\n\nexport type GetEnsResolverQueryKey<config extends Config> = ReturnType<\n  typeof getEnsResolverQueryKey<config>\n>\n\nexport type GetEnsResolverQueryOptions<\n  config extends Config,\n  selectData = GetEnsResolverData,\n> = QueryOptions<\n  GetEnsResolverQueryFnData,\n  GetEnsResolverErrorType,\n  selectData,\n  GetEnsResolverQueryKey<config>\n>\n", "import {\n  type GetEnsTextErrorType,\n  type GetEnsTextParameters,\n  type GetEnsTextReturnType,\n  getEnsText,\n} from '../actions/getEnsText.js'\nimport type { Config } from '../createConfig.js'\nimport type { ScopeKeyParameter } from '../types/properties.js'\nimport type { QueryOptions, QueryParameter } from '../types/query.js'\nimport type { Compute, ExactPartial } from '../types/utils.js'\nimport { filterQueryOptions } from './utils.js'\n\nexport type GetEnsTextOptions<\n  config extends Config,\n  selectData = GetEnsTextData,\n> = Compute<ExactPartial<GetEnsTextParameters<config>> & ScopeKeyParameter> &\n  QueryParameter<\n    GetEnsTextQueryFnData,\n    GetEnsTextErrorType,\n    selectData,\n    GetEnsTextQueryKey<config>\n  >\n\nexport function getEnsTextQueryOptions<\n  config extends Config,\n  selectData = GetEnsTextData,\n>(\n  config: config,\n  options: GetEnsTextOptions<config, selectData> = {},\n): GetEnsTextQueryOptions<config, selectData> {\n  return {\n    ...options.query,\n    enabled: Boolean(\n      options.key && options.name && (options.query?.enabled ?? true),\n    ),\n    queryFn: async (context) => {\n      const [, { scopeKey: _, ...parameters }] = context.queryKey\n      if (!parameters.key || !parameters.name)\n        throw new Error('key and name are required')\n      return getEnsText(config, {\n        ...parameters,\n        key: parameters.key,\n        name: parameters.name,\n      })\n    },\n    queryKey: getEnsTextQueryKey(options),\n  }\n}\n\nexport type GetEnsTextQueryFnData = GetEnsTextReturnType\n\nexport type GetEnsTextData = GetEnsTextQueryFnData\n\nexport function getEnsTextQueryKey<config extends Config>(\n  options: Compute<\n    ExactPartial<GetEnsTextParameters<config>> & ScopeKeyParameter\n  > = {},\n) {\n  return ['ensText', filterQueryOptions(options)] as const\n}\n\nexport type GetEnsTextQueryKey<config extends Config> = ReturnType<\n  typeof getEnsTextQueryKey<config>\n>\n\nexport type GetEnsTextQueryOptions<\n  config extends Config,\n  selectData = GetEnsTextData,\n> = QueryOptions<\n  GetEnsTextQueryFnData,\n  GetEnsTextErrorType,\n  selectData,\n  GetEnsTextQueryKey<config>\n>\n", "import {\n  type GetFeeHistoryErrorType,\n  type GetFeeHistoryParameters,\n  type GetFeeHistoryReturnType,\n  getFeeHistory,\n} from '../actions/getFeeHistory.js'\nimport type { Config } from '../createConfig.js'\nimport type { ScopeKeyParameter } from '../types/properties.js'\nimport type { QueryOptions, QueryParameter } from '../types/query.js'\nimport type { Compute, ExactPartial } from '../types/utils.js'\nimport { filterQueryOptions } from './utils.js'\n\nexport type GetFeeHistoryOptions<\n  config extends Config,\n  chainId extends config['chains'][number]['id'],\n  selectData = GetFeeHistoryData,\n> = Compute<\n  ExactPartial<GetFeeHistoryParameters<config, chainId>> & ScopeKeyParameter\n> &\n  QueryParameter<\n    GetFeeHistoryQueryFnData,\n    GetFeeHistoryErrorType,\n    selectData,\n    GetFeeHistoryQueryKey<config, chainId>\n  >\n\nexport function getFeeHistoryQueryOptions<\n  config extends Config,\n  chainId extends config['chains'][number]['id'],\n  selectData = GetFeeHistoryData,\n>(\n  config: config,\n  options: GetFeeHistoryOptions<config, chainId, selectData> = {},\n): GetFeeHistoryQueryOptions<config, chainId, selectData> {\n  return {\n    ...options.query,\n    enabled: Boolean(\n      options.blockCount &&\n        options.rewardPercentiles &&\n        (options.query?.enabled ?? true),\n    ),\n    queryFn: async (context) => {\n      const [, { scopeKey: _, ...parameters }] = context.queryKey\n      if (!parameters.blockCount) throw new Error('blockCount is required')\n      if (!parameters.rewardPercentiles)\n        throw new Error('rewardPercentiles is required')\n      const feeHistory = await getFeeHistory(config, {\n        ...(parameters as GetFeeHistoryParameters),\n        blockCount: parameters.blockCount,\n        rewardPercentiles: parameters.rewardPercentiles,\n      })\n      return feeHistory ?? null\n    },\n    queryKey: getFeeHistoryQueryKey(options),\n  }\n}\n\nexport type GetFeeHistoryQueryFnData = GetFeeHistoryReturnType\n\nexport type GetFeeHistoryData = GetFeeHistoryQueryFnData\n\nexport function getFeeHistoryQueryKey<\n  config extends Config,\n  chainId extends config['chains'][number]['id'],\n>(\n  options: Compute<\n    ExactPartial<GetFeeHistoryParameters<config, chainId>> & ScopeKeyParameter\n  > = {},\n) {\n  return ['feeHistory', filterQueryOptions(options)] as const\n}\n\nexport type GetFeeHistoryQueryKey<\n  config extends Config,\n  chainId extends config['chains'][number]['id'],\n> = ReturnType<typeof getFeeHistoryQueryKey<config, chainId>>\n\nexport type GetFeeHistoryQueryOptions<\n  config extends Config,\n  chainId extends config['chains'][number]['id'],\n  selectData = GetFeeHistoryData,\n> = QueryOptions<\n  GetFeeHistoryQueryFnData,\n  GetFeeHistoryErrorType,\n  selectData,\n  GetFeeHistoryQueryKey<config, chainId>\n>\n", "import {\n  type GetGasPriceErrorType,\n  type GetGasPriceParameters,\n  type GetGasPriceReturnType,\n  getGasPrice,\n} from '../actions/getGasPrice.js'\nimport type { Config } from '../createConfig.js'\nimport type { ScopeKeyParameter } from '../types/properties.js'\nimport type { QueryOptions, QueryParameter } from '../types/query.js'\nimport type { Compute, ExactPartial } from '../types/utils.js'\nimport { filterQueryOptions } from './utils.js'\n\nexport type GetGasPriceOptions<\n  config extends Config,\n  chainId extends config['chains'][number]['id'],\n  selectData = GetGasPriceData,\n> = Compute<\n  ExactPartial<GetGasPriceParameters<config, chainId>> & ScopeKeyParameter\n> &\n  QueryParameter<\n    GetGasPriceQueryFnData,\n    GetGasPriceErrorType,\n    selectData,\n    GetGasPriceQueryKey<config, chainId>\n  >\n\nexport function getGasPriceQueryOptions<\n  config extends Config,\n  chainId extends config['chains'][number]['id'],\n  selectData = GetGasPriceData,\n>(\n  config: config,\n  options: GetGasPriceOptions<config, chainId, selectData> = {},\n): GetGasPriceQueryOptions<config, chainId, selectData> {\n  return {\n    ...options.query,\n    queryFn: async (context) => {\n      const [, { scopeKey: _, ...parameters }] = context.queryKey\n      const gasPrice = await getGasPrice(config, parameters)\n      return gasPrice ?? null\n    },\n    queryKey: getGasPriceQueryKey(options),\n  }\n}\n\nexport type GetGasPriceQueryFnData = GetGasPriceReturnType\n\nexport type GetGasPriceData = GetGasPriceQueryFnData\n\nexport function getGasPriceQueryKey<\n  config extends Config,\n  chainId extends config['chains'][number]['id'],\n>(\n  options: Compute<\n    ExactPartial<GetGasPriceParameters<config, chainId>> & ScopeKeyParameter\n  > = {},\n) {\n  return ['gasPrice', filterQueryOptions(options)] as const\n}\n\nexport type GetGasPriceQueryKey<\n  config extends Config,\n  chainId extends config['chains'][number]['id'],\n> = ReturnType<typeof getGasPriceQueryKey<config, chainId>>\n\nexport type GetGasPriceQueryOptions<\n  config extends Config,\n  chainId extends config['chains'][number]['id'],\n  selectData = GetGasPriceData,\n> = QueryOptions<\n  GetGasPriceQueryFnData,\n  GetGasPriceErrorType,\n  selectData,\n  GetGasPriceQueryKey<config, chainId>\n>\n", "import {\n  type GetProofErrorType,\n  type GetProofParameters,\n  type GetProofReturnType,\n  getProof,\n} from '../actions/getProof.js'\nimport type { Config } from '../createConfig.js'\nimport type { ScopeKeyParameter } from '../types/properties.js'\nimport type { QueryOptions, QueryParameter } from '../types/query.js'\nimport type { Compute, ExactPartial } from '../types/utils.js'\nimport { filterQueryOptions } from './utils.js'\n\nexport type GetProofOptions<\n  config extends Config,\n  selectData = GetProofData,\n> = Compute<ExactPartial<GetProofParameters<config>> & ScopeKeyParameter> &\n  QueryParameter<\n    GetProofQueryFnData,\n    GetProofErrorType,\n    selectData,\n    GetProofQueryKey<config>\n  >\n\nexport function getProofQueryOptions<\n  config extends Config,\n  selectData = GetProofData,\n>(\n  config: config,\n  options: GetProofOptions<config, selectData> = {},\n): GetProofQueryOptions<config, selectData> {\n  return {\n    ...options.query,\n    enabled: Boolean(\n      options.address &&\n        options.storageKeys &&\n        (options.query?.enabled ?? true),\n    ),\n    queryFn: async (context) => {\n      const [, { scopeKey: _, ...parameters }] = context.queryKey\n      if (!parameters.address || !parameters.storageKeys)\n        throw new Error('address and storageKeys are required')\n      return getProof(config, {\n        ...(parameters as GetProofParameters),\n        address: parameters.address,\n        storageKeys: parameters.storageKeys,\n      })\n    },\n    queryKey: getProofQueryKey(options),\n  }\n}\n\nexport type GetProofQueryFnData = GetProofReturnType\n\nexport type GetProofData = GetProofQueryFnData\n\nexport function getProofQueryKey<config extends Config>(\n  options: Compute<\n    ExactPartial<GetProofParameters<config>> & ScopeKeyParameter\n  > = {},\n) {\n  return ['getProof', filterQueryOptions(options)] as const\n}\n\nexport type GetProofQueryKey<config extends Config> = ReturnType<\n  typeof getProofQueryKey<config>\n>\n\nexport type GetProofQueryOptions<\n  config extends Config,\n  selectData = GetProofData,\n> = QueryOptions<\n  GetProofQueryFnData,\n  GetProofErrorType,\n  selectData,\n  GetProofQueryKey<config>\n>\n", "import {\n  type GetStorageAtErrorType,\n  type GetStorageAtParameters,\n  type GetStorageAtReturnType,\n  getStorageAt,\n} from '../actions/getStorageAt.js'\nimport type { Config } from '../createConfig.js'\nimport type { ScopeKeyParameter } from '../types/properties.js'\nimport type { QueryOptions, QueryParameter } from '../types/query.js'\nimport type { Compute, ExactPartial } from '../types/utils.js'\nimport { filterQueryOptions } from './utils.js'\n\nexport type GetStorageAtOptions<\n  config extends Config,\n  selectData = GetStorageAtData,\n> = Compute<ExactPartial<GetStorageAtParameters<config>> & ScopeKeyParameter> &\n  QueryParameter<\n    GetStorageAtQueryFnData,\n    GetStorageAtErrorType,\n    selectData,\n    GetStorageAtQueryKey<config>\n  >\n\nexport function getStorageAtQueryOptions<\n  config extends Config,\n  selectData = GetStorageAtData,\n>(\n  config: config,\n  options: GetStorageAtOptions<config, selectData> = {},\n): GetStorageAtQueryOptions<config, selectData> {\n  return {\n    ...options.query,\n    enabled: Boolean(\n      options.address && options.slot && (options.query?.enabled ?? true),\n    ),\n    queryFn: async (context) => {\n      const [, { scopeKey: _, ...parameters }] = context.queryKey\n      if (!parameters.address || !parameters.slot)\n        throw new Error('address and slot are required')\n      return getStorageAt(config, {\n        ...(parameters as GetStorageAtParameters),\n        address: parameters.address,\n        slot: parameters.slot,\n      })\n    },\n    queryKey: getStorageAtQueryKey(options),\n  }\n}\n\nexport type GetStorageAtQueryFnData = GetStorageAtReturnType\n\nexport type GetStorageAtData = GetStorageAtQueryFnData\n\nexport function getStorageAtQueryKey<config extends Config>(\n  options: Compute<\n    ExactPartial<GetStorageAtParameters<config>> & ScopeKeyParameter\n  > = {},\n) {\n  return ['getStorageAt', filterQueryOptions(options)] as const\n}\n\nexport type GetStorageAtQueryKey<config extends Config> = ReturnType<\n  typeof getStorageAtQueryKey<config>\n>\n\nexport type GetStorageAtQueryOptions<\n  config extends Config,\n  selectData = GetStorageAtData,\n> = QueryOptions<\n  GetStorageAtQueryFnData,\n  GetStorageAtErrorType,\n  selectData,\n  GetStorageAtQueryKey<config>\n>\n", "import {\n  type GetTransactionErrorType,\n  type GetTransactionParameters,\n  type GetTransactionReturnType,\n  getTransaction,\n} from '../actions/getTransaction.js'\nimport type { Config } from '../createConfig.js'\nimport type { ScopeKeyParameter } from '../types/properties.js'\nimport type { QueryOptions, QueryParameter } from '../types/query.js'\nimport type { Compute, ExactPartial } from '../types/utils.js'\nimport { filterQueryOptions } from './utils.js'\n\nexport type GetTransactionOptions<\n  config extends Config,\n  chainId extends config['chains'][number]['id'],\n  selectData = GetTransactionData<config, chainId>,\n> = Compute<\n  ExactPartial<GetTransactionParameters<config, chainId>> & ScopeKeyParameter\n> &\n  QueryParameter<\n    GetTransactionQueryFnData<config, chainId>,\n    GetTransactionErrorType,\n    selectData,\n    GetTransactionQueryKey<config, chainId>\n  >\n\nexport function getTransactionQueryOptions<\n  config extends Config,\n  chainId extends config['chains'][number]['id'],\n  selectData = GetTransactionData<config, chainId>,\n>(\n  config: config,\n  options: GetTransactionOptions<config, chainId, selectData> = {},\n): GetTransactionQueryOptions<config, chainId, selectData> {\n  return {\n    ...options.query,\n    enabled: Boolean(\n      (options.hash ||\n        (options.index &&\n          (options.blockHash || options.blockNumber || options.blockTag))) &&\n        (options.query?.enabled ?? true),\n    ),\n    queryFn: async (context) => {\n      const [, { scopeKey: _, ...parameters }] = context.queryKey\n      if (\n        !(\n          parameters.hash ||\n          (parameters.index &&\n            (parameters.blockHash ||\n              parameters.blockNumber ||\n              parameters.blockTag))\n        )\n      )\n        throw new Error(\n          'hash OR index AND blockHash, blockNumber, blockTag is required',\n        )\n      return getTransaction(\n        config,\n        parameters as GetTransactionParameters,\n      ) as unknown as Promise<GetTransactionQueryFnData<config, chainId>>\n    },\n    queryKey: getTransactionQueryKey(options),\n  }\n}\n\nexport type GetTransactionQueryFnData<\n  config extends Config,\n  chainId extends config['chains'][number]['id'],\n> = GetTransactionReturnType<config, chainId>\n\nexport type GetTransactionData<\n  config extends Config,\n  chainId extends config['chains'][number]['id'],\n> = GetTransactionQueryFnData<config, chainId>\n\nexport function getTransactionQueryKey<\n  config extends Config,\n  chainId extends config['chains'][number]['id'],\n>(\n  options: Compute<\n    ExactPartial<GetTransactionParameters<config, chainId>> & ScopeKeyParameter\n  > = {},\n) {\n  return ['transaction', filterQueryOptions(options)] as const\n}\n\nexport type GetTransactionQueryKey<\n  config extends Config,\n  chainId extends config['chains'][number]['id'],\n> = ReturnType<typeof getTransactionQueryKey<config, chainId>>\n\nexport type GetTransactionQueryOptions<\n  config extends Config,\n  chainId extends config['chains'][number]['id'],\n  selectData = GetTransactionData<config, chainId>,\n> = QueryOptions<\n  GetTransactionQueryFnData<config, chainId>,\n  GetTransactionErrorType,\n  selectData,\n  GetTransactionQueryKey<config, chainId>\n>\n", "import {\n  type GetTransactionConfirmationsErrorType,\n  type GetTransactionConfirmationsParameters,\n  type GetTransactionConfirmationsReturnType,\n  getTransactionConfirmations,\n} from '../actions/getTransactionConfirmations.js'\nimport type { Config } from '../createConfig.js'\nimport type { ScopeKeyParameter } from '../types/properties.js'\nimport type { QueryOptions, QueryParameter } from '../types/query.js'\nimport type { UnionExactPartial } from '../types/utils.js'\nimport { filterQueryOptions } from './utils.js'\n\nexport type GetTransactionConfirmationsOptions<\n  config extends Config,\n  chainId extends\n    | config['chains'][number]['id']\n    | undefined = config['chains'][number]['id'],\n  selectData = GetTransactionConfirmationsData,\n> = UnionExactPartial<GetTransactionConfirmationsParameters<config, chainId>> &\n  ScopeKeyParameter &\n  QueryParameter<\n    GetTransactionConfirmationsQueryFnData,\n    GetTransactionConfirmationsErrorType,\n    selectData,\n    GetTransactionConfirmationsQueryKey<config, chainId>\n  >\n\nexport function getTransactionConfirmationsQueryOptions<\n  config extends Config,\n  chainId extends\n    | config['chains'][number]['id']\n    | undefined = config['chains'][number]['id'],\n  selectData = GetTransactionConfirmationsData,\n>(\n  config: config,\n  options: GetTransactionConfirmationsOptions<\n    config,\n    chainId,\n    selectData\n  > = {} as any,\n): GetTransactionConfirmationsQueryOptions<config, chainId, selectData> {\n  return {\n    ...options.query,\n    enabled: Boolean(\n      (options.hash || options.transactionReceipt) &&\n        (options.query?.enabled ?? true),\n    ),\n    queryFn: async (context) => {\n      const [, { scopeKey: _, ...parameters }] = context.queryKey\n      if (!parameters.hash && !parameters.transactionReceipt)\n        throw new Error('hash or transactionReceipt is required')\n      const confirmations = await getTransactionConfirmations(config, {\n        ...(parameters as any),\n        hash: parameters.hash,\n        transactionReceipt: parameters.transactionReceipt,\n      })\n      return confirmations ?? null\n    },\n    queryKey: getTransactionConfirmationsQueryKey(options),\n  }\n}\n\nexport type GetTransactionConfirmationsQueryFnData =\n  GetTransactionConfirmationsReturnType\n\nexport type GetTransactionConfirmationsData =\n  GetTransactionConfirmationsQueryFnData\n\nexport function getTransactionConfirmationsQueryKey<\n  config extends Config,\n  chainId extends\n    | config['chains'][number]['id']\n    | undefined = config['chains'][number]['id'],\n>(\n  options: UnionExactPartial<\n    GetTransactionConfirmationsParameters<config, chainId>\n  > &\n    ScopeKeyParameter = {} as any,\n) {\n  return ['transactionConfirmations', filterQueryOptions(options)] as const\n}\n\nexport type GetTransactionConfirmationsQueryKey<\n  config extends Config,\n  chainId extends\n    | config['chains'][number]['id']\n    | undefined = config['chains'][number]['id'],\n> = ReturnType<typeof getTransactionConfirmationsQueryKey<config, chainId>>\n\nexport type GetTransactionConfirmationsQueryOptions<\n  config extends Config,\n  chainId extends\n    | config['chains'][number]['id']\n    | undefined = config['chains'][number]['id'],\n  selectData = GetTransactionConfirmationsData,\n> = QueryOptions<\n  GetTransactionConfirmationsQueryFnData,\n  GetTransactionConfirmationsErrorType,\n  selectData,\n  GetTransactionConfirmationsQueryKey<config, chainId>\n>\n", "import {\n  type GetTransactionCountErrorType,\n  type GetTransactionCountParameters,\n  type GetTransactionCountReturnType,\n  getTransactionCount,\n} from '../actions/getTransactionCount.js'\nimport type { Config } from '../createConfig.js'\nimport type { ScopeKeyParameter } from '../types/properties.js'\nimport type { QueryOptions, QueryParameter } from '../types/query.js'\nimport type { Compute, ExactPartial } from '../types/utils.js'\nimport { filterQueryOptions } from './utils.js'\n\nexport type GetTransactionCountOptions<\n  config extends Config,\n  selectData = GetTransactionCountData,\n> = Compute<\n  ExactPartial<GetTransactionCountParameters<config>> & ScopeKeyParameter\n> &\n  QueryParameter<\n    GetTransactionCountQueryFnData,\n    GetTransactionCountErrorType,\n    selectData,\n    GetTransactionCountQueryKey<config>\n  >\n\nexport function getTransactionCountQueryOptions<\n  config extends Config,\n  selectData = GetTransactionCountData,\n>(\n  config: config,\n  options: GetTransactionCountOptions<config, selectData> = {},\n): GetTransactionCountQueryOptions<config, selectData> {\n  return {\n    ...options.query,\n    enabled: Boolean(options.address && (options.query?.enabled ?? true)),\n    queryFn: async (context) => {\n      const [, { scopeKey: _, ...parameters }] = context.queryKey\n      if (!parameters.address) throw new Error('address is required')\n      const transactionCount = await getTransactionCount(config, {\n        ...(parameters as any),\n        address: parameters.address,\n      })\n      return transactionCount ?? null\n    },\n    queryKey: getTransactionCountQueryKey(options),\n  }\n}\n\nexport type GetTransactionCountQueryFnData =\n  Compute<GetTransactionCountReturnType>\n\nexport type GetTransactionCountData = GetTransactionCountQueryFnData\n\nexport function getTransactionCountQueryKey<config extends Config>(\n  options: Compute<\n    ExactPartial<GetTransactionCountParameters<config>> & ScopeKeyParameter\n  > = {},\n) {\n  return ['transactionCount', filterQueryOptions(options)] as const\n}\n\nexport type GetTransactionCountQueryKey<config extends Config> = ReturnType<\n  typeof getTransactionCountQueryKey<config>\n>\n\nexport type GetTransactionCountQueryOptions<\n  config extends Config,\n  selectData = GetTransactionCountData,\n> = QueryOptions<\n  GetTransactionCountQueryFnData,\n  GetTransactionCountErrorType,\n  selectData,\n  GetTransactionCountQueryKey<config>\n>\n", "import type { GetTransactionReceiptReturnType } from '../actions/getTransactionReceipt.js'\nimport {\n  type GetTransactionReceiptErrorType,\n  type GetTransactionReceiptParameters,\n  getTransactionReceipt,\n} from '../actions/getTransactionReceipt.js'\nimport type { Config } from '../createConfig.js'\nimport type { ScopeKeyParameter } from '../types/properties.js'\nimport type { QueryOptions, QueryParameter } from '../types/query.js'\nimport type { Compute, ExactPartial } from '../types/utils.js'\nimport { filterQueryOptions } from './utils.js'\n\nexport type GetTransactionReceiptOptions<\n  config extends Config,\n  chainId extends config['chains'][number]['id'],\n  selectData = GetTransactionReceiptData<config, chainId>,\n> = Compute<\n  ExactPartial<GetTransactionReceiptParameters<config, chainId>> &\n    ScopeKeyParameter\n> &\n  QueryParameter<\n    GetTransactionReceiptQueryFnData<config, chainId>,\n    GetTransactionReceiptErrorType,\n    selectData,\n    GetTransactionReceiptQueryKey<config, chainId>\n  >\n\nexport function getTransactionReceiptQueryOptions<\n  config extends Config,\n  chainId extends config['chains'][number]['id'],\n  selectData = GetTransactionReceiptData<config, chainId>,\n>(\n  config: config,\n  options: GetTransactionReceiptOptions<config, chainId, selectData> = {},\n): GetTransactionReceiptQueryOptions<config, chainId, selectData> {\n  return {\n    ...options.query,\n    enabled: Boolean(options.hash && (options.query?.enabled ?? true)),\n    queryFn: async (context) => {\n      const [, { scopeKey: _, ...parameters }] = context.queryKey\n      if (!parameters.hash) throw new Error('hash is required')\n      return getTransactionReceipt(config, {\n        ...(parameters as any),\n        hash: parameters.hash,\n      })\n    },\n    queryKey: getTransactionReceiptQueryKey(options),\n  }\n}\n\nexport type GetTransactionReceiptQueryFnData<\n  config extends Config,\n  chainId extends config['chains'][number]['id'],\n> = GetTransactionReceiptReturnType<config, chainId>\n\nexport type GetTransactionReceiptData<\n  config extends Config,\n  chainId extends config['chains'][number]['id'],\n> = GetTransactionReceiptQueryFnData<config, chainId>\n\nexport function getTransactionReceiptQueryKey<\n  config extends Config,\n  chainId extends config['chains'][number]['id'],\n>(\n  options: Compute<\n    ExactPartial<GetTransactionReceiptParameters<config, chainId>> &\n      ScopeKeyParameter\n  > = {},\n) {\n  return ['getTransactionReceipt', filterQueryOptions(options)] as const\n}\n\nexport type GetTransactionReceiptQueryKey<\n  config extends Config,\n  chainId extends config['chains'][number]['id'],\n> = ReturnType<typeof getTransactionReceiptQueryKey<config, chainId>>\n\nexport type GetTransactionReceiptQueryOptions<\n  config extends Config,\n  chainId extends config['chains'][number]['id'],\n  selectData = GetTransactionReceiptData<config, chainId>,\n> = QueryOptions<\n  GetTransactionReceiptQueryFnData<config, chainId>,\n  GetTransactionReceiptErrorType,\n  selectData,\n  GetTransactionReceiptQueryKey<config, chainId>\n>\n", "import {\n  type GetWalletClientErrorType,\n  type GetWalletClientParameters,\n  type GetWalletClientReturnType,\n  getWalletClient,\n} from '../actions/getWalletClient.js'\nimport type { Config } from '../createConfig.js'\nimport type { ScopeKeyParameter } from '../types/properties.js'\nimport type { QueryOptions, QueryParameter } from '../types/query.js'\nimport type { Compute, ExactPartial } from '../types/utils.js'\nimport { filterQueryOptions } from './utils.js'\n\nexport type GetWalletClientOptions<\n  config extends Config,\n  chainId extends config['chains'][number]['id'],\n  selectData = GetWalletClientData<config, chainId>,\n> = Compute<\n  ExactPartial<GetWalletClientParameters<config, chainId>> & ScopeKeyParameter\n> &\n  QueryParameter<\n    GetWalletClientQueryFnData<config, chainId>,\n    GetWalletClientErrorType,\n    selectData,\n    GetWalletClientQueryKey<config, chainId>\n  >\n\nexport function getWalletClientQueryOptions<\n  config extends Config,\n  chainId extends config['chains'][number]['id'],\n  selectData = GetWalletClientData<config, chainId>,\n>(\n  config: config,\n  options: GetWalletClientOptions<config, chainId, selectData> = {},\n): GetWalletClientQueryOptions<config, chainId, selectData> {\n  return {\n    ...options.query,\n    enabled: Boolean(\n      options.connector?.getProvider && (options.query?.enabled ?? true),\n    ),\n    gcTime: 0,\n    queryFn: async (context) => {\n      if (!options.connector?.getProvider)\n        throw new Error('connector is required')\n      const [, { connectorUid: _, scopeKey: __, ...parameters }] =\n        context.queryKey\n      return getWalletClient(config, {\n        ...parameters,\n        connector: options.connector,\n      }) as never\n    },\n    queryKey: getWalletClientQueryKey(options),\n    staleTime: Number.POSITIVE_INFINITY,\n  }\n}\n\nexport type GetWalletClientQueryFnData<\n  config extends Config,\n  chainId extends config['chains'][number]['id'],\n> = GetWalletClientReturnType<config, chainId>\n\nexport type GetWalletClientData<\n  config extends Config,\n  chainId extends config['chains'][number]['id'],\n> = GetWalletClientQueryFnData<config, chainId>\n\nexport function getWalletClientQueryKey<\n  config extends Config,\n  chainId extends config['chains'][number]['id'],\n>(\n  options: Compute<\n    ExactPartial<GetWalletClientParameters<config, chainId>> & ScopeKeyParameter\n  > = {},\n) {\n  return ['walletClient', filterQueryOptions(options)] as const\n}\n\nexport type GetWalletClientQueryKey<\n  config extends Config,\n  chainId extends config['chains'][number]['id'],\n> = ReturnType<typeof getWalletClientQueryKey<config, chainId>>\n\nexport type GetWalletClientQueryOptions<\n  config extends Config,\n  chainId extends config['chains'][number]['id'],\n  selectData = GetWalletClientData<config, chainId>,\n> = QueryOptions<\n  GetWalletClientQueryFnData<config, chainId>,\n  GetWalletClientErrorType,\n  selectData,\n  GetWalletClientQueryKey<config, chainId>\n>\n", "import type { ContractFunctionParameters } from 'viem'\nimport {\n  type ReadContractsErrorType,\n  type ReadContractsParameters,\n  type ReadContractsReturnType,\n  readContracts,\n} from '../actions/readContracts.js'\nimport type { Config } from '../createConfig.js'\nimport type {\n  ChainIdParameter,\n  ScopeKeyParameter,\n} from '../types/properties.js'\nimport type { StrictOmit } from '../types/utils.js'\nimport type { InfiniteQueryOptions } from './types.js'\nimport { filterQueryOptions } from './utils.js'\n\nexport type InfiniteReadContractsOptions<\n  contracts extends readonly unknown[],\n  allowFailure extends boolean,\n  pageParam,\n  config extends Config,\n> = {\n  cacheKey: string\n  contracts(\n    pageParam: pageParam,\n  ): ReadContractsParameters<contracts, allowFailure, config>['contracts']\n} & StrictOmit<\n  ReadContractsParameters<contracts, allowFailure, config>,\n  'contracts'\n> &\n  ScopeKeyParameter\n\nexport function infiniteReadContractsQueryOptions<\n  config extends Config,\n  const contracts extends readonly ContractFunctionParameters[],\n  allowFailure extends boolean = true,\n  pageParam = unknown,\n>(\n  config: config,\n  options: InfiniteReadContractsOptions<\n    contracts,\n    allowFailure,\n    pageParam,\n    config\n  > &\n    ChainIdParameter<config> &\n    RequiredPageParamsParameters<contracts, allowFailure, pageParam>,\n) {\n  return {\n    ...options.query,\n    async queryFn({ pageParam, queryKey }) {\n      const { contracts } = options\n      const { cacheKey: _, scopeKey: _s, ...parameters } = queryKey[1]\n      return (await readContracts(config, {\n        ...parameters,\n        contracts: contracts(pageParam as any),\n      })) as ReadContractsReturnType<contracts, allowFailure>\n    },\n    queryKey: infiniteReadContractsQueryKey(options),\n  } as const satisfies InfiniteQueryOptions<\n    InfiniteReadContractsQueryFnData<contracts, allowFailure>,\n    ReadContractsErrorType,\n    InfiniteReadContractsData<contracts, allowFailure>,\n    InfiniteReadContractsData<contracts, allowFailure>,\n    InfiniteReadContractsQueryKey<contracts, allowFailure, pageParam, config>,\n    pageParam\n  >\n}\n\ntype RequiredPageParamsParameters<\n  contracts extends readonly unknown[],\n  allowFailure extends boolean,\n  pageParam,\n> = {\n  query: {\n    initialPageParam: pageParam\n    getNextPageParam(\n      lastPage: InfiniteReadContractsQueryFnData<contracts, allowFailure>,\n      allPages: InfiniteReadContractsQueryFnData<contracts, allowFailure>[],\n      lastPageParam: pageParam,\n      allPageParams: pageParam[],\n    ): pageParam | undefined | null\n  }\n}\n\nexport type InfiniteReadContractsQueryFnData<\n  contracts extends readonly unknown[],\n  allowFailure extends boolean,\n> = ReadContractsReturnType<contracts, allowFailure>\n\nexport type InfiniteReadContractsData<\n  contracts extends readonly unknown[],\n  allowFailure extends boolean,\n> = InfiniteReadContractsQueryFnData<contracts, allowFailure>\n\nexport function infiniteReadContractsQueryKey<\n  config extends Config,\n  const contracts extends readonly unknown[],\n  allowFailure extends boolean,\n  pageParam,\n>(\n  options: InfiniteReadContractsOptions<\n    contracts,\n    allowFailure,\n    pageParam,\n    config\n  > &\n    ChainIdParameter<config> &\n    RequiredPageParamsParameters<contracts, allowFailure, pageParam>,\n) {\n  const { contracts: _, ...parameters } = options\n  return ['infiniteReadContracts', filterQueryOptions(parameters)] as const\n}\n\nexport type InfiniteReadContractsQueryKey<\n  contracts extends readonly unknown[],\n  allowFailure extends boolean,\n  pageParam,\n  config extends Config,\n> = ReturnType<\n  typeof infiniteReadContractsQueryKey<\n    config,\n    contracts,\n    allowFailure,\n    pageParam\n  >\n>\n", "import type { PrepareTransactionRequestRequest as viem_PrepareTransactionRequestRequest } from 'viem'\n\nimport {\n  type PrepareTransactionRequestErrorType,\n  type PrepareTransactionRequestParameters,\n  type PrepareTransactionRequestReturnType,\n  prepareTransactionRequest,\n} from '../actions/prepareTransactionRequest.js'\nimport type { Config } from '../createConfig.js'\nimport type { SelectChains } from '../types/chain.js'\nimport type { ScopeKeyParameter } from '../types/properties.js'\nimport type { QueryOptions, QueryParameter } from '../types/query.js'\nimport type { UnionExactPartial } from '../types/utils.js'\nimport { filterQueryOptions } from './utils.js'\n\nexport type PrepareTransactionRequestOptions<\n  config extends Config,\n  chainId extends config['chains'][number]['id'] | undefined,\n  request extends viem_PrepareTransactionRequestRequest<\n    SelectChains<config, chainId>[0],\n    SelectChains<config, chainId>[0]\n  >,\n  selectData = PrepareTransactionRequestData<config, chainId, request>,\n> = UnionExactPartial<\n  PrepareTransactionRequestParameters<config, chainId, request>\n> &\n  ScopeKeyParameter &\n  QueryParameter<\n    PrepareTransactionRequestQueryFnData<config, chainId, request>,\n    PrepareTransactionRequestErrorType,\n    selectData,\n    PrepareTransactionRequestQueryKey<config, chainId, request>\n  >\n\nexport function prepareTransactionRequestQueryOptions<\n  config extends Config,\n  chainId extends config['chains'][number]['id'] | undefined,\n  request extends viem_PrepareTransactionRequestRequest<\n    SelectChains<config, chainId>[0],\n    SelectChains<config, chainId>[0]\n  >,\n  selectData = PrepareTransactionRequestData<config, chainId, request>,\n>(\n  config: config,\n  options: PrepareTransactionRequestOptions<\n    config,\n    chainId,\n    request,\n    selectData\n  > = {} as any,\n): PrepareTransactionRequestQueryOptions<config, chainId, request, selectData> {\n  return {\n    ...options.query,\n    enabled: Boolean(options.to && (options.query?.enabled ?? true)),\n    queryFn: async (context) => {\n      const [, { scopeKey: _, ...parameters }] = context.queryKey\n      if (!parameters.to) throw new Error('to is required')\n      return prepareTransactionRequest(config, {\n        ...(parameters as any),\n        to: parameters.to,\n      }) as unknown as Promise<\n        PrepareTransactionRequestQueryFnData<config, chainId, request>\n      >\n    },\n    queryKey: prepareTransactionRequestQueryKey(\n      options,\n    ) as PrepareTransactionRequestQueryKey<config, chainId, request>,\n  }\n}\n\nexport type PrepareTransactionRequestQueryFnData<\n  config extends Config,\n  chainId extends config['chains'][number]['id'] | undefined,\n  request extends viem_PrepareTransactionRequestRequest<\n    SelectChains<config, chainId>[0],\n    SelectChains<config, chainId>[0]\n  >,\n> = PrepareTransactionRequestReturnType<config, chainId, request>\n\nexport type PrepareTransactionRequestData<\n  config extends Config,\n  chainId extends config['chains'][number]['id'] | undefined,\n  request extends viem_PrepareTransactionRequestRequest<\n    SelectChains<config, chainId>[0],\n    SelectChains<config, chainId>[0]\n  >,\n> = PrepareTransactionRequestQueryFnData<config, chainId, request>\n\nexport function prepareTransactionRequestQueryKey<\n  config extends Config,\n  chainId extends config['chains'][number]['id'] | undefined,\n  request extends viem_PrepareTransactionRequestRequest<\n    SelectChains<config, chainId>[0],\n    SelectChains<config, chainId>[0]\n  >,\n>(\n  options: UnionExactPartial<\n    PrepareTransactionRequestParameters<config, chainId, request>\n  > &\n    ScopeKeyParameter = {} as any,\n) {\n  return ['prepareTransactionRequest', filterQueryOptions(options)] as const\n}\n\nexport type PrepareTransactionRequestQueryKey<\n  config extends Config,\n  chainId extends config['chains'][number]['id'] | undefined,\n  request extends viem_PrepareTransactionRequestRequest<\n    SelectChains<config, chainId>[0],\n    SelectChains<config, chainId>[0]\n  >,\n> = ReturnType<\n  typeof prepareTransactionRequestQueryKey<config, chainId, request>\n>\n\nexport type PrepareTransactionRequestQueryOptions<\n  config extends Config,\n  chainId extends config['chains'][number]['id'] | undefined,\n  request extends viem_PrepareTransactionRequestRequest<\n    SelectChains<config, chainId>[0],\n    SelectChains<config, chainId>[0]\n  >,\n  selectData = PrepareTransactionRequestData<config, chainId, request>,\n> = QueryOptions<\n  PrepareTransactionRequestQueryFnData<config, chainId, request>,\n  PrepareTransactionRequestErrorType,\n  selectData,\n  PrepareTransactionRequestQueryKey<config, chainId, request>\n>\n", "import type { Abi, ContractFunctionArgs, ContractFunctionName } from 'viem'\nimport {\n  type ReadContractErrorType,\n  type ReadContractParameters,\n  type ReadContractReturnType,\n  readContract,\n} from '../actions/readContract.js'\nimport type { Config } from '../createConfig.js'\nimport type { ScopeKeyParameter } from '../types/properties.js'\nimport type { QueryOptions, QueryParameter } from '../types/query.js'\nimport type { UnionExactPartial } from '../types/utils.js'\nimport { filterQueryOptions, structuralSharing } from './utils.js'\n\nexport type ReadContractOptions<\n  abi extends Abi | readonly unknown[],\n  functionName extends ContractFunctionName<abi, 'pure' | 'view'>,\n  args extends ContractFunctionArgs<abi, 'pure' | 'view', functionName>,\n  config extends Config,\n  selectData = ReadContractData<abi, functionName, args>,\n> = UnionExactPartial<ReadContractParameters<abi, functionName, args, config>> &\n  ScopeKeyParameter &\n  QueryParameter<\n    ReadContractQueryFnData<abi, functionName, args>,\n    ReadContractErrorType,\n    selectData,\n    ReadContractQueryKey<abi, functionName, args, config>\n  >\n\nexport function readContractQueryOptions<\n  config extends Config,\n  const abi extends Abi | readonly unknown[],\n  functionName extends ContractFunctionName<abi, 'pure' | 'view'>,\n  const args extends ContractFunctionArgs<abi, 'pure' | 'view', functionName>,\n  selectData = ReadContractData<abi, functionName, args>,\n>(\n  config: config,\n  options: ReadContractOptions<abi, functionName, args, config> = {} as any,\n): ReadContractQueryOptions<abi, functionName, args, config, selectData> {\n  return {\n    ...options.query,\n    enabled: Boolean(\n      Boolean(options.address || ('code' in options && options.code)) &&\n        options.abi &&\n        options.functionName &&\n        (options.query?.enabled ?? true),\n    ),\n    // TODO: Support `signal` once Viem actions allow passthrough\n    // https://tkdodo.eu/blog/why-you-want-react-query#bonus-cancellation\n    queryFn: async (context) => {\n      if (!options.abi) throw new Error('abi is required')\n      const [, { scopeKey: _, ...parameters }] = context.queryKey\n      if (!parameters.functionName) throw new Error('functionName is required')\n      const result = await readContract(config, {\n        ...(parameters as any),\n        abi: options.abi,\n        address: parameters.address,\n        code:\n          'code' in parameters && parameters.code ? parameters.code : undefined,\n        functionName: parameters.functionName,\n      })\n      return result as ReadContractData<abi, functionName, args>\n    },\n    queryKey: readContractQueryKey(options as any) as any,\n    structuralSharing,\n  } as ReadContractQueryOptions<abi, functionName, args, config, selectData>\n}\n\nexport type ReadContractQueryFnData<\n  abi extends Abi | readonly unknown[],\n  functionName extends ContractFunctionName<abi, 'pure' | 'view'>,\n  args extends ContractFunctionArgs<abi, 'pure' | 'view', functionName>,\n> = ReadContractReturnType<abi, functionName, args>\n\nexport type ReadContractData<\n  abi extends Abi | readonly unknown[],\n  functionName extends ContractFunctionName<abi, 'pure' | 'view'>,\n  args extends ContractFunctionArgs<abi, 'pure' | 'view', functionName>,\n> = ReadContractQueryFnData<abi, functionName, args>\n\nexport function readContractQueryKey<\n  config extends Config,\n  const abi extends Abi | readonly unknown[],\n  functionName extends ContractFunctionName<abi, 'pure' | 'view'>,\n  args extends ContractFunctionArgs<abi, 'pure' | 'view', functionName>,\n>(\n  options: UnionExactPartial<\n    ReadContractParameters<abi, functionName, args, config>\n  > &\n    ScopeKeyParameter = {} as any,\n) {\n  return ['readContract', filterQueryOptions(options)] as const\n}\n\nexport type ReadContractQueryKey<\n  abi extends Abi | readonly unknown[],\n  functionName extends ContractFunctionName<abi, 'pure' | 'view'>,\n  args extends ContractFunctionArgs<abi, 'pure' | 'view', functionName>,\n  config extends Config,\n> = ReturnType<typeof readContractQueryKey<config, abi, functionName, args>>\n\nexport type ReadContractQueryOptions<\n  abi extends Abi | readonly unknown[],\n  functionName extends ContractFunctionName<abi, 'pure' | 'view'>,\n  args extends ContractFunctionArgs<abi, 'pure' | 'view', functionName>,\n  config extends Config,\n  selectData = ReadContractData<abi, functionName, args>,\n> = QueryOptions<\n  ReadContractQueryFnData<abi, functionName, args>,\n  ReadContractErrorType,\n  selectData,\n  ReadContractQueryKey<abi, functionName, args, config>\n>\n", "import type {\n  ContractFunctionParameters,\n  MulticallParameters as viem_MulticallParameters,\n} from 'viem'\nimport {\n  type ReadContractsErrorType,\n  type ReadContractsReturnType,\n  readContracts,\n} from '../actions/readContracts.js'\nimport type { Config } from '../createConfig.js'\nimport type {\n  ChainIdParameter,\n  ScopeKeyParameter,\n} from '../types/properties.js'\nimport type { QueryOptions, QueryParameter } from '../types/query.js'\nimport type { ExactPartial } from '../types/utils.js'\nimport { filterQueryOptions } from './utils.js'\n\nexport type ReadContractsOptions<\n  contracts extends readonly unknown[],\n  allowFailure extends boolean,\n  config extends Config,\n  selectData = ReadContractsData<contracts, allowFailure>,\n> = ExactPartial<\n  viem_MulticallParameters<\n    contracts,\n    allowFailure,\n    { optional: true; properties: ChainIdParameter<config> }\n  >\n> &\n  ScopeKeyParameter &\n  QueryParameter<\n    ReadContractsQueryFnData<contracts, allowFailure>,\n    ReadContractsErrorType,\n    selectData,\n    ReadContractsQueryKey<contracts, allowFailure, config>\n  >\n\nexport function readContractsQueryOptions<\n  config extends Config,\n  const contracts extends readonly unknown[],\n  allowFailure extends boolean = true,\n  selectData = ReadContractsData<contracts, allowFailure>,\n>(\n  config: config,\n  options: ReadContractsOptions<contracts, allowFailure, config, selectData> &\n    ChainIdParameter<config> = {},\n): ReadContractsQueryOptions<contracts, allowFailure, config, selectData> {\n  return {\n    ...options.query,\n    queryFn: async (context) => {\n      const contracts: ContractFunctionParameters[] = []\n      const length = context.queryKey[1].contracts.length\n      for (let i = 0; i < length; i++) {\n        const contract = context.queryKey[1].contracts[i]!\n        const abi = (options.contracts?.[i] as ContractFunctionParameters).abi\n        contracts.push({ ...contract, abi })\n      }\n      const { scopeKey: _, ...parameters } = context.queryKey[1]\n      return readContracts(config, {\n        ...parameters,\n        contracts,\n      }) as Promise<ReadContractsReturnType<contracts, allowFailure>>\n    },\n    queryKey: readContractsQueryKey(options),\n  }\n}\n\nexport type ReadContractsQueryFnData<\n  contracts extends readonly unknown[],\n  allowFailure extends boolean,\n> = ReadContractsReturnType<contracts, allowFailure>\n\nexport type ReadContractsData<\n  contracts extends readonly unknown[],\n  allowFailure extends boolean,\n> = ReadContractsQueryFnData<contracts, allowFailure>\n\nexport function readContractsQueryKey<\n  config extends Config,\n  const contracts extends readonly unknown[],\n  allowFailure extends boolean,\n>(\n  options: ExactPartial<\n    viem_MulticallParameters<\n      contracts,\n      allowFailure,\n      { optional: true; properties: ChainIdParameter<config> }\n    >\n  > &\n    ScopeKeyParameter &\n    ChainIdParameter<config> = {},\n) {\n  const contracts = []\n  for (const contract of (options.contracts ??\n    []) as (ContractFunctionParameters & { chainId: number })[]) {\n    const { abi: _, ...rest } = contract\n    contracts.push({ ...rest, chainId: rest.chainId ?? options.chainId })\n  }\n  return [\n    'readContracts',\n    filterQueryOptions({ ...options, contracts }),\n  ] as const\n}\n\nexport type ReadContractsQueryKey<\n  contracts extends readonly unknown[],\n  allowFailure extends boolean,\n  config extends Config,\n> = ReturnType<typeof readContractsQueryKey<config, contracts, allowFailure>>\n\nexport type ReadContractsQueryOptions<\n  contracts extends readonly unknown[],\n  allowFailure extends boolean,\n  config extends Config,\n  selectData = ReadContractsData<contracts, allowFailure>,\n> = QueryOptions<\n  ReadContractsQueryFnData<contracts, allowFailure>,\n  ReadContractsErrorType,\n  selectData,\n  ReadContractsQueryKey<contracts, allowFailure, config>\n>\n", "import type { MutationOptions } from '@tanstack/query-core'\n\nimport {\n  type ReconnectErrorType,\n  type ReconnectParameters,\n  type ReconnectReturnType,\n  reconnect,\n} from '../actions/reconnect.js'\nimport type { Config } from '../createConfig.js'\nimport type { Compute } from '../types/utils.js'\nimport type { Mutate, MutateAsync } from './types.js'\n\nexport function reconnectMutationOptions(config: Config) {\n  return {\n    mutationFn(variables) {\n      return reconnect(config, variables)\n    },\n    mutationKey: ['reconnect'],\n  } as const satisfies MutationOptions<\n    ReconnectData,\n    ReconnectErrorType,\n    ReconnectVariables\n  >\n}\n\nexport type ReconnectData = Compute<ReconnectReturnType>\n\nexport type ReconnectVariables = ReconnectParameters | undefined\n\nexport type ReconnectMutate<context = unknown> = Mutate<\n  ReconnectData,\n  ReconnectErrorType,\n  ReconnectVariables,\n  context\n>\n\nexport type ReconnectMutateAsync<context = unknown> = MutateAsync<\n  ReconnectData,\n  ReconnectErrorType,\n  ReconnectVariables,\n  context\n>\n", "import type { MutateOptions, MutationOptions } from '@tanstack/query-core'\n\nimport {\n  type SendCallsErrorType,\n  type SendCallsParameters,\n  type SendCallsReturnType,\n  sendCalls,\n} from '../actions/sendCalls.js'\nimport type { Config } from '../createConfig.js'\nimport type { Compute } from '../types/utils.js'\n\nexport function sendCallsMutationOptions<config extends Config>(\n  config: config,\n) {\n  return {\n    mutationFn(variables) {\n      return sendCalls(config, variables)\n    },\n    mutationKey: ['sendCalls'],\n  } as const satisfies MutationOptions<\n    SendCallsData,\n    SendCallsErrorType,\n    SendCallsVariables<config, config['chains'][number]['id']>\n  >\n}\n\nexport type SendCallsData = Compute<SendCallsReturnType>\n\nexport type SendCallsVariables<\n  config extends Config,\n  chainId extends config['chains'][number]['id'],\n  calls extends readonly unknown[] = readonly unknown[],\n> = SendCallsParameters<config, chainId, calls>\n\nexport type SendCallsMutate<config extends Config, context = unknown> = <\n  const calls extends readonly unknown[],\n  chainId extends config['chains'][number]['id'],\n>(\n  variables: SendCallsVariables<config, chainId, calls>,\n  options?:\n    | Compute<\n        MutateOptions<\n          SendCallsData,\n          SendCallsErrorType,\n          Compute<SendCallsVariables<config, chainId, calls>>,\n          context\n        >\n      >\n    | undefined,\n) => void\n\nexport type SendCallsMutateAsync<config extends Config, context = unknown> = <\n  const calls extends readonly unknown[],\n  chainId extends config['chains'][number]['id'],\n>(\n  variables: SendCallsVariables<config, chainId, calls>,\n  options?:\n    | Compute<\n        MutateOptions<\n          SendCallsData,\n          SendCallsErrorType,\n          Compute<SendCallsVariables<config, chainId, calls>>,\n          context\n        >\n      >\n    | undefined,\n) => Promise<SendCallsData>\n", "import type { MutateOptions, MutationOptions } from '@tanstack/query-core'\n\nimport {\n  type SendCallsSyncErrorType,\n  type SendCallsSyncParameters,\n  type SendCallsSyncReturnType,\n  sendCallsSync,\n} from '../actions/sendCallsSync.js'\nimport type { Config } from '../createConfig.js'\nimport type { Compute } from '../types/utils.js'\n\nexport function sendCallsSyncMutationOptions<config extends Config>(\n  config: config,\n) {\n  return {\n    mutationFn(variables) {\n      return sendCallsSync(config, variables)\n    },\n    mutationKey: ['sendCallsSync'],\n  } as const satisfies MutationOptions<\n    SendCallsSyncData,\n    SendCallsSyncErrorType,\n    SendCallsSyncVariables<config, config['chains'][number]['id']>\n  >\n}\n\nexport type SendCallsSyncData = Compute<SendCallsSyncReturnType>\n\nexport type SendCallsSyncVariables<\n  config extends Config,\n  chainId extends config['chains'][number]['id'],\n  calls extends readonly unknown[] = readonly unknown[],\n> = SendCallsSyncParameters<config, chainId, calls>\n\nexport type SendCallsSyncMutate<config extends Config, context = unknown> = <\n  const calls extends readonly unknown[],\n  chainId extends config['chains'][number]['id'],\n>(\n  variables: SendCallsSyncVariables<config, chainId, calls>,\n  options?:\n    | Compute<\n        MutateOptions<\n          SendCallsSyncData,\n          SendCallsSyncErrorType,\n          Compute<SendCallsSyncVariables<config, chainId, calls>>,\n          context\n        >\n      >\n    | undefined,\n) => void\n\nexport type SendCallsSyncMutateAsync<\n  config extends Config,\n  context = unknown,\n> = <\n  const calls extends readonly unknown[],\n  chainId extends config['chains'][number]['id'],\n>(\n  variables: SendCallsSyncVariables<config, chainId, calls>,\n  options?:\n    | Compute<\n        MutateOptions<\n          SendCallsSyncData,\n          SendCallsSyncErrorType,\n          Compute<SendCallsSyncVariables<config, chainId, calls>>,\n          context\n        >\n      >\n    | undefined,\n) => Promise<SendCallsSyncData>\n", "import type { MutateOptions, MutationOptions } from '@tanstack/query-core'\n\nimport {\n  type SendTransactionErrorType,\n  type SendTransactionParameters,\n  type SendTransactionReturnType,\n  sendTransaction,\n} from '../actions/sendTransaction.js'\nimport type { Config } from '../createConfig.js'\nimport type { Compute } from '../types/utils.js'\n\nexport function sendTransactionMutationOptions<config extends Config>(\n  config: config,\n) {\n  return {\n    mutationFn(variables) {\n      return sendTransaction(config, variables)\n    },\n    mutationKey: ['sendTransaction'],\n  } as const satisfies MutationOptions<\n    SendTransactionData,\n    SendTransactionErrorType,\n    SendTransactionVariables<config, config['chains'][number]['id']>\n  >\n}\n\nexport type SendTransactionData = Compute<SendTransactionReturnType>\n\nexport type SendTransactionVariables<\n  config extends Config,\n  chainId extends config['chains'][number]['id'],\n> = SendTransactionParameters<config, chainId>\n\nexport type SendTransactionMutate<config extends Config, context = unknown> = <\n  chainId extends config['chains'][number]['id'],\n>(\n  variables: SendTransactionVariables<config, chainId>,\n  options?:\n    | Compute<\n        MutateOptions<\n          SendTransactionData,\n          SendTransactionErrorType,\n          Compute<SendTransactionVariables<config, chainId>>,\n          context\n        >\n      >\n    | undefined,\n) => void\n\nexport type SendTransactionMutateAsync<\n  config extends Config,\n  context = unknown,\n> = <chainId extends config['chains'][number]['id']>(\n  variables: SendTransactionVariables<config, chainId>,\n  options?:\n    | Compute<\n        MutateOptions<\n          SendTransactionData,\n          SendTransactionErrorType,\n          Compute<SendTransactionVariables<config, chainId>>,\n          context\n        >\n      >\n    | undefined,\n) => Promise<SendTransactionData>\n", "import type { MutateOptions, MutationOptions } from '@tanstack/query-core'\n\nimport {\n  type SendTransactionSyncErrorType,\n  type SendTransactionSyncParameters,\n  type SendTransactionSyncReturnType,\n  sendTransactionSync,\n} from '../actions/sendTransactionSync.js'\nimport type { Config } from '../createConfig.js'\nimport type { Compute } from '../types/utils.js'\n\nexport function sendTransactionSyncMutationOptions<config extends Config>(\n  config: config,\n) {\n  return {\n    mutationFn(variables) {\n      return sendTransactionSync(config, variables)\n    },\n    mutationKey: ['sendTransactionSync'],\n  } as const satisfies MutationOptions<\n    SendTransactionSyncData,\n    SendTransactionSyncErrorType,\n    SendTransactionSyncVariables<config, config['chains'][number]['id']>\n  >\n}\n\nexport type SendTransactionSyncData = Compute<SendTransactionSyncReturnType>\n\nexport type SendTransactionSyncVariables<\n  config extends Config,\n  chainId extends config['chains'][number]['id'],\n> = SendTransactionSyncParameters<config, chainId>\n\nexport type SendTransactionSyncMutate<\n  config extends Config,\n  context = unknown,\n> = <chainId extends config['chains'][number]['id']>(\n  variables: SendTransactionSyncVariables<config, chainId>,\n  options?:\n    | Compute<\n        MutateOptions<\n          SendTransactionSyncData,\n          SendTransactionSyncErrorType,\n          Compute<SendTransactionSyncVariables<config, chainId>>,\n          context\n        >\n      >\n    | undefined,\n) => void\n\nexport type SendTransactionSyncMutateAsync<\n  config extends Config,\n  context = unknown,\n> = <chainId extends config['chains'][number]['id']>(\n  variables: SendTransactionSyncVariables<config, chainId>,\n  options?:\n    | Compute<\n        MutateOptions<\n          SendTransactionSyncData,\n          SendTransactionSyncErrorType,\n          Compute<SendTransactionSyncVariables<config, chainId>>,\n          context\n        >\n      >\n    | undefined,\n) => Promise<SendTransactionSyncData>\n", "import type { MutateOptions, MutationOptions } from '@tanstack/query-core'\n\nimport {\n  type ShowCallsStatusErrorType,\n  type ShowCallsStatusParameters,\n  type ShowCallsStatusReturnType,\n  showCallsStatus,\n} from '../actions/showCallsStatus.js'\nimport type { Config } from '../createConfig.js'\nimport type { Compute } from '../types/utils.js'\n\nexport function showCallsStatusMutationOptions<config extends Config>(\n  config: config,\n) {\n  return {\n    mutationFn(variables) {\n      return showCallsStatus(config, variables)\n    },\n    mutationKey: ['showCallsStatus'],\n  } as const satisfies MutationOptions<\n    ShowCallsStatusData,\n    ShowCallsStatusErrorType,\n    ShowCallsStatusVariables\n  >\n}\n\nexport type ShowCallsStatusData = Compute<ShowCallsStatusReturnType>\n\nexport type ShowCallsStatusVariables = ShowCallsStatusParameters\n\nexport type ShowCallsStatusMutate<context = unknown> = (\n  variables: ShowCallsStatusVariables,\n  options?:\n    | Compute<\n        MutateOptions<\n          ShowCallsStatusData,\n          ShowCallsStatusErrorType,\n          Compute<ShowCallsStatusVariables>,\n          context\n        >\n      >\n    | undefined,\n) => void\n\nexport type ShowCallsStatusMutateAsync<context = unknown> = (\n  variables: ShowCallsStatusVariables,\n  options?:\n    | Compute<\n        MutateOptions<\n          ShowCallsStatusData,\n          ShowCallsStatusErrorType,\n          Compute<ShowCallsStatusVariables>,\n          context\n        >\n      >\n    | undefined,\n) => Promise<ShowCallsStatusData>\n", "import type { MutationOptions } from '@tanstack/query-core'\n\nimport {\n  type SignMessageErrorType,\n  type SignMessageParameters,\n  type SignMessageReturnType,\n  signMessage,\n} from '../actions/signMessage.js'\nimport type { Config } from '../createConfig.js'\nimport type { Compute } from '../types/utils.js'\nimport type { Mutate, MutateAsync } from './types.js'\n\nexport function signMessageMutationOptions(config: Config) {\n  return {\n    mutationFn(variables) {\n      return signMessage(config, variables)\n    },\n    mutationKey: ['signMessage'],\n  } as const satisfies MutationOptions<\n    SignMessageData,\n    SignMessageErrorType,\n    SignMessageVariables\n  >\n}\n\nexport type SignMessageData = SignMessageReturnType\n\nexport type SignMessageVariables = Compute<SignMessageParameters>\n\nexport type SignMessageMutate<context = unknown> = Mutate<\n  SignMessageData,\n  SignMessageErrorType,\n  SignMessageVariables,\n  context\n>\n\nexport type SignMessageMutateAsync<context = unknown> = MutateAsync<\n  SignMessageData,\n  SignMessageErrorType,\n  SignMessageVariables,\n  context\n>\n", "import type { MutateOptions, MutationOptions } from '@tanstack/query-core'\n\nimport type { TypedData } from 'viem'\nimport {\n  type SignTypedDataErrorType,\n  type SignTypedDataParameters,\n  type SignTypedDataReturnType,\n  signTypedData,\n} from '../actions/signTypedData.js'\nimport type { Config } from '../createConfig.js'\nimport type { Compute } from '../types/utils.js'\n\nexport function signTypedDataMutationOptions<config extends Config>(\n  config: config,\n) {\n  return {\n    mutationFn(variables) {\n      return signTypedData(config, variables)\n    },\n    mutationKey: ['signTypedData'],\n  } as const satisfies MutationOptions<\n    SignTypedDataData,\n    SignTypedDataErrorType,\n    SignTypedDataVariables\n  >\n}\n\nexport type SignTypedDataData = Compute<SignTypedDataReturnType>\n\nexport type SignTypedDataVariables<\n  typedData extends TypedData | Record<string, unknown> = TypedData,\n  primaryType extends keyof typedData | 'EIP712Domain' = keyof typedData,\n  ///\n  primaryTypes = typedData extends TypedData ? keyof typedData : string,\n> = SignTypedDataParameters<typedData, primaryType, primaryTypes>\n\nexport type SignTypedDataMutate<context = unknown> = <\n  const typedData extends TypedData | Record<string, unknown>,\n  primaryType extends keyof typedData | 'EIP712Domain',\n>(\n  variables: SignTypedDataVariables<typedData, primaryType>,\n  options?:\n    | MutateOptions<\n        SignTypedDataData,\n        SignTypedDataErrorType,\n        SignTypedDataVariables<\n          typedData,\n          primaryType,\n          // use `primaryType` to make sure it's not union of all possible primary types\n          primaryType\n        >,\n        context\n      >\n    | undefined,\n) => void\n\nexport type SignTypedDataMutateAsync<context = unknown> = <\n  const typedData extends TypedData | Record<string, unknown>,\n  primaryType extends keyof typedData | 'EIP712Domain',\n>(\n  variables: SignTypedDataVariables<typedData, primaryType>,\n  options?:\n    | MutateOptions<\n        SignTypedDataData,\n        SignTypedDataErrorType,\n        SignTypedDataVariables<\n          typedData,\n          primaryType,\n          // use `primaryType` to make sure it's not union of all possible primary types\n          primaryType\n        >,\n        context\n      >\n    | undefined,\n) => Promise<SignTypedDataData>\n", "import type { Abi, ContractFunctionArgs, ContractFunctionName } from 'viem'\n\nimport {\n  type SimulateContractErrorType,\n  type SimulateContractParameters,\n  type SimulateContractReturnType,\n  simulateContract,\n} from '../actions/simulateContract.js'\nimport type { Config } from '../createConfig.js'\nimport type { ScopeKeyParameter } from '../types/properties.js'\nimport type { QueryOptions, QueryParameter } from '../types/query.js'\nimport type { UnionExactPartial } from '../types/utils.js'\nimport { filterQueryOptions } from './utils.js'\n\nexport type SimulateContractOptions<\n  abi extends Abi | readonly unknown[],\n  functionName extends ContractFunctionName<abi, 'nonpayable' | 'payable'>,\n  args extends ContractFunctionArgs<\n    abi,\n    'nonpayable' | 'payable',\n    functionName\n  >,\n  config extends Config,\n  chainId extends config['chains'][number]['id'] | undefined,\n  selectData = SimulateContractData<abi, functionName, args, config, chainId>,\n> = UnionExactPartial<\n  SimulateContractParameters<abi, functionName, args, config, chainId>\n> &\n  ScopeKeyParameter &\n  QueryParameter<\n    SimulateContractQueryFnData<abi, functionName, args, config, chainId>,\n    SimulateContractErrorType,\n    selectData,\n    SimulateContractQueryKey<abi, functionName, args, config, chainId>\n  >\n\nexport function simulateContractQueryOptions<\n  const abi extends Abi | readonly unknown[],\n  functionName extends ContractFunctionName<abi, 'nonpayable' | 'payable'>,\n  const args extends ContractFunctionArgs<\n    abi,\n    'nonpayable' | 'payable',\n    functionName\n  >,\n  config extends Config,\n  chainId extends config['chains'][number]['id'] | undefined,\n  selectData = SimulateContractData<abi, functionName, args, config, chainId>,\n>(\n  config: config,\n  options: SimulateContractOptions<\n    abi,\n    functionName,\n    args,\n    config,\n    chainId,\n    selectData\n  > = {} as any,\n): SimulateContractQueryOptions<\n  abi,\n  functionName,\n  args,\n  config,\n  chainId,\n  selectData\n> {\n  return {\n    ...options.query,\n    enabled: Boolean(\n      options.abi &&\n        options.address &&\n        options.connector &&\n        options.functionName &&\n        (options.query?.enabled ?? true),\n    ),\n    queryFn: async (context) => {\n      if (!options.abi) throw new Error('abi is required')\n      if (!options.connector) throw new Error('connector is required')\n      const [, { scopeKey: _, ...parameters }] = context.queryKey\n      if (!parameters.address) throw new Error('address is required')\n      if (!parameters.functionName) throw new Error('functionName is required')\n      return simulateContract(config, {\n        ...(parameters as any),\n        abi: options.abi,\n        address: parameters.address,\n        connector: options.connector,\n        functionName: parameters.functionName,\n      })\n    },\n    queryKey: simulateContractQueryKey(options as any),\n  }\n}\n\nexport type SimulateContractQueryFnData<\n  abi extends Abi | readonly unknown[],\n  functionName extends ContractFunctionName<abi, 'nonpayable' | 'payable'>,\n  args extends ContractFunctionArgs<\n    abi,\n    'nonpayable' | 'payable',\n    functionName\n  >,\n  config extends Config,\n  chainId extends config['chains'][number]['id'] | undefined,\n> = SimulateContractReturnType<abi, functionName, args, config, chainId>\n\nexport type SimulateContractData<\n  abi extends Abi | readonly unknown[],\n  functionName extends ContractFunctionName<abi, 'nonpayable' | 'payable'>,\n  args extends ContractFunctionArgs<\n    abi,\n    'nonpayable' | 'payable',\n    functionName\n  >,\n  config extends Config,\n  chainId extends config['chains'][number]['id'] | undefined,\n> = SimulateContractQueryFnData<abi, functionName, args, config, chainId>\n\nexport function simulateContractQueryKey<\n  abi extends Abi | readonly unknown[],\n  functionName extends ContractFunctionName<abi, 'nonpayable' | 'payable'>,\n  const args extends ContractFunctionArgs<\n    abi,\n    'nonpayable' | 'payable',\n    functionName\n  >,\n  const config extends Config,\n  chainId extends config['chains'][number]['id'] | undefined,\n>(\n  options: UnionExactPartial<\n    SimulateContractParameters<abi, functionName, args, config, chainId>\n  > &\n    ScopeKeyParameter = {} as any,\n) {\n  const { connector: _, ...rest } = options\n  return ['simulateContract', filterQueryOptions(rest)] as const\n}\n\nexport type SimulateContractQueryKey<\n  abi extends Abi | readonly unknown[],\n  functionName extends ContractFunctionName<abi, 'nonpayable' | 'payable'>,\n  args extends ContractFunctionArgs<\n    abi,\n    'nonpayable' | 'payable',\n    functionName\n  >,\n  config extends Config,\n  chainId extends config['chains'][number]['id'] | undefined,\n> = ReturnType<\n  typeof simulateContractQueryKey<abi, functionName, args, config, chainId>\n>\n\nexport type SimulateContractQueryOptions<\n  abi extends Abi | readonly unknown[],\n  functionName extends ContractFunctionName<abi, 'nonpayable' | 'payable'>,\n  args extends ContractFunctionArgs<\n    abi,\n    'nonpayable' | 'payable',\n    functionName\n  >,\n  config extends Config,\n  chainId extends config['chains'][number]['id'] | undefined,\n  selectData = SimulateContractData<abi, functionName, args, config, chainId>,\n> = QueryOptions<\n  SimulateContractQueryFnData<abi, functionName, args, config, chainId>,\n  SimulateContractErrorType,\n  selectData,\n  SimulateContractQueryKey<abi, functionName, args, config, chainId>\n>\n", "import type { MutateOptions, MutationOptions } from '@tanstack/query-core'\n\nimport {\n  type SwitchChainErrorType,\n  type SwitchChainParameters,\n  type SwitchChainReturnType,\n  switchChain,\n} from '../actions/switchChain.js'\nimport type { Config } from '../createConfig.js'\nimport type { Compute } from '../types/utils.js'\n\nexport function switchChainMutationOptions<config extends Config>(\n  config: config,\n) {\n  return {\n    mutationFn(variables) {\n      return switchChain(config, variables)\n    },\n    mutationKey: ['switchChain'],\n  } as const satisfies MutationOptions<\n    SwitchChainData<config, config['chains'][number]['id']>,\n    SwitchChainErrorType,\n    SwitchChainVariables<config, config['chains'][number]['id']>\n  >\n}\n\nexport type SwitchChainData<\n  config extends Config,\n  chainId extends config['chains'][number]['id'],\n> = Compute<SwitchChainReturnType<config, chainId>>\n\nexport type SwitchChainVariables<\n  config extends Config,\n  chainId extends config['chains'][number]['id'],\n> = Compute<SwitchChainParameters<config, chainId>>\n\nexport type SwitchChainMutate<config extends Config, context = unknown> = <\n  chainId extends config['chains'][number]['id'],\n>(\n  variables: SwitchChainVariables<config, chainId>,\n  options?:\n    | Compute<\n        MutateOptions<\n          SwitchChainData<config, chainId>,\n          SwitchChainErrorType,\n          Compute<SwitchChainVariables<config, chainId>>,\n          context\n        >\n      >\n    | undefined,\n) => void\n\nexport type SwitchChainMutateAsync<config extends Config, context = unknown> = <\n  chainId extends config['chains'][number]['id'],\n>(\n  variables: SwitchChainVariables<config, chainId>,\n  options?:\n    | Compute<\n        MutateOptions<\n          SwitchChainData<config, chainId>,\n          SwitchChainErrorType,\n          Compute<SwitchChainVariables<config, chainId>>,\n          context\n        >\n      >\n    | undefined,\n) => Promise<SwitchChainData<config, chainId>>\n", "import type { MutationOptions } from '@tanstack/query-core'\n\nimport {\n  type SwitchConnectionErrorType,\n  type SwitchConnectionParameters,\n  type SwitchConnectionReturnType,\n  switchConnection,\n} from '../actions/switchConnection.js'\nimport type { Config } from '../createConfig.js'\nimport type { Compute } from '../types/utils.js'\nimport type { Mutate, MutateAsync } from './types.js'\n\nexport function switchConnectionMutationOptions<config extends Config>(\n  config: config,\n) {\n  return {\n    mutationFn(variables) {\n      return switchConnection(config, variables)\n    },\n    mutationKey: ['switchConnection'],\n  } as const satisfies MutationOptions<\n    SwitchConnectionData<config>,\n    SwitchConnectionErrorType,\n    SwitchConnectionVariables\n  >\n}\n\nexport type SwitchConnectionData<config extends Config> = Compute<\n  SwitchConnectionReturnType<config>\n>\n\nexport type SwitchConnectionVariables = Compute<SwitchConnectionParameters>\n\nexport type SwitchConnectionMutate<\n  config extends Config,\n  context = unknown,\n> = Mutate<\n  SwitchConnectionData<config>,\n  SwitchConnectionErrorType,\n  SwitchConnectionVariables,\n  context\n>\n\nexport type SwitchConnectionMutateAsync<\n  config extends Config,\n  context = unknown,\n> = MutateAsync<\n  SwitchConnectionData<config>,\n  SwitchConnectionErrorType,\n  SwitchConnectionVariables,\n  context\n>\n", "import {\n  type VerifyMessageErrorType,\n  type VerifyMessageParameters,\n  type VerifyMessageReturnType,\n  verifyMessage,\n} from '../actions/verifyMessage.js'\nimport type { Config } from '../createConfig.js'\nimport type { ScopeKeyParameter } from '../types/properties.js'\nimport type { QueryOptions, QueryParameter } from '../types/query.js'\nimport type { Compute, ExactPartial } from '../types/utils.js'\nimport { filterQueryOptions } from './utils.js'\n\nexport type VerifyMessageOptions<\n  config extends Config,\n  selectData = VerifyMessageData,\n> = Compute<ExactPartial<VerifyMessageParameters<config>> & ScopeKeyParameter> &\n  QueryParameter<\n    VerifyMessageQueryFnData,\n    VerifyMessageErrorType,\n    selectData,\n    VerifyMessageQueryKey<config>\n  >\n\nexport function verifyMessageQueryOptions<\n  config extends Config,\n  selectData = VerifyMessageData,\n>(\n  config: config,\n  options: VerifyMessageOptions<config, selectData> = {},\n): VerifyMessageQueryOptions<config, selectData> {\n  return {\n    ...options.query,\n    enabled: Boolean(\n      options.address &&\n        options.message &&\n        options.signature &&\n        (options.query?.enabled ?? true),\n    ),\n    queryFn: async (context) => {\n      const [, { scopeKey: _, ...parameters }] = context.queryKey\n      if (!parameters.address) throw new Error('address is required')\n      if (!parameters.message) throw new Error('message is required')\n      if (!parameters.signature) throw new Error('signature is required')\n      const verified = await verifyMessage(config, {\n        ...parameters,\n        address: parameters.address,\n        message: parameters.message,\n        signature: parameters.signature,\n      })\n      return verified ?? null\n    },\n    queryKey: verifyMessageQueryKey(options),\n  }\n}\n\nexport type VerifyMessageQueryFnData = VerifyMessageReturnType\n\nexport type VerifyMessageData = VerifyMessageQueryFnData\n\nexport function verifyMessageQueryKey<config extends Config>(\n  options: Compute<\n    ExactPartial<VerifyMessageParameters<config>> & ScopeKeyParameter\n  > = {},\n) {\n  return ['verifyMessage', filterQueryOptions(options)] as const\n}\n\nexport type VerifyMessageQueryKey<config extends Config> = ReturnType<\n  typeof verifyMessageQueryKey<config>\n>\n\nexport type VerifyMessageQueryOptions<\n  config extends Config,\n  selectData = VerifyMessageData,\n> = QueryOptions<\n  VerifyMessageQueryFnData,\n  VerifyMessageErrorType,\n  selectData,\n  VerifyMessageQueryKey<config>\n>\n", "import type { TypedData } from 'viem'\n\nimport {\n  type VerifyTypedDataErrorType,\n  type VerifyTypedDataParameters,\n  type VerifyTypedDataReturnType,\n  verifyTypedData,\n} from '../actions/verifyTypedData.js'\nimport type { Config } from '../createConfig.js'\nimport type { ScopeKeyParameter } from '../types/properties.js'\nimport type { QueryOptions, QueryParameter } from '../types/query.js'\nimport type { UnionExactPartial } from '../types/utils.js'\nimport { filterQueryOptions } from './utils.js'\n\nexport type VerifyTypedDataOptions<\n  typedData extends TypedData | Record<string, unknown>,\n  primaryType extends keyof typedData | 'EIP712Domain',\n  config extends Config,\n  selectData = VerifyTypedDataData,\n> = UnionExactPartial<\n  VerifyTypedDataParameters<typedData, primaryType, config>\n> &\n  ScopeKeyParameter &\n  QueryParameter<\n    VerifyTypedDataQueryFnData,\n    VerifyTypedDataErrorType,\n    selectData,\n    VerifyTypedDataQueryKey<typedData, primaryType, config>\n  >\n\nexport function verifyTypedDataQueryOptions<\n  const typedData extends TypedData | Record<string, unknown>,\n  primaryType extends keyof typedData | 'EIP712Domain',\n  config extends Config,\n  selectData = VerifyTypedDataData,\n>(\n  config: config,\n  options: VerifyTypedDataOptions<\n    typedData,\n    primaryType,\n    config,\n    selectData\n  > = {} as any,\n): VerifyTypedDataQueryOptions<typedData, primaryType, config, selectData> {\n  return {\n    ...options.query,\n    enabled: Boolean(\n      options.address &&\n        options.message &&\n        options.primaryType &&\n        options.signature &&\n        options.types &&\n        (options.query?.enabled ?? true),\n    ),\n    queryFn: async (context) => {\n      const [, { scopeKey: _, ...parameters }] = context.queryKey\n      if (!parameters.address) throw new Error('address is required')\n      if (!parameters.message) throw new Error('message is required')\n      if (!parameters.primaryType) throw new Error('primaryType is required')\n      if (!parameters.signature) throw new Error('signature is required')\n      if (!parameters.types) throw new Error('types is required')\n      const verified = await verifyTypedData(config, {\n        ...(parameters as any),\n        address: parameters.address,\n        message: parameters.message,\n        primaryType: parameters.primaryType,\n        signature: parameters.signature,\n        types: parameters.types,\n      })\n      return verified ?? null\n    },\n    queryKey: verifyTypedDataQueryKey(options as any) as any,\n  }\n}\n\nexport type VerifyTypedDataQueryFnData = VerifyTypedDataReturnType\n\nexport type VerifyTypedDataData = VerifyTypedDataQueryFnData\n\nexport function verifyTypedDataQueryKey<\n  config extends Config,\n  const typedData extends TypedData | Record<string, unknown>,\n  primaryType extends keyof typedData | 'EIP712Domain',\n>(\n  options: UnionExactPartial<\n    VerifyTypedDataParameters<typedData, primaryType, config>\n  > &\n    ScopeKeyParameter = {} as any,\n) {\n  return ['verifyTypedData', filterQueryOptions(options)] as const\n}\n\nexport type VerifyTypedDataQueryKey<\n  typedData extends TypedData | Record<string, unknown>,\n  primaryType extends keyof typedData | 'EIP712Domain',\n  config extends Config,\n> = ReturnType<typeof verifyTypedDataQueryKey<config, typedData, primaryType>>\n\nexport type VerifyTypedDataQueryOptions<\n  typedData extends TypedData | Record<string, unknown>,\n  primaryType extends keyof typedData | 'EIP712Domain',\n  config extends Config,\n  selectData = VerifyTypedDataData,\n> = QueryOptions<\n  VerifyTypedDataQueryFnData,\n  VerifyTypedDataErrorType,\n  selectData,\n  VerifyTypedDataQueryKey<typedData, primaryType, config>\n>\n", "import {\n  type WaitForCallsStatusErrorType,\n  type WaitForCallsStatusParameters,\n  type WaitForCallsStatusReturnType,\n  waitForCallsStatus,\n} from '../actions/waitForCallsStatus.js'\nimport type { Config } from '../createConfig.js'\nimport { filterQueryOptions } from '../query/utils.js'\nimport type { ScopeKeyParameter } from '../types/properties.js'\nimport type { QueryOptions, QueryParameter } from '../types/query.js'\nimport type { Compute, ExactPartial } from '../types/utils.js'\n\nexport type WaitForCallsStatusOptions<selectData = WaitForCallsStatusData> =\n  Compute<ExactPartial<WaitForCallsStatusParameters> & ScopeKeyParameter> &\n    QueryParameter<\n      WaitForCallsStatusQueryFnData,\n      WaitForCallsStatusErrorType,\n      selectData,\n      WaitForCallsStatusQueryKey\n    >\n\nexport function waitForCallsStatusQueryOptions<\n  config extends Config,\n  selectData = WaitForCallsStatusData,\n>(\n  config: config,\n  options: WaitForCallsStatusOptions<selectData>,\n): WaitForCallsStatusQueryOptions<selectData> {\n  return {\n    ...options.query,\n    enabled: Boolean(\n      options.id &&\n        options.connector?.getProvider &&\n        (options.query?.enabled ?? true),\n    ),\n    queryFn: async (context) => {\n      if (!options.connector?.getProvider)\n        throw new Error('connector is required')\n      const [, { connectorUid: _, scopeKey: __, ...parameters }] =\n        context.queryKey\n      if (!parameters.id) throw new Error('id is required')\n      const status = await waitForCallsStatus(config, {\n        ...parameters,\n        id: parameters.id,\n      })\n      return status\n    },\n    queryKey: waitForCallsStatusQueryKey(options),\n  }\n}\n\nexport type WaitForCallsStatusQueryFnData = WaitForCallsStatusReturnType\n\nexport type WaitForCallsStatusData = WaitForCallsStatusQueryFnData\n\nexport function waitForCallsStatusQueryKey(\n  options: Compute<\n    ExactPartial<WaitForCallsStatusParameters> & ScopeKeyParameter\n  > = {},\n) {\n  return ['callsStatus', filterQueryOptions(options)] as const\n}\n\nexport type WaitForCallsStatusQueryKey = ReturnType<\n  typeof waitForCallsStatusQueryKey\n>\n\nexport type WaitForCallsStatusQueryOptions<\n  selectData = WaitForCallsStatusData,\n> = QueryOptions<\n  WaitForCallsStatusQueryFnData,\n  WaitForCallsStatusErrorType,\n  selectData,\n  WaitForCallsStatusQueryKey\n>\n", "import {\n  type WaitForTransactionReceiptErrorType,\n  type WaitForTransactionReceiptParameters,\n  type WaitForTransactionReceiptReturnType,\n  waitForTransactionReceipt,\n} from '../actions/waitForTransactionReceipt.js'\nimport type { Config } from '../createConfig.js'\nimport type { ScopeKeyParameter } from '../types/properties.js'\nimport type { QueryOptions, QueryParameter } from '../types/query.js'\nimport type { Compute, ExactPartial } from '../types/utils.js'\nimport { filterQueryOptions } from './utils.js'\n\nexport type WaitForTransactionReceiptOptions<\n  config extends Config,\n  chainId extends config['chains'][number]['id'],\n  selectData = WaitForTransactionReceiptData<config, chainId>,\n> = Compute<\n  ExactPartial<WaitForTransactionReceiptParameters<config, chainId>> &\n    ScopeKeyParameter\n> &\n  QueryParameter<\n    WaitForTransactionReceiptQueryFnData<config, chainId>,\n    WaitForTransactionReceiptErrorType,\n    selectData,\n    WaitForTransactionReceiptQueryKey<config, chainId>\n  >\n\nexport function waitForTransactionReceiptQueryOptions<\n  config extends Config,\n  chainId extends config['chains'][number]['id'],\n  selectData = WaitForTransactionReceiptData<config, chainId>,\n>(\n  config: config,\n  options: WaitForTransactionReceiptOptions<config, chainId, selectData> = {},\n): WaitForTransactionReceiptQueryOptions<config, chainId, selectData> {\n  return {\n    ...options.query,\n    enabled: Boolean(options.hash && (options.query?.enabled ?? true)),\n    queryFn: async (context) => {\n      const [, { scopeKey: _, ...parameters }] = context.queryKey\n      if (!parameters.hash) throw new Error('hash is required')\n      return waitForTransactionReceipt(config, {\n        ...parameters,\n        onReplaced: options.onReplaced,\n        hash: parameters.hash,\n      }) as unknown as Promise<\n        WaitForTransactionReceiptReturnType<config, chainId>\n      >\n    },\n    queryKey: waitForTransactionReceiptQueryKey(options),\n  }\n}\n\nexport type WaitForTransactionReceiptQueryFnData<\n  config extends Config,\n  chainId extends config['chains'][number]['id'],\n> = WaitForTransactionReceiptReturnType<config, chainId>\n\nexport type WaitForTransactionReceiptData<\n  config extends Config,\n  chainId extends config['chains'][number]['id'],\n> = WaitForTransactionReceiptQueryFnData<config, chainId>\n\nexport function waitForTransactionReceiptQueryKey<\n  config extends Config,\n  chainId extends config['chains'][number]['id'],\n>(\n  options: Compute<\n    ExactPartial<WaitForTransactionReceiptParameters<config, chainId>> &\n      ScopeKeyParameter\n  > = {},\n) {\n  const { onReplaced: _, ...rest } = options\n  return ['waitForTransactionReceipt', filterQueryOptions(rest)] as const\n}\n\nexport type WaitForTransactionReceiptQueryKey<\n  config extends Config,\n  chainId extends config['chains'][number]['id'],\n> = ReturnType<typeof waitForTransactionReceiptQueryKey<config, chainId>>\n\nexport type WaitForTransactionReceiptQueryOptions<\n  config extends Config,\n  chainId extends config['chains'][number]['id'],\n  selectData = WaitForTransactionReceiptData<config, chainId>,\n> = QueryOptions<\n  WaitForTransactionReceiptQueryFnData<config, chainId>,\n  WaitForTransactionReceiptErrorType,\n  selectData,\n  WaitForTransactionReceiptQueryKey<config, chainId>\n>\n", "import type { MutationOptions } from '@tanstack/query-core'\n\nimport {\n  type WatchAssetErrorType,\n  type WatchAssetParameters,\n  type WatchAssetReturnType,\n  watchAsset,\n} from '../actions/watchAsset.js'\nimport type { Config } from '../createConfig.js'\nimport type { Compute } from '../types/utils.js'\nimport type { Mutate, MutateAsync } from './types.js'\n\nexport function watchAssetMutationOptions(config: Config) {\n  return {\n    mutationFn(variables) {\n      return watchAsset(config, variables)\n    },\n    mutationKey: ['watchAsset'],\n  } as const satisfies MutationOptions<\n    WatchAssetData,\n    WatchAssetErrorType,\n    WatchAssetVariables\n  >\n}\n\nexport type WatchAssetData = WatchAssetReturnType\n\nexport type WatchAssetVariables = Compute<WatchAssetParameters>\n\nexport type WatchAssetMutate<context = unknown> = Mutate<\n  WatchAssetData,\n  WatchAssetErrorType,\n  WatchAssetVariables,\n  context\n>\n\nexport type WatchAssetMutateAsync<context = unknown> = MutateAsync<\n  WatchAssetData,\n  WatchAssetErrorType,\n  WatchAssetVariables,\n  context\n>\n", "import type { MutateOptions, MutationOptions } from '@tanstack/query-core'\nimport type { Abi, ContractFunctionArgs, ContractFunctionName } from 'viem'\n\nimport {\n  type WriteContractErrorType,\n  type WriteContractParameters,\n  type WriteContractReturnType,\n  writeContract,\n} from '../actions/writeContract.js'\nimport type { Config } from '../createConfig.js'\nimport type { Compute } from '../types/utils.js'\n\nexport function writeContractMutationOptions<config extends Config>(\n  config: config,\n) {\n  return {\n    mutationFn(variables) {\n      return writeContract(config, variables)\n    },\n    mutationKey: ['writeContract'],\n  } as const satisfies MutationOptions<\n    WriteContractData,\n    WriteContractErrorType,\n    WriteContractVariables<\n      Abi,\n      string,\n      readonly unknown[],\n      config,\n      config['chains'][number]['id']\n    >\n  >\n}\n\nexport type WriteContractData = Compute<WriteContractReturnType>\n\nexport type WriteContractVariables<\n  abi extends Abi | readonly unknown[],\n  functionName extends ContractFunctionName<abi, 'nonpayable' | 'payable'>,\n  args extends ContractFunctionArgs<\n    abi,\n    'nonpayable' | 'payable',\n    functionName\n  >,\n  config extends Config,\n  chainId extends config['chains'][number]['id'],\n  ///\n  allFunctionNames = ContractFunctionName<abi, 'nonpayable' | 'payable'>,\n> = WriteContractParameters<\n  abi,\n  functionName,\n  args,\n  config,\n  chainId,\n  allFunctionNames\n>\n\nexport type WriteContractMutate<config extends Config, context = unknown> = <\n  const abi extends Abi | readonly unknown[],\n  functionName extends ContractFunctionName<abi, 'nonpayable' | 'payable'>,\n  args extends ContractFunctionArgs<\n    abi,\n    'nonpayable' | 'payable',\n    functionName\n  >,\n  chainId extends config['chains'][number]['id'],\n>(\n  variables: WriteContractVariables<abi, functionName, args, config, chainId>,\n  options?:\n    | MutateOptions<\n        WriteContractData,\n        WriteContractErrorType,\n        WriteContractVariables<\n          abi,\n          functionName,\n          args,\n          config,\n          chainId,\n          // use `functionName` to make sure it's not union of all possible function names\n          functionName\n        >,\n        context\n      >\n    | undefined,\n) => void\n\nexport type WriteContractMutateAsync<\n  config extends Config,\n  context = unknown,\n> = <\n  const abi extends Abi | readonly unknown[],\n  functionName extends ContractFunctionName<abi, 'nonpayable' | 'payable'>,\n  args extends ContractFunctionArgs<\n    abi,\n    'nonpayable' | 'payable',\n    functionName\n  >,\n  chainId extends config['chains'][number]['id'],\n>(\n  variables: WriteContractVariables<abi, functionName, args, config, chainId>,\n  options?:\n    | MutateOptions<\n        WriteContractData,\n        WriteContractErrorType,\n        WriteContractVariables<\n          abi,\n          functionName,\n          args,\n          config,\n          chainId,\n          // use `functionName` to make sure it's not union of all possible function names\n          functionName\n        >,\n        context\n      >\n    | undefined,\n) => Promise<WriteContractData>\n", "import {\n  type DefaultError,\n  type QueryKey,\n  useInfiniteQuery as tanstack_useInfiniteQuery,\n  useQuery as tanstack_useQuery,\n  type UseInfiniteQueryOptions,\n  type UseInfiniteQueryResult,\n  type UseMutationOptions,\n  type UseMutationResult,\n  type UseQueryOptions,\n  type UseQueryResult,\n  useMutation,\n} from '@tanstack/react-query'\nimport type {\n  Compute,\n  ExactPartial,\n  Omit,\n  UnionStrictOmit,\n} from '@wagmi/core/internal'\nimport { hashFn } from '@wagmi/core/query'\n\nexport type UseMutationParameters<\n  data = unknown,\n  error = Error,\n  variables = void,\n  context = unknown,\n> = Compute<\n  Omit<\n    UseMutationOptions<data, error, Compute<variables>, context>,\n    'mutationFn' | 'mutationKey' | 'throwOnError'\n  >\n>\n\nexport type UseMutationReturnType<\n  data = unknown,\n  error = Error,\n  variables = void,\n  context = unknown,\n> = Compute<\n  UnionStrictOmit<\n    UseMutationResult<data, error, variables, context>,\n    'mutate' | 'mutateAsync'\n  >\n>\n\nexport { useMutation }\n\n////////////////////////////////////////////////////////////////////////////////\n\nexport type UseQueryParameters<\n  queryFnData = unknown,\n  error = DefaultError,\n  data = queryFnData,\n  queryKey extends QueryKey = QueryKey,\n> = Compute<\n  ExactPartial<\n    Omit<UseQueryOptions<queryFnData, error, data, queryKey>, 'initialData'>\n  > & {\n    // Fix `initialData` type\n    initialData?:\n      | UseQueryOptions<queryFnData, error, data, queryKey>['initialData']\n      | undefined\n  }\n>\n\nexport type UseQueryReturnType<data = unknown, error = DefaultError> = Compute<\n  UseQueryResult<data, error> & {\n    queryKey: QueryKey\n  }\n>\n\n// Adding some basic customization.\n// Ideally we don't have this function, but `import('@tanstack/react-query').useQuery` currently has some quirks where it is super hard to\n// pass down the inferred `initialData` type because of it's discriminated overload in the on `useQuery`.\nexport function useQuery<queryFnData, error, data, queryKey extends QueryKey>(\n  parameters: UseQueryParameters<queryFnData, error, data, queryKey> & {\n    queryKey: QueryKey\n  },\n): UseQueryReturnType<data, error> {\n  const result = tanstack_useQuery({\n    ...(parameters as any),\n    queryKeyHashFn: hashFn, // for bigint support\n  }) as UseQueryReturnType<data, error>\n  result.queryKey = parameters.queryKey\n  return result\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\nexport type UseInfiniteQueryParameters<\n  queryFnData = unknown,\n  error = DefaultError,\n  data = queryFnData,\n  queryData = queryFnData,\n  queryKey extends QueryKey = QueryKey,\n  pageParam = unknown,\n> = Compute<\n  Omit<\n    UseInfiniteQueryOptions<\n      queryFnData,\n      error,\n      data,\n      queryData,\n      queryKey,\n      pageParam\n    >,\n    'initialData'\n  > & {\n    // Fix `initialData` type\n    initialData?:\n      | UseInfiniteQueryOptions<\n          queryFnData,\n          error,\n          data,\n          queryKey\n        >['initialData']\n      | undefined\n  }\n>\n\nexport type UseInfiniteQueryReturnType<\n  data = unknown,\n  error = DefaultError,\n> = UseInfiniteQueryResult<data, error> & {\n  queryKey: QueryKey\n}\n\n// Adding some basic customization.\nexport function useInfiniteQuery<\n  queryFnData,\n  error,\n  data,\n  queryKey extends QueryKey,\n>(\n  parameters: UseInfiniteQueryParameters<queryFnData, error, data, queryKey> & {\n    queryKey: QueryKey\n  },\n): UseInfiniteQueryReturnType<data, error> {\n  const result = tanstack_useInfiniteQuery({\n    ...(parameters as any),\n    queryKeyHashFn: hashFn, // for bigint support\n  }) as UseInfiniteQueryReturnType<data, error>\n  result.queryKey = parameters.queryKey\n  return result\n}\n", "'use client'\n\nimport {\n  type Config,\n  type GetChainIdReturnType,\n  getChainId,\n  type ResolvedRegister,\n  watchChainId,\n} from '@wagmi/core'\nimport { useSyncExternalStore } from 'react'\n\nimport type { ConfigParameter } from '../types/properties.js'\nimport { useConfig } from './useConfig.js'\n\nexport type UseChainIdParameters<config extends Config = Config> =\n  ConfigParameter<config>\n\nexport type UseChainIdReturnType<config extends Config = Config> =\n  GetChainIdReturnType<config>\n\n/** https://wagmi.sh/react/api/hooks/useChainId */\nexport function useChainId<config extends Config = ResolvedRegister['config']>(\n  parameters: UseChainIdParameters<config> = {},\n): UseChainIdReturnType<config> {\n  const config = useConfig(parameters)\n\n  return useSyncExternalStore(\n    (onChange) => watchChainId(config, { onChange }),\n    () => getChainId(config),\n    () => getChainId(config),\n  )\n}\n", "'use client'\n\nimport type { Config, ResolvedRegister } from '@wagmi/core'\nimport { useContext } from 'react'\n\nimport { WagmiContext } from '../context.js'\nimport { WagmiProviderNotFoundError } from '../errors/context.js'\nimport type { ConfigParameter } from '../types/properties.js'\n\nexport type UseConfigParameters<config extends Config = Config> =\n  ConfigParameter<config>\n\nexport type UseConfigReturnType<config extends Config = Config> = config\n\n/** https://wagmi.sh/react/api/hooks/useConfig */\nexport function useConfig<config extends Config = ResolvedRegister['config']>(\n  parameters: UseConfigParameters<config> = {},\n): UseConfigReturnType<config> {\n  // biome-ignore lint/correctness/useHookAtTopLevel: false alarm\n  const config = parameters.config ?? useContext(WagmiContext)\n  if (!config) throw new WagmiProviderNotFoundError()\n  return config as UseConfigReturnType<config>\n}\n", "'use client'\nimport type { Config, GetBalanceErrorType, ResolvedRegister } from '@wagmi/core'\nimport type { Compute } from '@wagmi/core/internal'\nimport {\n  type GetBalanceData,\n  type GetBalanceOptions,\n  getBalanceQueryOptions,\n} from '@wagmi/core/query'\nimport type { ConfigParameter } from '../types/properties.js'\nimport { type UseQueryReturnType, useQuery } from '../utils/query.js'\nimport { useChainId } from './useChainId.js'\nimport { useConfig } from './useConfig.js'\n\nexport type UseBalanceParameters<\n  config extends Config = Config,\n  selectData = GetBalanceData,\n> = Compute<GetBalanceOptions<config, selectData> & ConfigParameter<config>>\n\nexport type UseBalanceReturnType<selectData = GetBalanceData> =\n  UseQueryReturnType<selectData, GetBalanceErrorType>\n\n/** https://wagmi.sh/react/api/hooks/useBalance */\nexport function useBalance<\n  config extends Config = ResolvedRegister['config'],\n  selectData = GetBalanceData,\n>(\n  parameters: UseBalanceParameters<config, selectData> = {},\n): UseBalanceReturnType<selectData> {\n  const config = useConfig(parameters)\n  const chainId = useChainId({ config })\n  const options = getBalanceQueryOptions(config, {\n    ...parameters,\n    chainId: parameters.chainId ?? chainId,\n    query: parameters.query,\n  })\n  return useQuery(options)\n}\n", "'use client'\n\nimport {\n  type Config,\n  type ResolvedRegister,\n  type WatchBlocksParameters,\n  watchBlocks,\n} from '@wagmi/core'\nimport type { UnionCompute, UnionExactPartial } from '@wagmi/core/internal'\nimport { useEffect } from 'react'\nimport type { BlockTag } from 'viem'\n\nimport type { ConfigParameter, EnabledParameter } from '../types/properties.js'\nimport { useChainId } from './useChainId.js'\nimport { useConfig } from './useConfig.js'\n\nexport type UseWatchBlocksParameters<\n  includeTransactions extends boolean = false,\n  blockTag extends BlockTag = 'latest',\n  config extends Config = Config,\n  chainId extends\n    config['chains'][number]['id'] = config['chains'][number]['id'],\n> = UnionCompute<\n  UnionExactPartial<\n    WatchBlocksParameters<includeTransactions, blockTag, config, chainId>\n  > &\n    ConfigParameter<config> &\n    EnabledParameter\n>\n\nexport type UseWatchBlocksReturnType = void\n\n/** https://wagmi.sh/react/hooks/useWatchBlocks */\nexport function useWatchBlocks<\n  config extends Config = ResolvedRegister['config'],\n  chainId extends\n    config['chains'][number]['id'] = config['chains'][number]['id'],\n  includeTransactions extends boolean = false,\n  blockTag extends BlockTag = 'latest',\n>(\n  parameters: UseWatchBlocksParameters<\n    includeTransactions,\n    blockTag,\n    config,\n    chainId\n  > = {} as any,\n): UseWatchBlocksReturnType {\n  const { enabled = true, onBlock, config: _, ...rest } = parameters\n\n  const config = useConfig(parameters)\n  const configChainId = useChainId({ config })\n  const chainId = parameters.chainId ?? configChainId\n\n  // TODO(react@19): cleanup\n  // biome-ignore lint/correctness/useExhaustiveDependencies: `rest` changes every render so only including properties in dependency array\n  useEffect(() => {\n    if (!enabled) return\n    if (!onBlock) return\n    return watchBlocks(config, {\n      ...(rest as any),\n      chainId,\n      onBlock,\n    })\n  }, [\n    chainId,\n    config,\n    enabled,\n    onBlock,\n    ///\n    rest.blockTag,\n    rest.emitMissed,\n    rest.emitOnBegin,\n    rest.includeTransactions,\n    rest.onError,\n    rest.poll,\n    rest.pollingInterval,\n    rest.syncConnectedChain,\n  ])\n}\n", "'use client'\nimport { useQueryClient } from '@tanstack/react-query'\nimport type { Config, GetBlockErrorType, ResolvedRegister } from '@wagmi/core'\nimport type {\n  Compute,\n  UnionCompute,\n  UnionStrictOmit,\n} from '@wagmi/core/internal'\nimport {\n  type GetBlockData,\n  type GetBlockOptions,\n  getBlockQueryOptions,\n} from '@wagmi/core/query'\nimport type { BlockTag } from 'viem'\nimport type { ConfigParameter } from '../types/properties.js'\nimport { type UseQueryReturnType, useQuery } from '../utils/query.js'\nimport { useChainId } from './useChainId.js'\nimport { useConfig } from './useConfig.js'\nimport {\n  type UseWatchBlocksParameters,\n  useWatchBlocks,\n} from './useWatchBlocks.js'\n\nexport type UseBlockParameters<\n  includeTransactions extends boolean = false,\n  blockTag extends BlockTag = 'latest',\n  config extends Config = Config,\n  chainId extends\n    config['chains'][number]['id'] = config['chains'][number]['id'],\n  selectData = GetBlockData<includeTransactions, blockTag, config, chainId>,\n> = Compute<\n  GetBlockOptions<includeTransactions, blockTag, config, chainId, selectData> &\n    ConfigParameter<config> & {\n      watch?:\n        | boolean\n        | UnionCompute<\n            UnionStrictOmit<\n              UseWatchBlocksParameters<\n                includeTransactions,\n                blockTag,\n                config,\n                chainId\n              >,\n              'chainId' | 'config' | 'onBlock' | 'onError'\n            >\n          >\n        | undefined\n    }\n>\n\nexport type UseBlockReturnType<\n  includeTransactions extends boolean = false,\n  blockTag extends BlockTag = 'latest',\n  config extends Config = Config,\n  chainId extends\n    config['chains'][number]['id'] = config['chains'][number]['id'],\n  selectData = GetBlockData<includeTransactions, blockTag, config, chainId>,\n> = UseQueryReturnType<selectData, GetBlockErrorType>\n\n/** https://wagmi.sh/react/hooks/useBlock */\nexport function useBlock<\n  includeTransactions extends boolean = false,\n  blockTag extends BlockTag = 'latest',\n  config extends Config = ResolvedRegister['config'],\n  chainId extends\n    config['chains'][number]['id'] = config['chains'][number]['id'],\n  selectData = GetBlockData<includeTransactions, blockTag, config, chainId>,\n>(\n  parameters: UseBlockParameters<\n    includeTransactions,\n    blockTag,\n    config,\n    chainId,\n    selectData\n  > = {},\n): UseBlockReturnType<\n  includeTransactions,\n  blockTag,\n  config,\n  chainId,\n  selectData\n> {\n  const config = useConfig(parameters)\n  const chainId = useChainId({ config })\n  const options = getBlockQueryOptions(config, {\n    ...parameters,\n    chainId: parameters.chainId ?? chainId,\n    query: parameters.query,\n  })\n  const queryClient = useQueryClient()\n  useWatchBlocks({\n    ...({\n      config: parameters.config,\n      chainId: parameters.chainId!,\n      ...(typeof parameters.watch === 'object' ? parameters.watch : {}),\n    } as UseWatchBlocksParameters),\n    enabled: Boolean(\n      (options.enabled ?? true) &&\n        (typeof parameters.watch === 'object'\n          ? parameters.watch.enabled\n          : parameters.watch),\n    ),\n    onBlock(block) {\n      queryClient.setQueryData(options.queryKey, block)\n    },\n  })\n  return useQuery(options) as any\n}\n", "'use client'\n\nimport {\n  type Config,\n  type ResolvedRegister,\n  type WatchBlockNumberParameters,\n  watchBlockNumber,\n} from '@wagmi/core'\nimport type { UnionCompute, UnionExactPartial } from '@wagmi/core/internal'\nimport { useEffect } from 'react'\n\nimport type { ConfigParameter, EnabledParameter } from '../types/properties.js'\nimport { useChainId } from './useChainId.js'\nimport { useConfig } from './useConfig.js'\n\nexport type UseWatchBlockNumberParameters<\n  config extends Config = Config,\n  chainId extends\n    config['chains'][number]['id'] = config['chains'][number]['id'],\n> = UnionCompute<\n  UnionExactPartial<WatchBlockNumberParameters<config, chainId>> &\n    ConfigParameter<config> &\n    EnabledParameter\n>\n\nexport type UseWatchBlockNumberReturnType = void\n\n/** https://wagmi.sh/react/api/hooks/useWatchBlockNumber */\nexport function useWatchBlockNumber<\n  config extends Config = ResolvedRegister['config'],\n  chainId extends\n    config['chains'][number]['id'] = config['chains'][number]['id'],\n>(\n  parameters: UseWatchBlockNumberParameters<config, chainId> = {} as any,\n): UseWatchBlockNumberReturnType {\n  const { enabled = true, onBlockNumber, config: _, ...rest } = parameters\n\n  const config = useConfig(parameters)\n  const configChainId = useChainId({ config })\n  const chainId = parameters.chainId ?? configChainId\n\n  // TODO(react@19): cleanup\n  // biome-ignore lint/correctness/useExhaustiveDependencies: `rest` changes every render so only including properties in dependency array\n  useEffect(() => {\n    if (!enabled) return\n    if (!onBlockNumber) return\n    return watchBlockNumber(config, {\n      ...(rest as any),\n      chainId,\n      onBlockNumber,\n    })\n  }, [\n    chainId,\n    config,\n    enabled,\n    onBlockNumber,\n    ///\n    rest.onError,\n    rest.emitMissed,\n    rest.emitOnBegin,\n    rest.poll,\n    rest.pollingInterval,\n    rest.syncConnectedChain,\n  ])\n}\n", "'use client'\nimport { useQueryClient } from '@tanstack/react-query'\nimport type {\n  Config,\n  GetBlockNumberErrorType,\n  ResolvedRegister,\n} from '@wagmi/core'\nimport type {\n  Compute,\n  UnionCompute,\n  UnionStrictOmit,\n} from '@wagmi/core/internal'\nimport {\n  type GetBlockNumberData,\n  type GetBlockNumberOptions,\n  getBlockNumberQueryOptions,\n} from '@wagmi/core/query'\nimport type { ConfigParameter } from '../types/properties.js'\nimport { type UseQueryReturnType, useQuery } from '../utils/query.js'\nimport { useChainId } from './useChainId.js'\nimport { useConfig } from './useConfig.js'\nimport {\n  type UseWatchBlockNumberParameters,\n  useWatchBlockNumber,\n} from './useWatchBlockNumber.js'\n\nexport type UseBlockNumberParameters<\n  config extends Config = Config,\n  chainId extends\n    config['chains'][number]['id'] = config['chains'][number]['id'],\n  selectData = GetBlockNumberData,\n> = Compute<\n  GetBlockNumberOptions<config, chainId, selectData> &\n    ConfigParameter<config> & {\n      watch?:\n        | boolean\n        | UnionCompute<\n            UnionStrictOmit<\n              UseWatchBlockNumberParameters<config, chainId>,\n              'chainId' | 'config' | 'onBlockNumber' | 'onError'\n            >\n          >\n        | undefined\n    }\n>\n\nexport type UseBlockNumberReturnType<selectData = GetBlockNumberData> =\n  UseQueryReturnType<selectData, GetBlockNumberErrorType>\n\n/** https://wagmi.sh/react/api/hooks/useBlockNumber */\nexport function useBlockNumber<\n  config extends Config = ResolvedRegister['config'],\n  chainId extends\n    config['chains'][number]['id'] = config['chains'][number]['id'],\n  selectData = GetBlockNumberData,\n>(\n  parameters: UseBlockNumberParameters<config, chainId, selectData> = {},\n): UseBlockNumberReturnType<selectData> {\n  const config = useConfig(parameters)\n  const chainId = useChainId({ config })\n  const options = getBlockNumberQueryOptions(config, {\n    ...parameters,\n    chainId: parameters.chainId ?? chainId,\n    query: parameters.query,\n  })\n  const queryClient = useQueryClient()\n  useWatchBlockNumber({\n    ...({\n      config: parameters.config,\n      chainId: parameters.chainId,\n      ...(typeof parameters.watch === 'object' ? parameters.watch : {}),\n    } as UseWatchBlockNumberParameters),\n    enabled: Boolean(\n      (options.enabled ?? true) &&\n        (typeof parameters.watch === 'object'\n          ? parameters.watch.enabled\n          : parameters.watch),\n    ),\n    onBlockNumber(blockNumber) {\n      queryClient.setQueryData(options.queryKey, blockNumber)\n    },\n  })\n  return useQuery(options)\n}\n", "'use client'\nimport type {\n  Config,\n  GetBlockTransactionCountErrorType,\n  ResolvedRegister,\n} from '@wagmi/core'\nimport type { UnionCompute } from '@wagmi/core/internal'\nimport {\n  type GetBlockTransactionCountData,\n  type GetBlockTransactionCountOptions,\n  getBlockTransactionCountQueryOptions,\n} from '@wagmi/core/query'\nimport type { ConfigParameter } from '../types/properties.js'\nimport { type UseQueryReturnType, useQuery } from '../utils/query.js'\nimport { useChainId } from './useChainId.js'\nimport { useConfig } from './useConfig.js'\n\nexport type UseBlockTransactionCountParameters<\n  config extends Config = Config,\n  chainId extends\n    config['chains'][number]['id'] = config['chains'][number]['id'],\n  selectData = GetBlockTransactionCountData,\n> = UnionCompute<\n  GetBlockTransactionCountOptions<config, chainId, selectData> &\n    ConfigParameter<config>\n>\n\nexport type UseBlockTransactionCountReturnType<\n  selectData = GetBlockTransactionCountData,\n> = UseQueryReturnType<selectData, GetBlockTransactionCountErrorType>\n\n/** https://wagmi.sh/react/api/hooks/useBlockTransactionCount */\nexport function useBlockTransactionCount<\n  config extends Config = ResolvedRegister['config'],\n  chainId extends\n    config['chains'][number]['id'] = config['chains'][number]['id'],\n  selectData = GetBlockTransactionCountData,\n>(\n  parameters: UseBlockTransactionCountParameters<\n    config,\n    chainId,\n    selectData\n  > = {},\n): UseBlockTransactionCountReturnType<selectData> {\n  const config = useConfig(parameters)\n  const chainId = useChainId({ config })\n  const options = getBlockTransactionCountQueryOptions(config, {\n    ...parameters,\n    chainId: parameters.chainId ?? chainId,\n    query: parameters.query,\n  })\n  return useQuery(options)\n}\n", "'use client'\nimport type {\n  Config,\n  GetBytecodeErrorType,\n  ResolvedRegister,\n} from '@wagmi/core'\nimport type { Compute } from '@wagmi/core/internal'\nimport {\n  type GetBytecodeData,\n  type GetBytecodeOptions,\n  getBytecodeQueryOptions,\n} from '@wagmi/core/query'\nimport type { ConfigParameter } from '../types/properties.js'\nimport { type UseQueryReturnType, useQuery } from '../utils/query.js'\nimport { useChainId } from './useChainId.js'\nimport { useConfig } from './useConfig.js'\n\nexport type UseBytecodeParameters<\n  config extends Config = Config,\n  selectData = GetBytecodeData,\n> = Compute<GetBytecodeOptions<config, selectData> & ConfigParameter<config>>\n\nexport type UseBytecodeReturnType<selectData = GetBytecodeData> =\n  UseQueryReturnType<selectData, GetBytecodeErrorType>\n\n/** https://wagmi.sh/react/api/hooks/useBytecode */\nexport function useBytecode<\n  config extends Config = ResolvedRegister['config'],\n  selectData = GetBytecodeData,\n>(\n  parameters: UseBytecodeParameters<config, selectData> = {},\n): UseBytecodeReturnType<selectData> {\n  const config = useConfig(parameters)\n  const chainId = useChainId({ config })\n  const options = getBytecodeQueryOptions(config, {\n    ...parameters,\n    chainId: parameters.chainId ?? chainId,\n    query: parameters.query,\n  })\n  return useQuery(options)\n}\n", "'use client'\nimport type { CallErrorType, Config, ResolvedRegister } from '@wagmi/core'\nimport type { Compute } from '@wagmi/core/internal'\nimport {\n  type CallData,\n  type CallOptions,\n  callQueryOptions,\n} from '@wagmi/core/query'\nimport type { ConfigParameter } from '../types/properties.js'\nimport { type UseQueryReturnType, useQuery } from '../utils/query.js'\nimport { useChainId } from './useChainId.js'\nimport { useConfig } from './useConfig.js'\n\nexport type UseCallParameters<\n  config extends Config = Config,\n  selectData = CallData,\n> = Compute<CallOptions<config, selectData> & ConfigParameter<config>>\n\nexport type UseCallReturnType<selectData = CallData> = UseQueryReturnType<\n  selectData,\n  CallErrorType\n>\n\n/** https://wagmi.sh/react/api/hooks/useCall */\nexport function useCall<\n  config extends Config = ResolvedRegister['config'],\n  selectData = CallData,\n>(\n  parameters: UseCallParameters<config, selectData> = {},\n): UseCallReturnType<selectData> {\n  const config = useConfig(parameters)\n  const chainId = useChainId({ config })\n  const options = callQueryOptions(config, {\n    ...parameters,\n    chainId: parameters.chainId ?? chainId,\n    query: parameters.query,\n  })\n  return useQuery(options)\n}\n", "import type { Config } from '../createConfig.js'\nimport type { GetChainsReturnType } from './getChains.js'\n\nexport type WatchChainsParameters<config extends Config = Config> = {\n  onChange(\n    chains: GetChainsReturnType<config>,\n    prevChains: GetChainsReturnType<config>,\n  ): void\n}\n\nexport type WatchChainsReturnType = () => void\n\n/**\n * @internal\n * We don't expose this because as far as consumers know, you can't chainge (lol) `config.chains` at runtime.\n * Setting `config.chains` via `config._internal.chains.setState(...)` is an extremely advanced use case that's not worth documenting or supporting in the public API at this time.\n */\nexport function watchChains<config extends Config>(\n  config: config,\n  parameters: WatchChainsParameters<config>,\n): WatchChainsReturnType {\n  const { onChange } = parameters\n  return config._internal.chains.subscribe((chains, prevChains) => {\n    onChange(\n      chains as unknown as GetChainsReturnType<config>,\n      prevChains as unknown as GetChainsReturnType<config>,\n    )\n  })\n}\n", "'use client'\n\nimport { deepEqual } from '@wagmi/core/internal'\nimport { useMemo, useRef } from 'react'\nimport { useSyncExternalStoreWithSelector } from 'use-sync-external-store/shim/with-selector.js'\n\nconst isPlainObject = (obj: unknown) =>\n  typeof obj === 'object' && !Array.isArray(obj)\n\nexport function useSyncExternalStoreWithTracked<\n  snapshot extends selection,\n  selection = snapshot,\n>(\n  subscribe: (onStoreChange: () => void) => () => void,\n  getSnapshot: () => snapshot,\n  getServerSnapshot: undefined | null | (() => snapshot) = getSnapshot,\n  isEqual: (a: selection, b: selection) => boolean = deepEqual,\n) {\n  const trackedKeys = useRef<string[]>([])\n  const result = useSyncExternalStoreWithSelector(\n    subscribe,\n    getSnapshot,\n    getServerSnapshot,\n    (x) => x,\n    (a, b) => {\n      if (isPlainObject(a) && isPlainObject(b) && trackedKeys.current.length) {\n        for (const key of trackedKeys.current) {\n          const equal = isEqual(\n            (a as { [_a: string]: any })[key],\n            (b as { [_b: string]: any })[key],\n          )\n          if (!equal) return false\n        }\n        return true\n      }\n      return isEqual(a, b)\n    },\n  )\n\n  return useMemo(() => {\n    if (isPlainObject(result)) {\n      const trackedResult = { ...result }\n      let properties = {}\n      for (const [key, value] of Object.entries(\n        trackedResult as { [key: string]: any },\n      )) {\n        properties = {\n          ...properties,\n          [key]: {\n            configurable: false,\n            enumerable: true,\n            get: () => {\n              if (!trackedKeys.current.includes(key)) {\n                trackedKeys.current.push(key)\n              }\n              return value\n            },\n          },\n        }\n      }\n      Object.defineProperties(trackedResult, properties)\n      return trackedResult\n    }\n\n    return result\n  }, [result])\n}\n", "'use client'\n\nimport {\n  type Config,\n  type GetConnectionReturnType,\n  getConnection,\n  type ResolvedRegister,\n  watchConnection,\n} from '@wagmi/core'\n\nimport type { ConfigParameter } from '../types/properties.js'\nimport { useConfig } from './useConfig.js'\nimport { useSyncExternalStoreWithTracked } from './useSyncExternalStoreWithTracked.js'\n\nexport type UseConnectionParameters<config extends Config = Config> =\n  ConfigParameter<config>\n\nexport type UseConnectionReturnType<config extends Config = Config> =\n  GetConnectionReturnType<config>\n\n/** https://wagmi.sh/react/api/hooks/useConnection */\nexport function useConnection<\n  config extends Config = ResolvedRegister['config'],\n>(\n  parameters: UseConnectionParameters<config> = {},\n): UseConnectionReturnType<config> {\n  const config = useConfig(parameters)\n\n  return useSyncExternalStoreWithTracked(\n    (onChange) => watchConnection(config, { onChange }),\n    () => getConnection(config),\n  )\n}\n", "'use client'\nimport type {\n  Config,\n  GetCallsStatusErrorType,\n  ResolvedRegister,\n} from '@wagmi/core'\nimport type { Compute } from '@wagmi/core/internal'\nimport {\n  type GetCallsStatusData,\n  type GetCallsStatusOptions,\n  getCallsStatusQueryOptions,\n} from '@wagmi/core/query'\nimport type { ConfigParameter } from '../types/properties.js'\nimport { type UseQueryReturnType, useQuery } from '../utils/query.js'\nimport { useConfig } from './useConfig.js'\nimport { useConnection } from './useConnection.js'\n\nexport type UseCallsStatusParameters<\n  config extends Config = Config,\n  selectData = GetCallsStatusData,\n> = Compute<GetCallsStatusOptions<selectData> & ConfigParameter<config>>\n\nexport type UseCallsStatusReturnType<selectData = GetCallsStatusData> =\n  UseQueryReturnType<selectData, GetCallsStatusErrorType>\n\n/** https://wagmi.sh/react/api/hooks/useCallsStatus */\nexport function useCallsStatus<\n  config extends Config = ResolvedRegister['config'],\n  selectData = GetCallsStatusData,\n>(\n  parameters: UseCallsStatusParameters<config, selectData>,\n): UseCallsStatusReturnType<selectData> {\n  const config = useConfig(parameters)\n  const { connector } = useConnection({ config })\n  const options = getCallsStatusQueryOptions(config, {\n    ...parameters,\n    connector: parameters.connector ?? connector,\n    query: parameters.query,\n  })\n  return useQuery(options)\n}\n", "'use client'\nimport type {\n  Config,\n  GetCapabilitiesErrorType,\n  ResolvedRegister,\n} from '@wagmi/core'\nimport type { Compute } from '@wagmi/core/internal'\nimport {\n  type GetCapabilitiesData,\n  type GetCapabilitiesOptions,\n  getCapabilitiesQueryOptions,\n} from '@wagmi/core/query'\nimport type { ConfigParameter } from '../types/properties.js'\nimport { type UseQueryReturnType, useQuery } from '../utils/query.js'\nimport { useConfig } from './useConfig.js'\nimport { useConnection } from './useConnection.js'\n\nexport type UseCapabilitiesParameters<\n  config extends Config = Config,\n  chainId extends config['chains'][number]['id'] | undefined = undefined,\n  selectData = GetCapabilitiesData<config, chainId>,\n> = Compute<\n  GetCapabilitiesOptions<config, chainId, selectData> & ConfigParameter<config>\n>\n\nexport type UseCapabilitiesReturnType<\n  config extends Config = Config,\n  chainId extends config['chains'][number]['id'] | undefined = undefined,\n  selectData = GetCapabilitiesData<config, chainId>,\n> = UseQueryReturnType<selectData, GetCapabilitiesErrorType>\n\n/** https://wagmi.sh/react/api/hooks/useCapabilities */\nexport function useCapabilities<\n  config extends Config = ResolvedRegister['config'],\n  chainId extends config['chains'][number]['id'] | undefined = undefined,\n  selectData = GetCapabilitiesData<config, chainId>,\n>(\n  parameters: UseCapabilitiesParameters<config, chainId, selectData> = {},\n): UseCapabilitiesReturnType<config, chainId, selectData> {\n  const config = useConfig(parameters)\n  const { address, connector } = useConnection({ config })\n  const options = getCapabilitiesQueryOptions(config, {\n    ...parameters,\n    account: parameters.account ?? address,\n    connector: parameters.connector ?? connector,\n    query: parameters.query,\n  })\n  return useQuery(options as never) as any\n}\n", "'use client'\n\nimport {\n  type Config,\n  type GetChainsReturnType,\n  getChains,\n  type ResolvedRegister,\n} from '@wagmi/core'\nimport { watchChains } from '@wagmi/core/internal'\nimport { useSyncExternalStore } from 'react'\n\nimport type { ConfigParameter } from '../types/properties.js'\nimport { useConfig } from './useConfig.js'\n\nexport type UseChainsParameters<config extends Config = Config> =\n  ConfigParameter<config>\n\nexport type UseChainsReturnType<config extends Config = Config> =\n  GetChainsReturnType<config>\n\n/** https://wagmi.sh/react/api/hooks/useChains */\nexport function useChains<config extends Config = ResolvedRegister['config']>(\n  parameters: UseChainsParameters<config> = {},\n): UseChainsReturnType<config> {\n  const config = useConfig(parameters)\n\n  return useSyncExternalStore(\n    (onChange) => watchChains(config, { onChange }),\n    () => getChains(config),\n    () => getChains(config),\n  )\n}\n", "'use client'\n\nimport {\n  type Config,\n  type GetClientParameters,\n  type GetClientReturnType,\n  getClient,\n  type ResolvedRegister,\n  watchClient,\n} from '@wagmi/core'\nimport type { Compute } from '@wagmi/core/internal'\nimport { useSyncExternalStoreWithSelector } from 'use-sync-external-store/shim/with-selector.js'\n\nimport type { ConfigParameter } from '../types/properties.js'\nimport { useConfig } from './useConfig.js'\n\nexport type UseClientParameters<\n  config extends Config = Config,\n  chainId extends config['chains'][number]['id'] | number | undefined =\n    | config['chains'][number]['id']\n    | undefined,\n> = Compute<GetClientParameters<config, chainId> & ConfigParameter<config>>\n\nexport type UseClientReturnType<\n  config extends Config = Config,\n  chainId extends config['chains'][number]['id'] | number | undefined =\n    | config['chains'][number]['id']\n    | undefined,\n> = GetClientReturnType<config, chainId>\n\n/** https://wagmi.sh/react/api/hooks/useClient */\nexport function useClient<\n  config extends Config = ResolvedRegister['config'],\n  chainId extends config['chains'][number]['id'] | number | undefined =\n    | config['chains'][number]['id']\n    | undefined,\n>(\n  parameters: UseClientParameters<config, chainId> = {},\n): UseClientReturnType<config, chainId> {\n  const config = useConfig(parameters)\n\n  return useSyncExternalStoreWithSelector(\n    (onChange) => watchClient(config, { onChange }),\n    () => getClient(config, parameters),\n    () => getClient(config, parameters),\n    (x) => x,\n    (a, b) => a?.uid === b?.uid,\n  ) as any\n}\n", "'use client'\n\nimport { useMutation } from '@tanstack/react-query'\nimport type { Config, ConnectErrorType, ResolvedRegister } from '@wagmi/core'\nimport type { Compute } from '@wagmi/core/internal'\nimport {\n  type ConnectData,\n  type ConnectMutate,\n  type ConnectMutateAsync,\n  type ConnectVariables,\n  connectMutationOptions,\n} from '@wagmi/core/query'\nimport { useEffect } from 'react'\n\nimport type { ConfigParameter } from '../types/properties.js'\nimport type {\n  UseMutationParameters,\n  UseMutationReturnType,\n} from '../utils/query.js'\nimport { useConfig } from './useConfig.js'\nimport { type UseConnectorsReturnType, useConnectors } from './useConnectors.js'\n\nexport type UseConnectParameters<\n  config extends Config = Config,\n  context = unknown,\n> = Compute<\n  ConfigParameter<config> & {\n    mutation?:\n      | UseMutationParameters<\n          ConnectData<config, config['connectors'][number], boolean>,\n          ConnectErrorType,\n          ConnectVariables<config, config['connectors'][number], boolean>,\n          context\n        >\n      | undefined\n  }\n>\n\nexport type UseConnectReturnType<\n  config extends Config = Config,\n  context = unknown,\n> = Compute<\n  UseMutationReturnType<\n    ConnectData<config, config['connectors'][number], boolean>,\n    ConnectErrorType,\n    ConnectVariables<config, config['connectors'][number], boolean>,\n    context\n  > & {\n    /** @deprecated use `mutate` instead */\n    connect: ConnectMutate<config, context>\n    /** @deprecated use `mutateAsync` instead */\n    connectAsync: ConnectMutateAsync<config, context>\n    /** @deprecated use `useConnectors` instead */\n    connectors: Compute<UseConnectorsReturnType> | config['connectors']\n    mutate: ConnectMutate<config, context>\n    mutateAsync: ConnectMutateAsync<config, context>\n  }\n>\n\n/** https://wagmi.sh/react/api/hooks/useConnect */\nexport function useConnect<\n  config extends Config = ResolvedRegister['config'],\n  context = unknown,\n>(\n  parameters: UseConnectParameters<config, context> = {},\n): UseConnectReturnType<config, context> {\n  const config = useConfig(parameters)\n\n  const mutationOptions = connectMutationOptions(config)\n  const mutation = useMutation({\n    ...(parameters.mutation as typeof mutationOptions),\n    ...mutationOptions,\n  })\n\n  // Reset mutation back to an idle state when the connector disconnects.\n  useEffect(() => {\n    return config.subscribe(\n      ({ status }) => status,\n      (status, previousStatus) => {\n        if (previousStatus === 'connected' && status === 'disconnected')\n          mutation.reset()\n      },\n    )\n  }, [config, mutation.reset])\n\n  type Return = UseConnectReturnType<config, context>\n  return {\n    ...(mutation as Return),\n    connect: mutation.mutate as Return['mutate'],\n    connectAsync: mutation.mutateAsync as Return['mutateAsync'],\n    connectors: useConnectors({ config }),\n  }\n}\n", "'use client'\n\nimport {\n  type Config,\n  type GetConnectorsReturnType,\n  getConnectors,\n  type ResolvedRegister,\n  watchConnectors,\n} from '@wagmi/core'\nimport { useSyncExternalStore } from 'react'\n\nimport type { ConfigParameter } from '../types/properties.js'\nimport { useConfig } from './useConfig.js'\n\nexport type UseConnectorsParameters<config extends Config = Config> =\n  ConfigParameter<config>\n\nexport type UseConnectorsReturnType<config extends Config = Config> =\n  GetConnectorsReturnType<config>\n\n/** https://wagmi.sh/react/api/hooks/useConnectors */\nexport function useConnectors<\n  config extends Config = ResolvedRegister['config'],\n>(\n  parameters: UseConnectorsParameters<config> = {},\n): UseConnectorsReturnType<config> {\n  const config = useConfig(parameters)\n\n  return useSyncExternalStore(\n    (onChange) => watchConnectors(config, { onChange }),\n    () => getConnectors(config),\n    () => getConnectors(config),\n  )\n}\n", "'use client'\n\nimport { type GetConnectionReturnType, watchConnection } from '@wagmi/core'\nimport type { Compute } from '@wagmi/core/internal'\nimport { useEffect } from 'react'\n\nimport type { ConfigParameter } from '../types/properties.js'\nimport { useConfig } from './useConfig.js'\n\nexport type UseConnectionEffectParameters = Compute<\n  {\n    onConnect?(\n      data: Compute<\n        Pick<\n          Extract<GetConnectionReturnType, { status: 'connected' }>,\n          'address' | 'addresses' | 'chain' | 'chainId' | 'connector'\n        > & {\n          isReconnected: boolean\n        }\n      >,\n    ): void\n    onDisconnect?(): void\n  } & ConfigParameter\n>\n\n/** https://wagmi.sh/react/api/hooks/useConnectionEffect */\nexport function useConnectionEffect(\n  parameters: UseConnectionEffectParameters = {},\n) {\n  const { onConnect, onDisconnect } = parameters\n\n  const config = useConfig(parameters)\n\n  useEffect(() => {\n    return watchConnection(config, {\n      onChange(data, prevData) {\n        if (\n          (prevData.status === 'reconnecting' ||\n            (prevData.status === 'connecting' &&\n              prevData.address === undefined)) &&\n          data.status === 'connected'\n        ) {\n          const { address, addresses, chain, chainId, connector } = data\n          const isReconnected =\n            prevData.status === 'reconnecting' ||\n            // if `previousAccount.status` is `undefined`, the connector connected immediately.\n            prevData.status === undefined\n          onConnect?.({\n            address,\n            addresses,\n            chain,\n            chainId,\n            connector,\n            isReconnected,\n          })\n        } else if (\n          prevData.status === 'connected' &&\n          data.status === 'disconnected'\n        )\n          onDisconnect?.()\n      },\n    })\n  }, [config, onConnect, onDisconnect])\n}\n", "'use client'\n\nimport {\n  type GetConnectionsReturnType,\n  getConnections,\n  watchConnections,\n} from '@wagmi/core'\nimport { useSyncExternalStore } from 'react'\n\nimport type { ConfigParameter } from '../types/properties.js'\nimport { useConfig } from './useConfig.js'\n\nexport type UseConnectionsParameters = ConfigParameter\n\nexport type UseConnectionsReturnType = GetConnectionsReturnType\n\n/** https://wagmi.sh/react/api/hooks/useConnections */\nexport function useConnections(\n  parameters: UseConnectionsParameters = {},\n): UseConnectionsReturnType {\n  const config = useConfig(parameters)\n\n  return useSyncExternalStore(\n    (onChange) => watchConnections(config, { onChange }),\n    () => getConnections(config),\n    () => getConnections(config),\n  )\n}\n", "'use client'\n\nimport { useQueryClient } from '@tanstack/react-query'\nimport type {\n  Config,\n  GetConnectorClientErrorType,\n  ResolvedRegister,\n} from '@wagmi/core'\nimport type { Compute } from '@wagmi/core/internal'\nimport {\n  type GetConnectorClientData,\n  type GetConnectorClientOptions,\n  getConnectorClientQueryOptions,\n} from '@wagmi/core/query'\nimport { useEffect, useRef } from 'react'\n\nimport type { ConfigParameter } from '../types/properties.js'\nimport { type UseQueryReturnType, useQuery } from '../utils/query.js'\nimport { useChainId } from './useChainId.js'\nimport { useConfig } from './useConfig.js'\nimport { useConnection } from './useConnection.js'\n\nexport type UseConnectorClientParameters<\n  config extends Config = Config,\n  chainId extends\n    config['chains'][number]['id'] = config['chains'][number]['id'],\n  selectData = GetConnectorClientData<config, chainId>,\n> = Compute<\n  GetConnectorClientOptions<config, chainId, selectData> &\n    ConfigParameter<config>\n>\n\nexport type UseConnectorClientReturnType<\n  config extends Config = Config,\n  chainId extends\n    config['chains'][number]['id'] = config['chains'][number]['id'],\n  selectData = GetConnectorClientData<config, chainId>,\n> = UseQueryReturnType<selectData, GetConnectorClientErrorType>\n\n/** https://wagmi.sh/react/api/hooks/useConnectorClient */\nexport function useConnectorClient<\n  config extends Config = ResolvedRegister['config'],\n  chainId extends\n    config['chains'][number]['id'] = config['chains'][number]['id'],\n  selectData = GetConnectorClientData<config, chainId>,\n>(\n  parameters: UseConnectorClientParameters<config, chainId, selectData> = {},\n): UseConnectorClientReturnType<config, chainId, selectData> {\n  const config = useConfig(parameters)\n  const chainId = useChainId({ config })\n  const { address, connector } = useConnection({ config })\n  const options = getConnectorClientQueryOptions(config, {\n    ...parameters,\n    chainId: parameters.chainId ?? chainId,\n    connector: parameters.connector ?? connector,\n    query: parameters.query as any,\n  })\n\n  const addressRef = useRef(address)\n  const queryClient = useQueryClient()\n  // biome-ignore lint/correctness/useExhaustiveDependencies: `queryKey` not required\n  useEffect(() => {\n    const previousAddress = addressRef.current\n    if (!address && previousAddress) {\n      // remove when account is disconnected\n      queryClient.removeQueries({ queryKey: options.queryKey })\n      addressRef.current = undefined\n    } else if (address !== previousAddress) {\n      // invalidate when address changes\n      queryClient.invalidateQueries({ queryKey: options.queryKey })\n      addressRef.current = address\n    }\n  }, [address, queryClient])\n\n  return useQuery(options) as any\n}\n", "'use client'\n\nimport { useMutation } from '@tanstack/react-query'\nimport type {\n  Config,\n  DeployContractErrorType,\n  ResolvedRegister,\n} from '@wagmi/core'\nimport type { Compute } from '@wagmi/core/internal'\nimport {\n  type DeployContractData,\n  type DeployContractMutate,\n  type DeployContractMutateAsync,\n  type DeployContractVariables,\n  deployContractMutationOptions,\n} from '@wagmi/core/query'\nimport type { Abi } from 'viem'\n\nimport type { ConfigParameter } from '../types/properties.js'\nimport type {\n  UseMutationParameters,\n  UseMutationReturnType,\n} from '../utils/query.js'\nimport { useConfig } from './useConfig.js'\n\nexport type UseDeployContractParameters<\n  config extends Config = Config,\n  context = unknown,\n> = Compute<\n  ConfigParameter<config> & {\n    mutation?:\n      | UseMutationParameters<\n          DeployContractData,\n          DeployContractErrorType,\n          DeployContractVariables<Abi, config, config['chains'][number]['id']>,\n          context\n        >\n      | undefined\n  }\n>\n\nexport type UseDeployContractReturnType<\n  config extends Config = Config,\n  context = unknown,\n> = UseMutationReturnType<\n  DeployContractData,\n  DeployContractErrorType,\n  DeployContractVariables<Abi, config, config['chains'][number]['id']>,\n  context\n> & {\n  /** @deprecated use `mutate` instead */\n  deployContract: DeployContractMutate<config, context>\n  /** @deprecated use `mutateAsync` instead */\n  deployContractAsync: DeployContractMutateAsync<config, context>\n  mutate: DeployContractMutate<config, context>\n  mutateAsync: DeployContractMutateAsync<config, context>\n}\n\n/** https://wagmi.sh/react/api/hooks/useDeployContract */\nexport function useDeployContract<\n  config extends Config = ResolvedRegister['config'],\n  context = unknown,\n>(\n  parameters: UseDeployContractParameters<config, context> = {},\n): UseDeployContractReturnType<config, context> {\n  const config = useConfig(parameters)\n  const mutationOptions = deployContractMutationOptions(config)\n  const mutation = useMutation({ ...parameters.mutation, ...mutationOptions })\n  type Return = UseDeployContractReturnType<config, context>\n  return {\n    ...mutation,\n    deployContract: mutation.mutate as Return['mutate'],\n    deployContractAsync: mutation.mutateAsync as Return['mutateAsync'],\n    mutate: mutation.mutate as Return['mutate'],\n    mutateAsync: mutation.mutateAsync as Return['mutateAsync'],\n  }\n}\n", "'use client'\n\nimport { useMutation } from '@tanstack/react-query'\nimport type { Connector, DisconnectErrorType } from '@wagmi/core'\nimport type { Compute } from '@wagmi/core/internal'\nimport {\n  type DisconnectData,\n  type DisconnectMutate,\n  type DisconnectMutateAsync,\n  type DisconnectVariables,\n  disconnectMutationOptions,\n} from '@wagmi/core/query'\n\nimport type { ConfigParameter } from '../types/properties.js'\nimport type {\n  UseMutationParameters,\n  UseMutationReturnType,\n} from '../utils/query.js'\nimport { useConfig } from './useConfig.js'\nimport { useConnections } from './useConnections.js'\n\nexport type UseDisconnectParameters<context = unknown> = Compute<\n  ConfigParameter & {\n    mutation?:\n      | UseMutationParameters<\n          DisconnectData,\n          DisconnectErrorType,\n          DisconnectVariables,\n          context\n        >\n      | undefined\n  }\n>\n\nexport type UseDisconnectReturnType<context = unknown> = Compute<\n  UseMutationReturnType<\n    DisconnectData,\n    DisconnectErrorType,\n    DisconnectVariables,\n    context\n  > & {\n    /** @deprecated use `useConnections` instead */\n    connectors: readonly Connector[]\n    /** @deprecated use `mutate` instead */\n    disconnect: DisconnectMutate<context>\n    /** @deprecated use `mutateAsync` instead */\n    disconnectAsync: DisconnectMutateAsync<context>\n    mutate: DisconnectMutate<context>\n    mutateAsync: DisconnectMutateAsync<context>\n  }\n>\n\n/** https://wagmi.sh/react/api/hooks/useDisconnect */\nexport function useDisconnect<context = unknown>(\n  parameters: UseDisconnectParameters<context> = {},\n): UseDisconnectReturnType<context> {\n  const config = useConfig(parameters)\n  const mutationOptions = disconnectMutationOptions(config)\n  const mutation = useMutation({ ...parameters.mutation, ...mutationOptions })\n  return {\n    ...mutation,\n    connectors: useConnections({ config }).map(\n      (connection) => connection.connector,\n    ),\n    disconnect: mutation.mutate,\n    disconnectAsync: mutation.mutateAsync,\n  }\n}\n", "'use client'\nimport type {\n  Config,\n  GetEnsAddressErrorType,\n  ResolvedRegister,\n} from '@wagmi/core'\nimport type { Compute } from '@wagmi/core/internal'\nimport {\n  type GetEnsAddressData,\n  type GetEnsAddressOptions,\n  getEnsAddressQueryOptions,\n} from '@wagmi/core/query'\nimport type { ConfigParameter } from '../types/properties.js'\nimport { type UseQueryReturnType, useQuery } from '../utils/query.js'\nimport { useChainId } from './useChainId.js'\nimport { useConfig } from './useConfig.js'\n\nexport type UseEnsAddressParameters<\n  config extends Config = Config,\n  selectData = GetEnsAddressData,\n> = Compute<GetEnsAddressOptions<config, selectData> & ConfigParameter<config>>\n\nexport type UseEnsAddressReturnType<selectData = GetEnsAddressData> =\n  UseQueryReturnType<selectData, GetEnsAddressErrorType>\n\n/** https://wagmi.sh/react/api/hooks/useEnsAddress */\nexport function useEnsAddress<\n  config extends Config = ResolvedRegister['config'],\n  selectData = GetEnsAddressData,\n>(\n  parameters: UseEnsAddressParameters<config, selectData> = {},\n): UseEnsAddressReturnType<selectData> {\n  const config = useConfig(parameters)\n  const chainId = useChainId({ config })\n  const options = getEnsAddressQueryOptions(config, {\n    ...parameters,\n    chainId: parameters.chainId ?? chainId,\n    query: parameters.query,\n  })\n  return useQuery(options)\n}\n", "'use client'\nimport type {\n  Config,\n  GetEnsAvatarErrorType,\n  ResolvedRegister,\n} from '@wagmi/core'\nimport type { Compute } from '@wagmi/core/internal'\nimport {\n  type GetEnsAvatarData,\n  type GetEnsAvatarOptions,\n  getEnsAvatarQueryOptions,\n} from '@wagmi/core/query'\nimport type { ConfigParameter } from '../types/properties.js'\nimport { type UseQueryReturnType, useQuery } from '../utils/query.js'\nimport { useChainId } from './useChainId.js'\nimport { useConfig } from './useConfig.js'\n\nexport type UseEnsAvatarParameters<\n  config extends Config = Config,\n  selectData = GetEnsAvatarData,\n> = Compute<GetEnsAvatarOptions<config, selectData> & ConfigParameter<config>>\n\nexport type UseEnsAvatarReturnType<selectData = GetEnsAvatarData> =\n  UseQueryReturnType<selectData, GetEnsAvatarErrorType>\n\n/** https://wagmi.sh/react/api/hooks/useEnsAvatar */\nexport function useEnsAvatar<\n  config extends Config = ResolvedRegister['config'],\n  selectData = GetEnsAvatarData,\n>(\n  parameters: UseEnsAvatarParameters<config, selectData> = {},\n): UseEnsAvatarReturnType<selectData> {\n  const config = useConfig(parameters)\n  const chainId = useChainId({ config })\n  const options = getEnsAvatarQueryOptions(config, {\n    ...parameters,\n    chainId: parameters.chainId ?? chainId,\n    query: parameters.query,\n  })\n  return useQuery(options)\n}\n", "'use client'\nimport type { Config, GetEnsNameErrorType, ResolvedRegister } from '@wagmi/core'\nimport type { Compute } from '@wagmi/core/internal'\nimport {\n  type GetEnsNameData,\n  type GetEnsNameOptions,\n  getEnsNameQueryOptions,\n} from '@wagmi/core/query'\nimport type { ConfigParameter } from '../types/properties.js'\nimport { type UseQueryReturnType, useQuery } from '../utils/query.js'\nimport { useChainId } from './useChainId.js'\nimport { useConfig } from './useConfig.js'\n\nexport type UseEnsNameParameters<\n  config extends Config = Config,\n  selectData = GetEnsNameData,\n> = Compute<GetEnsNameOptions<config, selectData> & ConfigParameter<config>>\n\nexport type UseEnsNameReturnType<selectData = GetEnsNameData> =\n  UseQueryReturnType<selectData, GetEnsNameErrorType>\n\n/** https://wagmi.sh/react/api/hooks/useEnsName */\nexport function useEnsName<\n  config extends Config = ResolvedRegister['config'],\n  selectData = GetEnsNameData,\n>(\n  parameters: UseEnsNameParameters<config, selectData> = {},\n): UseEnsNameReturnType<selectData> {\n  const config = useConfig(parameters)\n  const chainId = useChainId({ config })\n  const options = getEnsNameQueryOptions(config, {\n    ...parameters,\n    chainId: parameters.chainId ?? chainId,\n    query: parameters.query,\n  })\n  return useQuery(options)\n}\n", "'use client'\nimport type {\n  Config,\n  GetEnsResolverErrorType,\n  ResolvedRegister,\n} from '@wagmi/core'\nimport type { Compute } from '@wagmi/core/internal'\nimport {\n  type GetEnsResolverData,\n  type GetEnsResolverOptions,\n  getEnsResolverQueryOptions,\n} from '@wagmi/core/query'\nimport type { ConfigParameter } from '../types/properties.js'\nimport { type UseQueryReturnType, useQuery } from '../utils/query.js'\nimport { useChainId } from './useChainId.js'\nimport { useConfig } from './useConfig.js'\n\nexport type UseEnsResolverParameters<\n  config extends Config = Config,\n  selectData = GetEnsResolverData,\n> = Compute<GetEnsResolverOptions<config, selectData> & ConfigParameter<config>>\n\nexport type UseEnsResolverReturnType<selectData = GetEnsResolverData> =\n  UseQueryReturnType<selectData, GetEnsResolverErrorType>\n\n/** https://wagmi.sh/react/api/hooks/useEnsResolver */\nexport function useEnsResolver<\n  config extends Config = ResolvedRegister['config'],\n  selectData = GetEnsResolverData,\n>(\n  parameters: UseEnsResolverParameters<config, selectData> = {},\n): UseEnsResolverReturnType<selectData> {\n  const config = useConfig(parameters)\n  const chainId = useChainId({ config })\n  const options = getEnsResolverQueryOptions(config, {\n    ...parameters,\n    chainId: parameters.chainId ?? chainId,\n    query: parameters.query,\n  })\n  return useQuery(options)\n}\n", "'use client'\nimport type { Config, GetEnsTextErrorType, ResolvedRegister } from '@wagmi/core'\nimport type { Compute } from '@wagmi/core/internal'\nimport {\n  type GetEnsTextData,\n  type GetEnsTextOptions,\n  getEnsTextQueryOptions,\n} from '@wagmi/core/query'\nimport type { ConfigParameter } from '../types/properties.js'\nimport { type UseQueryReturnType, useQuery } from '../utils/query.js'\nimport { useChainId } from './useChainId.js'\nimport { useConfig } from './useConfig.js'\n\nexport type UseEnsTextParameters<\n  config extends Config = Config,\n  selectData = GetEnsTextData,\n> = Compute<GetEnsTextOptions<config, selectData> & ConfigParameter<config>>\n\nexport type UseEnsTextReturnType<selectData = GetEnsTextData> =\n  UseQueryReturnType<selectData, GetEnsTextErrorType>\n\n/** https://wagmi.sh/react/api/hooks/useEnsText */\nexport function useEnsText<\n  config extends Config = ResolvedRegister['config'],\n  selectData = GetEnsTextData,\n>(\n  parameters: UseEnsTextParameters<config, selectData> = {},\n): UseEnsTextReturnType<selectData> {\n  const config = useConfig(parameters)\n  const chainId = useChainId({ config })\n  const options = getEnsTextQueryOptions(config, {\n    ...parameters,\n    chainId: parameters.chainId ?? chainId,\n    query: parameters.query,\n  })\n  return useQuery(options)\n}\n", "'use client'\nimport type {\n  Config,\n  EstimateFeesPerGasErrorType,\n  ResolvedRegister,\n} from '@wagmi/core'\nimport type { Compute } from '@wagmi/core/internal'\nimport {\n  type EstimateFeesPerGasData,\n  type EstimateFeesPerGasOptions,\n  estimateFeesPerGasQueryOptions,\n} from '@wagmi/core/query'\nimport type { FeeValuesType } from 'viem'\nimport type { ConfigParameter } from '../types/properties.js'\nimport { type UseQueryReturnType, useQuery } from '../utils/query.js'\nimport { useChainId } from './useChainId.js'\nimport { useConfig } from './useConfig.js'\n\nexport type UseEstimateFeesPerGasParameters<\n  type extends FeeValuesType = FeeValuesType,\n  config extends Config = Config,\n  selectData = EstimateFeesPerGasData<type>,\n> = Compute<\n  EstimateFeesPerGasOptions<type, config, selectData> & ConfigParameter<config>\n>\n\nexport type UseEstimateFeesPerGasReturnType<\n  type extends FeeValuesType = FeeValuesType,\n  selectData = EstimateFeesPerGasData<type>,\n> = UseQueryReturnType<selectData, EstimateFeesPerGasErrorType>\n\n/** https://wagmi.sh/react/api/hooks/useEstimateFeesPerGas */\nexport function useEstimateFeesPerGas<\n  config extends Config = ResolvedRegister['config'],\n  type extends FeeValuesType = 'eip1559',\n  selectData = EstimateFeesPerGasData<type>,\n>(\n  parameters: UseEstimateFeesPerGasParameters<type, config, selectData> = {},\n): UseEstimateFeesPerGasReturnType<type, selectData> {\n  const config = useConfig(parameters)\n  const chainId = useChainId({ config })\n  const options = estimateFeesPerGasQueryOptions(config, {\n    ...parameters,\n    chainId: parameters.chainId ?? chainId,\n    query: parameters.query,\n  })\n  return useQuery(options)\n}\n", "'use client'\nimport type {\n  Config,\n  EstimateGasErrorType,\n  ResolvedRegister,\n} from '@wagmi/core'\nimport {\n  type EstimateGasData,\n  type EstimateGasOptions,\n  estimateGasQueryOptions,\n} from '@wagmi/core/query'\nimport type { ConfigParameter } from '../types/properties.js'\nimport { type UseQueryReturnType, useQuery } from '../utils/query.js'\nimport { useChainId } from './useChainId.js'\nimport { useConfig } from './useConfig.js'\nimport { useConnection } from './useConnection.js'\n\nexport type UseEstimateGasParameters<\n  config extends Config = Config,\n  chainId extends config['chains'][number]['id'] | undefined = undefined,\n  selectData = EstimateGasData,\n> = EstimateGasOptions<config, chainId, selectData> & ConfigParameter<config>\n\nexport type UseEstimateGasReturnType<selectData = EstimateGasData> =\n  UseQueryReturnType<selectData, EstimateGasErrorType>\n\n/** https://wagmi.sh/react/api/hooks/useEstimateGas */\nexport function useEstimateGas<\n  config extends Config = ResolvedRegister['config'],\n  chainId extends config['chains'][number]['id'] | undefined = undefined,\n  selectData = EstimateGasData,\n>(\n  parameters?: UseEstimateGasParameters<config, chainId, selectData>,\n): UseEstimateGasReturnType<selectData>\n\nexport function useEstimateGas(\n  parameters: UseEstimateGasParameters = {},\n): UseEstimateGasReturnType {\n  const config = useConfig(parameters)\n  const { address, connector } = useConnection()\n  const chainId = useChainId({ config })\n  const options = estimateGasQueryOptions(config, {\n    ...parameters,\n    account: parameters.account ?? address,\n    chainId: parameters.chainId ?? chainId,\n    connector: parameters.connector ?? connector,\n    query: parameters.query,\n  })\n  return useQuery(options)\n}\n", "'use client'\nimport type {\n  Config,\n  EstimateMaxPriorityFeePerGasErrorType,\n  ResolvedRegister,\n} from '@wagmi/core'\nimport type { Compute } from '@wagmi/core/internal'\nimport {\n  type EstimateMaxPriorityFeePerGasData,\n  type EstimateMaxPriorityFeePerGasOptions,\n  estimateMaxPriorityFeePerGasQueryOptions,\n} from '@wagmi/core/query'\nimport type { ConfigParameter } from '../types/properties.js'\nimport { type UseQueryReturnType, useQuery } from '../utils/query.js'\nimport { useChainId } from './useChainId.js'\nimport { useConfig } from './useConfig.js'\n\nexport type UseEstimateMaxPriorityFeePerGasParameters<\n  config extends Config = Config,\n  selectData = EstimateMaxPriorityFeePerGasData,\n> = Compute<\n  EstimateMaxPriorityFeePerGasOptions<config, selectData> &\n    ConfigParameter<config>\n>\n\nexport type UseEstimateMaxPriorityFeePerGasReturnType<\n  selectData = EstimateMaxPriorityFeePerGasData,\n> = UseQueryReturnType<selectData, EstimateMaxPriorityFeePerGasErrorType>\n\n/** https://wagmi.sh/react/api/hooks/useEstimateMaxPriorityFeePerGas */\nexport function useEstimateMaxPriorityFeePerGas<\n  config extends Config = ResolvedRegister['config'],\n  selectData = EstimateMaxPriorityFeePerGasData,\n>(\n  parameters: UseEstimateMaxPriorityFeePerGasParameters<\n    config,\n    selectData\n  > = {},\n): UseEstimateMaxPriorityFeePerGasReturnType<selectData> {\n  const config = useConfig(parameters)\n  const chainId = useChainId({ config })\n  const options = estimateMaxPriorityFeePerGasQueryOptions(config, {\n    ...parameters,\n    chainId: parameters.chainId ?? chainId,\n    query: parameters.query,\n  })\n  return useQuery(options)\n}\n", "'use client'\nimport type {\n  Config,\n  GetFeeHistoryErrorType,\n  ResolvedRegister,\n} from '@wagmi/core'\nimport type { Compute } from '@wagmi/core/internal'\nimport {\n  type GetFeeHistoryData,\n  type GetFeeHistoryOptions,\n  getFeeHistoryQueryOptions,\n} from '@wagmi/core/query'\nimport type { ConfigParameter } from '../types/properties.js'\nimport { type UseQueryReturnType, useQuery } from '../utils/query.js'\nimport { useChainId } from './useChainId.js'\nimport { useConfig } from './useConfig.js'\n\nexport type UseFeeHistoryParameters<\n  config extends Config = Config,\n  chainId extends\n    config['chains'][number]['id'] = config['chains'][number]['id'],\n  selectData = GetFeeHistoryData,\n> = Compute<\n  GetFeeHistoryOptions<config, chainId, selectData> & ConfigParameter<config>\n>\n\nexport type UseFeeHistoryReturnType<selectData = GetFeeHistoryData> =\n  UseQueryReturnType<selectData, GetFeeHistoryErrorType>\n\n/** https://wagmi.sh/react/api/hooks/useFeeHistory */\nexport function useFeeHistory<\n  config extends Config = ResolvedRegister['config'],\n  chainId extends\n    config['chains'][number]['id'] = config['chains'][number]['id'],\n  selectData = GetFeeHistoryData,\n>(\n  parameters: UseFeeHistoryParameters<config, chainId, selectData> = {},\n): UseFeeHistoryReturnType<selectData> {\n  const config = useConfig(parameters)\n  const chainId = useChainId({ config })\n  const options = getFeeHistoryQueryOptions(config, {\n    ...parameters,\n    chainId: parameters.chainId ?? chainId,\n    query: parameters.query,\n  })\n  return useQuery(options)\n}\n", "'use client'\nimport type {\n  Config,\n  GetGasPriceErrorType,\n  ResolvedRegister,\n} from '@wagmi/core'\nimport type { Compute } from '@wagmi/core/internal'\nimport {\n  type GetGasPriceData,\n  type GetGasPriceOptions,\n  getGasPriceQueryOptions,\n} from '@wagmi/core/query'\nimport type { ConfigParameter } from '../types/properties.js'\nimport { type UseQueryReturnType, useQuery } from '../utils/query.js'\nimport { useChainId } from './useChainId.js'\nimport { useConfig } from './useConfig.js'\n\nexport type UseGasPriceParameters<\n  config extends Config = Config,\n  chainId extends\n    config['chains'][number]['id'] = config['chains'][number]['id'],\n  selectData = GetGasPriceData,\n> = Compute<\n  GetGasPriceOptions<config, chainId, selectData> & ConfigParameter<config>\n>\n\nexport type UseGasPriceReturnType<selectData = GetGasPriceData> =\n  UseQueryReturnType<selectData, GetGasPriceErrorType>\n\n/** https://wagmi.sh/react/api/hooks/useGasPrice */\nexport function useGasPrice<\n  config extends Config = ResolvedRegister['config'],\n  chainId extends\n    config['chains'][number]['id'] = config['chains'][number]['id'],\n  selectData = GetGasPriceData,\n>(\n  parameters: UseGasPriceParameters<config, chainId, selectData> = {},\n): UseGasPriceReturnType<selectData> {\n  const config = useConfig(parameters)\n  const chainId = useChainId({ config })\n  const options = getGasPriceQueryOptions(config, {\n    ...parameters,\n    chainId: parameters.chainId ?? chainId,\n    query: parameters.query,\n  })\n  return useQuery(options)\n}\n", "'use client'\n\nimport type {\n  Config,\n  ReadContractsErrorType,\n  ResolvedRegister,\n} from '@wagmi/core'\nimport {\n  type InfiniteReadContractsQueryFnData,\n  type InfiniteReadContractsQueryKey,\n  infiniteReadContractsQueryOptions,\n  structuralSharing,\n} from '@wagmi/core/query'\nimport type { ContractFunctionParameters } from 'viem'\n\nimport type {\n  InfiniteReadContractsData,\n  InfiniteReadContractsOptions,\n} from '../exports/query.js'\nimport type {\n  ConfigParameter,\n  InfiniteQueryParameter,\n} from '../types/properties.js'\nimport {\n  type UseInfiniteQueryParameters,\n  type UseInfiniteQueryReturnType,\n  useInfiniteQuery,\n} from '../utils/query.js'\nimport { useChainId } from './useChainId.js'\nimport { useConfig } from './useConfig.js'\n\nexport type UseInfiniteContractReadsParameters<\n  contracts extends readonly unknown[] = readonly ContractFunctionParameters[],\n  allowFailure extends boolean = true,\n  config extends Config = Config,\n  pageParam = unknown,\n  selectData = InfiniteReadContractsData<contracts, allowFailure>,\n> = InfiniteReadContractsOptions<contracts, allowFailure, pageParam, config> &\n  ConfigParameter<config> &\n  InfiniteQueryParameter<\n    InfiniteReadContractsQueryFnData<contracts, allowFailure>,\n    ReadContractsErrorType,\n    selectData,\n    InfiniteReadContractsData<contracts, allowFailure>,\n    InfiniteReadContractsQueryKey<contracts, allowFailure, pageParam, config>,\n    pageParam\n  >\n\nexport type UseInfiniteContractReadsReturnType<\n  contracts extends readonly unknown[] = readonly ContractFunctionParameters[],\n  allowFailure extends boolean = true,\n  selectData = InfiniteReadContractsData<contracts, allowFailure>,\n> = UseInfiniteQueryReturnType<selectData, ReadContractsErrorType>\n\n/** https://wagmi.sh/react/api/hooks/useInfiniteReadContracts */\nexport function useInfiniteReadContracts<\n  const contracts extends readonly unknown[],\n  allowFailure extends boolean = true,\n  config extends Config = ResolvedRegister['config'],\n  pageParam = unknown,\n  selectData = InfiniteReadContractsData<contracts, allowFailure>,\n>(\n  parameters: UseInfiniteContractReadsParameters<\n    contracts,\n    allowFailure,\n    config,\n    pageParam,\n    selectData\n  >,\n): UseInfiniteContractReadsReturnType<contracts, allowFailure, selectData> {\n  const { contracts = [], query } = parameters\n\n  const config = useConfig(parameters)\n  const chainId = useChainId({ config })\n\n  const options = infiniteReadContractsQueryOptions(config, {\n    ...parameters,\n    chainId,\n    contracts: contracts as UseInfiniteContractReadsParameters['contracts'],\n    query: query as UseInfiniteQueryParameters,\n  })\n\n  return useInfiniteQuery({\n    ...(query as any),\n    ...options,\n    initialPageParam: options.initialPageParam,\n    structuralSharing: query.structuralSharing ?? structuralSharing,\n  })\n}\n", "'use client'\nimport type {\n  Config,\n  PrepareTransactionRequestErrorType,\n  ResolvedRegister,\n  SelectChains,\n} from '@wagmi/core'\nimport {\n  type PrepareTransactionRequestData,\n  type PrepareTransactionRequestOptions,\n  prepareTransactionRequestQueryOptions,\n} from '@wagmi/core/query'\nimport type { PrepareTransactionRequestRequest as viem_PrepareTransactionRequestRequest } from 'viem'\nimport type { ConfigParameter } from '../types/properties.js'\nimport { type UseQueryReturnType, useQuery } from '../utils/query.js'\nimport { useChainId } from './useChainId.js'\nimport { useConfig } from './useConfig.js'\n\nexport type UsePrepareTransactionRequestParameters<\n  config extends Config = Config,\n  chainId extends config['chains'][number]['id'] | undefined = undefined,\n  request extends viem_PrepareTransactionRequestRequest<\n    SelectChains<config, chainId>[0],\n    SelectChains<config, chainId>[0]\n  > = viem_PrepareTransactionRequestRequest<\n    SelectChains<config, chainId>[0],\n    SelectChains<config, chainId>[0]\n  >,\n  selectData = PrepareTransactionRequestData<config, chainId, request>,\n> = PrepareTransactionRequestOptions<config, chainId, request, selectData> &\n  ConfigParameter<config>\n\nexport type UsePrepareTransactionRequestReturnType<\n  config extends Config = Config,\n  chainId extends config['chains'][number]['id'] | undefined = undefined,\n  request extends viem_PrepareTransactionRequestRequest<\n    SelectChains<config, chainId>[0],\n    SelectChains<config, chainId>[0]\n  > = viem_PrepareTransactionRequestRequest<\n    SelectChains<config, chainId>[0],\n    SelectChains<config, chainId>[0]\n  >,\n  selectData = PrepareTransactionRequestData<config, chainId, request>,\n> = UseQueryReturnType<selectData, PrepareTransactionRequestErrorType>\n\n/** https://wagmi.sh/react/api/hooks/usePrepareTransactionRequest */\nexport function usePrepareTransactionRequest<\n  config extends Config = ResolvedRegister['config'],\n  chainId extends config['chains'][number]['id'] | undefined = undefined,\n  request extends viem_PrepareTransactionRequestRequest<\n    SelectChains<config, chainId>[0],\n    SelectChains<config, chainId>[0]\n  > = viem_PrepareTransactionRequestRequest<\n    SelectChains<config, chainId>[0],\n    SelectChains<config, chainId>[0]\n  >,\n  selectData = PrepareTransactionRequestData<config, chainId, request>,\n>(\n  parameters: UsePrepareTransactionRequestParameters<\n    config,\n    chainId,\n    request,\n    selectData\n  > = {} as any,\n): UsePrepareTransactionRequestReturnType<\n  config,\n  chainId,\n  request,\n  selectData\n> {\n  const config = useConfig(parameters)\n  const chainId = useChainId({ config })\n  const options = prepareTransactionRequestQueryOptions(config, {\n    ...parameters,\n    chainId: parameters.chainId ?? chainId,\n    query: parameters.query,\n  } as PrepareTransactionRequestOptions<config, chainId, request>)\n  return useQuery(options) as any\n}\n", "'use client'\nimport type { Config, GetProofErrorType, ResolvedRegister } from '@wagmi/core'\nimport type { Compute } from '@wagmi/core/internal'\nimport {\n  type GetProofData,\n  type GetProofOptions,\n  getProofQueryOptions,\n} from '@wagmi/core/query'\nimport type { ConfigParameter } from '../types/properties.js'\nimport { type UseQueryReturnType, useQuery } from '../utils/query.js'\nimport { useChainId } from './useChainId.js'\nimport { useConfig } from './useConfig.js'\n\nexport type UseProofParameters<\n  config extends Config = Config,\n  selectData = GetProofData,\n> = Compute<GetProofOptions<config, selectData> & ConfigParameter<config>>\n\nexport type UseProofReturnType<selectData = GetProofData> = UseQueryReturnType<\n  selectData,\n  GetProofErrorType\n>\n\n/** https://wagmi.sh/react/api/hooks/useProof */\nexport function useProof<\n  config extends Config = ResolvedRegister['config'],\n  selectData = GetProofData,\n>(\n  parameters: UseProofParameters<config, selectData> = {},\n): UseProofReturnType<selectData> {\n  const config = useConfig(parameters)\n  const chainId = useChainId({ config })\n  const options = getProofQueryOptions(config, {\n    ...parameters,\n    chainId: parameters.chainId ?? chainId,\n    query: parameters.query,\n  })\n  return useQuery(options)\n}\n", "'use client'\n\nimport {\n  type Config,\n  type GetPublicClientParameters,\n  type GetPublicClientReturnType,\n  getPublicClient,\n  type ResolvedRegister,\n  watchPublicClient,\n} from '@wagmi/core'\nimport type { Compute } from '@wagmi/core/internal'\nimport { useSyncExternalStoreWithSelector } from 'use-sync-external-store/shim/with-selector.js'\n\nimport type { ConfigParameter } from '../types/properties.js'\nimport { useConfig } from './useConfig.js'\n\nexport type UsePublicClientParameters<\n  config extends Config = Config,\n  chainId extends config['chains'][number]['id'] | number | undefined =\n    | config['chains'][number]['id']\n    | undefined,\n> = Compute<\n  GetPublicClientParameters<config, chainId> & ConfigParameter<config>\n>\n\nexport type UsePublicClientReturnType<\n  config extends Config = Config,\n  chainId extends config['chains'][number]['id'] | number | undefined =\n    | config['chains'][number]['id']\n    | undefined,\n> = GetPublicClientReturnType<config, chainId>\n\n/** https://wagmi.sh/react/api/hooks/usePublicClient */\nexport function usePublicClient<\n  config extends Config = ResolvedRegister['config'],\n  chainId extends config['chains'][number]['id'] | number | undefined =\n    | config['chains'][number]['id']\n    | undefined,\n>(\n  parameters: UsePublicClientParameters<config, chainId> = {},\n): UsePublicClientReturnType<config, chainId> {\n  const config = useConfig(parameters)\n\n  return useSyncExternalStoreWithSelector(\n    (onChange) => watchPublicClient(config, { onChange }),\n    () => getPublicClient(config, parameters),\n    () => getPublicClient(config, parameters),\n    (x) => x,\n    (a, b) => a?.uid === b?.uid,\n  ) as any\n}\n", "'use client'\nimport type {\n  Config,\n  ReadContractErrorType,\n  ResolvedRegister,\n} from '@wagmi/core'\nimport type { UnionCompute } from '@wagmi/core/internal'\nimport {\n  type ReadContractData,\n  type ReadContractOptions,\n  readContractQueryOptions,\n} from '@wagmi/core/query'\nimport type { Abi, ContractFunctionArgs, ContractFunctionName } from 'viem'\nimport type { ConfigParameter } from '../types/properties.js'\nimport { type UseQueryReturnType, useQuery } from '../utils/query.js'\nimport { useChainId } from './useChainId.js'\nimport { useConfig } from './useConfig.js'\n\nexport type UseReadContractParameters<\n  abi extends Abi | readonly unknown[] = Abi,\n  functionName extends ContractFunctionName<\n    abi,\n    'pure' | 'view'\n  > = ContractFunctionName<abi, 'pure' | 'view'>,\n  args extends ContractFunctionArgs<\n    abi,\n    'pure' | 'view',\n    functionName\n  > = ContractFunctionArgs<abi, 'pure' | 'view', functionName>,\n  config extends Config = Config,\n  selectData = ReadContractData<abi, functionName, args>,\n> = UnionCompute<\n  ReadContractOptions<abi, functionName, args, config, selectData> &\n    ConfigParameter<config>\n>\n\nexport type UseReadContractReturnType<\n  abi extends Abi | readonly unknown[] = Abi,\n  functionName extends ContractFunctionName<\n    abi,\n    'pure' | 'view'\n  > = ContractFunctionName<abi, 'pure' | 'view'>,\n  args extends ContractFunctionArgs<\n    abi,\n    'pure' | 'view',\n    functionName\n  > = ContractFunctionArgs<abi, 'pure' | 'view', functionName>,\n  selectData = ReadContractData<abi, functionName, args>,\n> = UseQueryReturnType<selectData, ReadContractErrorType>\n\n/** https://wagmi.sh/react/api/hooks/useReadContract */\nexport function useReadContract<\n  const abi extends Abi | readonly unknown[],\n  functionName extends ContractFunctionName<abi, 'pure' | 'view'>,\n  const args extends ContractFunctionArgs<abi, 'pure' | 'view', functionName>,\n  config extends Config = ResolvedRegister['config'],\n  selectData = ReadContractData<abi, functionName, args>,\n>(\n  parameters: UseReadContractParameters<\n    abi,\n    functionName,\n    args,\n    config,\n    selectData\n  > = {} as any,\n): UseReadContractReturnType<abi, functionName, args, selectData> {\n  const config = useConfig(parameters)\n  const chainId = useChainId({ config })\n  const options = readContractQueryOptions(config, {\n    ...(parameters as any),\n    chainId: parameters.chainId ?? chainId,\n    query: parameters.query,\n  })\n  return useQuery(options) as any\n}\n", "'use client'\nimport type {\n  Config,\n  ReadContractsErrorType,\n  ResolvedRegister,\n} from '@wagmi/core'\nimport type { Compute } from '@wagmi/core/internal'\nimport {\n  type ReadContractsData,\n  type ReadContractsOptions,\n  readContractsQueryOptions,\n} from '@wagmi/core/query'\nimport { useMemo } from 'react'\nimport type { ContractFunctionParameters } from 'viem'\nimport type { ConfigParameter } from '../types/properties.js'\nimport { type UseQueryReturnType, useQuery } from '../utils/query.js'\nimport { useChainId } from './useChainId.js'\nimport { useConfig } from './useConfig.js'\n\nexport type UseReadContractsParameters<\n  contracts extends readonly unknown[] = readonly ContractFunctionParameters[],\n  allowFailure extends boolean = true,\n  config extends Config = Config,\n  selectData = ReadContractsData<contracts, allowFailure>,\n> = Compute<\n  ReadContractsOptions<contracts, allowFailure, config, selectData> &\n    ConfigParameter<config>\n>\n\nexport type UseReadContractsReturnType<\n  contracts extends readonly unknown[] = readonly ContractFunctionParameters[],\n  allowFailure extends boolean = true,\n  selectData = ReadContractsData<contracts, allowFailure>,\n> = UseQueryReturnType<selectData, ReadContractsErrorType>\n\n/** https://wagmi.sh/react/api/hooks/useReadContracts */\nexport function useReadContracts<\n  const contracts extends readonly unknown[],\n  allowFailure extends boolean = true,\n  config extends Config = ResolvedRegister['config'],\n  selectData = ReadContractsData<contracts, allowFailure>,\n>(\n  parameters: UseReadContractsParameters<\n    contracts,\n    allowFailure,\n    config,\n    selectData\n  > = {},\n): UseReadContractsReturnType<contracts, allowFailure, selectData> {\n  const config = useConfig(parameters)\n  const chainId = useChainId({ config })\n  const contractsChainId = useMemo(() => {\n    const firstChainId = (\n      parameters.contracts?.[0] as { chainId?: number } | undefined\n    )?.chainId\n    if (\n      ((parameters.contracts ?? []) as { chainId?: number }[]).every(\n        (contract) => contract.chainId === firstChainId,\n      )\n    )\n      return firstChainId\n    return undefined\n  }, [parameters.contracts])\n  const options = readContractsQueryOptions(config, {\n    ...parameters,\n    chainId: contractsChainId ?? chainId,\n    query: parameters.query,\n  })\n  return useQuery(options) as any\n}\n", "'use client'\n\nimport { useMutation } from '@tanstack/react-query'\nimport type { Connector, ReconnectErrorType } from '@wagmi/core'\nimport type { Compute } from '@wagmi/core/internal'\nimport {\n  type ReconnectData,\n  type ReconnectMutate,\n  type ReconnectMutateAsync,\n  type ReconnectVariables,\n  reconnectMutationOptions,\n} from '@wagmi/core/query'\n\nimport type { ConfigParameter } from '../types/properties.js'\nimport type {\n  UseMutationParameters,\n  UseMutationReturnType,\n} from '../utils/query.js'\nimport { useConfig } from './useConfig.js'\n\nexport type UseReconnectParameters<context = unknown> = Compute<\n  ConfigParameter & {\n    mutation?:\n      | UseMutationParameters<\n          ReconnectData,\n          ReconnectErrorType,\n          ReconnectVariables,\n          context\n        >\n      | undefined\n  }\n>\n\nexport type UseReconnectReturnType<context = unknown> = Compute<\n  UseMutationReturnType<\n    ReconnectData,\n    ReconnectErrorType,\n    ReconnectVariables,\n    context\n  > & {\n    connectors: readonly Connector[]\n    mutate: ReconnectMutate<context>\n    mutateAsync: ReconnectMutateAsync<context>\n    /** @deprecated use `mutate` instead */\n    reconnect: ReconnectMutate<context>\n    /** @deprecated use `mutateAsync` instead */\n    reconnectAsync: ReconnectMutateAsync<context>\n  }\n>\n\n/** https://wagmi.sh/react/api/hooks/useReconnect */\nexport function useReconnect<context = unknown>(\n  parameters: UseReconnectParameters<context> = {},\n): UseReconnectReturnType<context> {\n  const config = useConfig(parameters)\n  const mutationOptions = reconnectMutationOptions(config)\n  const mutation = useMutation({ ...parameters.mutation, ...mutationOptions })\n  return {\n    ...mutation,\n    connectors: config.connectors,\n    reconnect: mutation.mutate,\n    reconnectAsync: mutation.mutateAsync,\n  }\n}\n", "'use client'\n\nimport { useMutation } from '@tanstack/react-query'\nimport type { Config, ResolvedRegister, SendCallsErrorType } from '@wagmi/core'\nimport type { Compute } from '@wagmi/core/internal'\nimport {\n  type SendCallsData,\n  type SendCallsMutate,\n  type SendCallsMutateAsync,\n  type SendCallsVariables,\n  sendCallsMutationOptions,\n} from '@wagmi/core/query'\n\nimport type { ConfigParameter } from '../types/properties.js'\nimport type {\n  UseMutationParameters,\n  UseMutationReturnType,\n} from '../utils/query.js'\nimport { useConfig } from './useConfig.js'\n\nexport type UseSendCallsParameters<\n  config extends Config = Config,\n  context = unknown,\n> = Compute<\n  ConfigParameter<config> & {\n    mutation?:\n      | UseMutationParameters<\n          SendCallsData,\n          SendCallsErrorType,\n          SendCallsVariables<config, config['chains'][number]['id']>,\n          context\n        >\n      | undefined\n  }\n>\n\nexport type UseSendCallsReturnType<\n  config extends Config = Config,\n  context = unknown,\n> = Compute<\n  UseMutationReturnType<\n    SendCallsData,\n    SendCallsErrorType,\n    SendCallsVariables<config, config['chains'][number]['id']>,\n    context\n  > & {\n    mutate: SendCallsMutate<config, context>\n    mutateAsync: SendCallsMutateAsync<config, context>\n    /** @deprecated use `mutate` instead */\n    sendCalls: SendCallsMutate<config, context>\n    /** @deprecated use `mutateAsync` instead */\n    sendCallsAsync: SendCallsMutateAsync<config, context>\n  }\n>\n\n/** https://wagmi.sh/react/api/hooks/useSendCalls */\nexport function useSendCalls<\n  config extends Config = ResolvedRegister['config'],\n  context = unknown,\n>(\n  parameters: UseSendCallsParameters<config, context> = {},\n): UseSendCallsReturnType<config, context> {\n  const config = useConfig(parameters)\n  const mutationOptions = sendCallsMutationOptions(config)\n  const mutation = useMutation({ ...parameters.mutation, ...mutationOptions })\n  type Return = UseSendCallsReturnType<config, context>\n  return {\n    ...mutation,\n    mutate: mutation.mutate as Return['mutate'],\n    mutateAsync: mutation.mutateAsync as Return['mutateAsync'],\n    sendCalls: mutation.mutate as Return['mutate'],\n    sendCallsAsync: mutation.mutateAsync as Return['mutateAsync'],\n  }\n}\n", "'use client'\n\nimport { useMutation } from '@tanstack/react-query'\nimport type {\n  Config,\n  ResolvedRegister,\n  SendCallsSyncErrorType,\n} from '@wagmi/core'\nimport type { Compute } from '@wagmi/core/internal'\nimport {\n  type SendCallsSyncData,\n  type SendCallsSyncMutate,\n  type SendCallsSyncMutateAsync,\n  type SendCallsSyncVariables,\n  sendCallsSyncMutationOptions,\n} from '@wagmi/core/query'\n\nimport type { ConfigParameter } from '../types/properties.js'\nimport type {\n  UseMutationParameters,\n  UseMutationReturnType,\n} from '../utils/query.js'\nimport { useConfig } from './useConfig.js'\n\nexport type UseSendCallsSyncParameters<\n  config extends Config = Config,\n  context = unknown,\n> = Compute<\n  ConfigParameter<config> & {\n    mutation?:\n      | UseMutationParameters<\n          SendCallsSyncData,\n          SendCallsSyncErrorType,\n          SendCallsSyncVariables<config, config['chains'][number]['id']>,\n          context\n        >\n      | undefined\n  }\n>\n\nexport type UseSendCallsSyncReturnType<\n  config extends Config = Config,\n  context = unknown,\n> = Compute<\n  UseMutationReturnType<\n    SendCallsSyncData,\n    SendCallsSyncErrorType,\n    SendCallsSyncVariables<config, config['chains'][number]['id']>,\n    context\n  > & {\n    mutate: SendCallsSyncMutate<config, context>\n    mutateAsync: SendCallsSyncMutateAsync<config, context>\n    /** @deprecated use `mutate` instead */\n    sendCallsSync: SendCallsSyncMutate<config, context>\n    /** @deprecated use `mutateAsync` instead */\n    sendCallsSyncAsync: SendCallsSyncMutateAsync<config, context>\n  }\n>\n\n/** https://wagmi.sh/react/api/hooks/useSendCallsSync */\nexport function useSendCallsSync<\n  config extends Config = ResolvedRegister['config'],\n  context = unknown,\n>(\n  parameters: UseSendCallsSyncParameters<config, context> = {},\n): UseSendCallsSyncReturnType<config, context> {\n  const config = useConfig(parameters)\n  const mutationOptions = sendCallsSyncMutationOptions(config)\n  const mutation = useMutation({ ...parameters.mutation, ...mutationOptions })\n  type Return = UseSendCallsSyncReturnType<config, context>\n  return {\n    ...mutation,\n    mutate: mutation.mutate as Return['mutate'],\n    mutateAsync: mutation.mutateAsync as Return['mutateAsync'],\n    sendCallsSync: mutation.mutate as Return['mutate'],\n    sendCallsSyncAsync: mutation.mutateAsync as Return['mutateAsync'],\n  }\n}\n", "'use client'\n\nimport { useMutation } from '@tanstack/react-query'\nimport type {\n  Config,\n  ResolvedRegister,\n  SendTransactionErrorType,\n} from '@wagmi/core'\nimport type { Compute } from '@wagmi/core/internal'\nimport {\n  type SendTransactionData,\n  type SendTransactionMutate,\n  type SendTransactionMutateAsync,\n  type SendTransactionVariables,\n  sendTransactionMutationOptions,\n} from '@wagmi/core/query'\n\nimport type { ConfigParameter } from '../types/properties.js'\nimport type {\n  UseMutationParameters,\n  UseMutationReturnType,\n} from '../utils/query.js'\nimport { useConfig } from './useConfig.js'\n\nexport type UseSendTransactionParameters<\n  config extends Config = Config,\n  context = unknown,\n> = Compute<\n  ConfigParameter<config> & {\n    mutation?:\n      | UseMutationParameters<\n          SendTransactionData,\n          SendTransactionErrorType,\n          SendTransactionVariables<config, config['chains'][number]['id']>,\n          context\n        >\n      | undefined\n  }\n>\n\nexport type UseSendTransactionReturnType<\n  config extends Config = Config,\n  context = unknown,\n> = Compute<\n  UseMutationReturnType<\n    SendTransactionData,\n    SendTransactionErrorType,\n    SendTransactionVariables<config, config['chains'][number]['id']>,\n    context\n  > & {\n    mutate: SendTransactionMutate<config, context>\n    mutateAsync: SendTransactionMutateAsync<config, context>\n    /** @deprecated use `mutate` instead */\n    sendTransaction: SendTransactionMutate<config, context>\n    /** @deprecated use `mutateAsync` instead */\n    sendTransactionAsync: SendTransactionMutateAsync<config, context>\n  }\n>\n\n/** https://wagmi.sh/react/api/hooks/useSendTransaction */\nexport function useSendTransaction<\n  config extends Config = ResolvedRegister['config'],\n  context = unknown,\n>(\n  parameters: UseSendTransactionParameters<config, context> = {},\n): UseSendTransactionReturnType<config, context> {\n  const config = useConfig(parameters)\n  const mutationOptions = sendTransactionMutationOptions(config)\n  const mutation = useMutation({ ...parameters.mutation, ...mutationOptions })\n  type Return = UseSendTransactionReturnType<config, context>\n  return {\n    ...mutation,\n    sendTransaction: mutation.mutate as Return['mutate'],\n    sendTransactionAsync: mutation.mutateAsync as Return['mutateAsync'],\n  }\n}\n", "'use client'\n\nimport { useMutation } from '@tanstack/react-query'\nimport type {\n  Config,\n  ResolvedRegister,\n  SendTransactionSyncErrorType,\n} from '@wagmi/core'\nimport type { Compute } from '@wagmi/core/internal'\nimport {\n  type SendTransactionSyncData,\n  type SendTransactionSyncMutate,\n  type SendTransactionSyncMutateAsync,\n  type SendTransactionSyncVariables,\n  sendTransactionSyncMutationOptions,\n} from '@wagmi/core/query'\n\nimport type { ConfigParameter } from '../types/properties.js'\nimport type {\n  UseMutationParameters,\n  UseMutationReturnType,\n} from '../utils/query.js'\nimport { useConfig } from './useConfig.js'\n\nexport type UseSendTransactionSyncParameters<\n  config extends Config = Config,\n  context = unknown,\n> = Compute<\n  ConfigParameter<config> & {\n    mutation?:\n      | UseMutationParameters<\n          SendTransactionSyncData,\n          SendTransactionSyncErrorType,\n          SendTransactionSyncVariables<config, config['chains'][number]['id']>,\n          context\n        >\n      | undefined\n  }\n>\n\nexport type UseSendTransactionSyncReturnType<\n  config extends Config = Config,\n  context = unknown,\n> = Compute<\n  UseMutationReturnType<\n    SendTransactionSyncData,\n    SendTransactionSyncErrorType,\n    SendTransactionSyncVariables<config, config['chains'][number]['id']>,\n    context\n  > & {\n    mutate: SendTransactionSyncMutate<config, context>\n    mutateAsync: SendTransactionSyncMutateAsync<config, context>\n    /** @deprecated use `mutate` instead */\n    sendTransactionSync: SendTransactionSyncMutate<config, context>\n    /** @deprecated use `mutateAsync` instead */\n    sendTransactionSyncAsync: SendTransactionSyncMutateAsync<config, context>\n  }\n>\n\n/** https://wagmi.sh/react/api/hooks/useSendTransactionSync */\nexport function useSendTransactionSync<\n  config extends Config = ResolvedRegister['config'],\n  context = unknown,\n>(\n  parameters: UseSendTransactionSyncParameters<config, context> = {},\n): UseSendTransactionSyncReturnType<config, context> {\n  const config = useConfig(parameters)\n  const mutationOptions = sendTransactionSyncMutationOptions(config)\n  const mutation = useMutation({ ...parameters.mutation, ...mutationOptions })\n  type Return = UseSendTransactionSyncReturnType<config, context>\n  return {\n    ...mutation,\n    sendTransactionSync: mutation.mutate as Return['mutate'],\n    sendTransactionSyncAsync: mutation.mutateAsync as Return['mutateAsync'],\n  }\n}\n", "'use client'\n\nimport { useMutation } from '@tanstack/react-query'\nimport type {\n  Config,\n  ResolvedRegister,\n  ShowCallsStatusErrorType,\n} from '@wagmi/core'\nimport type { Compute } from '@wagmi/core/internal'\nimport {\n  type ShowCallsStatusData,\n  type ShowCallsStatusMutate,\n  type ShowCallsStatusMutateAsync,\n  type ShowCallsStatusVariables,\n  showCallsStatusMutationOptions,\n} from '@wagmi/core/query'\n\nimport type { ConfigParameter } from '../types/properties.js'\nimport type {\n  UseMutationParameters,\n  UseMutationReturnType,\n} from '../utils/query.js'\nimport { useConfig } from './useConfig.js'\n\nexport type UseShowCallsStatusParameters<\n  config extends Config = Config,\n  context = unknown,\n> = Compute<\n  ConfigParameter<config> & {\n    mutation?:\n      | UseMutationParameters<\n          ShowCallsStatusData,\n          ShowCallsStatusErrorType,\n          ShowCallsStatusVariables,\n          context\n        >\n      | undefined\n  }\n>\n\nexport type UseShowCallsStatusReturnType<context = unknown> = Compute<\n  UseMutationReturnType<\n    ShowCallsStatusData,\n    ShowCallsStatusErrorType,\n    ShowCallsStatusVariables,\n    context\n  > & {\n    mutate: ShowCallsStatusMutate\n    mutateAsync: ShowCallsStatusMutateAsync\n    /** @deprecated use `mutate` instead */\n    showCallsStatus: ShowCallsStatusMutate\n    /** @deprecated use `mutateAsync` instead */\n    showCallsStatusAsync: ShowCallsStatusMutateAsync\n  }\n>\n\n/** https://wagmi.sh/react/api/hooks/useShowCallsStatus */\nexport function useShowCallsStatus<\n  config extends Config = ResolvedRegister['config'],\n  context = unknown,\n>(\n  parameters: UseShowCallsStatusParameters<config, context> = {},\n): UseShowCallsStatusReturnType<context> {\n  const config = useConfig(parameters)\n  const mutationOptions = showCallsStatusMutationOptions(config)\n  const mutation = useMutation({ ...parameters.mutation, ...mutationOptions })\n  type Return = UseShowCallsStatusReturnType<context>\n  return {\n    ...mutation,\n    showCallsStatus: mutation.mutate as Return['mutate'],\n    showCallsStatusAsync: mutation.mutateAsync as Return['mutateAsync'],\n  }\n}\n", "'use client'\n\nimport { useMutation } from '@tanstack/react-query'\nimport type { SignMessageErrorType } from '@wagmi/core'\nimport type { Compute } from '@wagmi/core/internal'\nimport {\n  type SignMessageData,\n  type SignMessageMutate,\n  type SignMessageMutateAsync,\n  type SignMessageVariables,\n  signMessageMutationOptions,\n} from '@wagmi/core/query'\n\nimport type { ConfigParameter } from '../types/properties.js'\nimport type {\n  UseMutationParameters,\n  UseMutationReturnType,\n} from '../utils/query.js'\nimport { useConfig } from './useConfig.js'\n\nexport type UseSignMessageParameters<context = unknown> = Compute<\n  ConfigParameter & {\n    mutation?:\n      | UseMutationParameters<\n          SignMessageData,\n          SignMessageErrorType,\n          SignMessageVariables,\n          context\n        >\n      | undefined\n  }\n>\n\nexport type UseSignMessageReturnType<context = unknown> = Compute<\n  UseMutationReturnType<\n    SignMessageData,\n    SignMessageErrorType,\n    SignMessageVariables,\n    context\n  > & {\n    mutate: SignMessageMutate<context>\n    mutateAsync: SignMessageMutateAsync<context>\n    /** @deprecated use `mutate` instead */\n    signMessage: SignMessageMutate<context>\n    /** @deprecated use `mutateAsync` instead */\n    signMessageAsync: SignMessageMutateAsync<context>\n  }\n>\n\n/** https://wagmi.sh/react/api/hooks/useSignMessage */\nexport function useSignMessage<context = unknown>(\n  parameters: UseSignMessageParameters<context> = {},\n): UseSignMessageReturnType<context> {\n  const config = useConfig(parameters)\n  const mutationOptions = signMessageMutationOptions(config)\n  const mutation = useMutation({ ...parameters.mutation, ...mutationOptions })\n  return {\n    ...mutation,\n    signMessage: mutation.mutate,\n    signMessageAsync: mutation.mutateAsync,\n  }\n}\n", "'use client'\n\nimport { useMutation } from '@tanstack/react-query'\nimport type { SignTypedDataErrorType } from '@wagmi/core'\nimport type { Compute } from '@wagmi/core/internal'\nimport {\n  type SignTypedDataData,\n  type SignTypedDataMutate,\n  type SignTypedDataMutateAsync,\n  type SignTypedDataVariables,\n  signTypedDataMutationOptions,\n} from '@wagmi/core/query'\n\nimport type { ConfigParameter } from '../types/properties.js'\nimport type {\n  UseMutationParameters,\n  UseMutationReturnType,\n} from '../utils/query.js'\nimport { useConfig } from './useConfig.js'\n\nexport type UseSignTypedDataParameters<context = unknown> = Compute<\n  ConfigParameter & {\n    mutation?:\n      | UseMutationParameters<\n          SignTypedDataData,\n          SignTypedDataErrorType,\n          SignTypedDataVariables,\n          context\n        >\n      | undefined\n  }\n>\n\nexport type UseSignTypedDataReturnType<context = unknown> = Compute<\n  UseMutationReturnType<\n    SignTypedDataData,\n    SignTypedDataErrorType,\n    SignTypedDataVariables,\n    context\n  > & {\n    mutate: SignTypedDataMutate<context>\n    mutateAsync: SignTypedDataMutateAsync<context>\n    /** @deprecated use `mutate` instead */\n    signTypedData: SignTypedDataMutate<context>\n    /** @deprecated use `mutateAsync` instead */\n    signTypedDataAsync: SignTypedDataMutateAsync<context>\n  }\n>\n\n/** https://wagmi.sh/react/api/hooks/useSignTypedData */\nexport function useSignTypedData<context = unknown>(\n  parameters: UseSignTypedDataParameters<context> = {},\n): UseSignTypedDataReturnType<context> {\n  const config = useConfig(parameters)\n  const mutationOptions = signTypedDataMutationOptions(config)\n  const mutation = useMutation({ ...parameters.mutation, ...mutationOptions })\n  type Return = UseSignTypedDataReturnType<context>\n  return {\n    ...mutation,\n    mutate: mutation.mutate as Return['mutate'],\n    mutateAsync: mutation.mutateAsync as Return['mutateAsync'],\n    signTypedData: mutation.mutate as Return['mutate'],\n    signTypedDataAsync: mutation.mutateAsync as Return['mutateAsync'],\n  }\n}\n", "'use client'\nimport type {\n  Config,\n  ResolvedRegister,\n  SimulateContractErrorType,\n} from '@wagmi/core'\nimport {\n  type SimulateContractData,\n  type SimulateContractOptions,\n  simulateContractQueryOptions,\n} from '@wagmi/core/query'\nimport type { Abi, ContractFunctionArgs, ContractFunctionName } from 'viem'\nimport type { ConfigParameter } from '../types/properties.js'\nimport { type UseQueryReturnType, useQuery } from '../utils/query.js'\nimport { useChainId } from './useChainId.js'\nimport { useConfig } from './useConfig.js'\nimport { useConnection } from './useConnection.js'\n\nexport type UseSimulateContractParameters<\n  abi extends Abi | readonly unknown[] = Abi,\n  functionName extends ContractFunctionName<\n    abi,\n    'nonpayable' | 'payable'\n  > = ContractFunctionName<abi, 'nonpayable' | 'payable'>,\n  args extends ContractFunctionArgs<\n    abi,\n    'nonpayable' | 'payable',\n    functionName\n  > = ContractFunctionArgs<abi, 'nonpayable' | 'payable', functionName>,\n  config extends Config = Config,\n  chainId extends config['chains'][number]['id'] | undefined = undefined,\n  selectData = SimulateContractData<abi, functionName, args, config, chainId>,\n> = SimulateContractOptions<\n  abi,\n  functionName,\n  args,\n  config,\n  chainId,\n  selectData\n> &\n  ConfigParameter<config>\n\nexport type UseSimulateContractReturnType<\n  abi extends Abi | readonly unknown[] = Abi,\n  functionName extends ContractFunctionName<\n    abi,\n    'nonpayable' | 'payable'\n  > = ContractFunctionName<abi, 'nonpayable' | 'payable'>,\n  args extends ContractFunctionArgs<\n    abi,\n    'nonpayable' | 'payable',\n    functionName\n  > = ContractFunctionArgs<abi, 'nonpayable' | 'payable', functionName>,\n  config extends Config = Config,\n  chainId extends config['chains'][number]['id'] | undefined = undefined,\n  selectData = SimulateContractData<abi, functionName, args, config, chainId>,\n> = UseQueryReturnType<selectData, SimulateContractErrorType>\n\n/** https://wagmi.sh/react/api/hooks/useSimulateContract */\nexport function useSimulateContract<\n  const abi extends Abi | readonly unknown[],\n  functionName extends ContractFunctionName<abi, 'nonpayable' | 'payable'>,\n  const args extends ContractFunctionArgs<\n    abi,\n    'nonpayable' | 'payable',\n    functionName\n  >,\n  config extends Config = ResolvedRegister['config'],\n  chainId extends config['chains'][number]['id'] | undefined = undefined,\n  selectData = SimulateContractData<abi, functionName, args, config, chainId>,\n>(\n  parameters: UseSimulateContractParameters<\n    abi,\n    functionName,\n    args,\n    config,\n    chainId,\n    selectData\n  > = {} as any,\n): UseSimulateContractReturnType<\n  abi,\n  functionName,\n  args,\n  config,\n  chainId,\n  selectData\n> {\n  const config = useConfig(parameters)\n  const { address, connector } = useConnection()\n  const chainId = useChainId({ config })\n  const options = simulateContractQueryOptions(config, {\n    ...(parameters as any),\n    account: parameters.account ?? address,\n    chainId: parameters.chainId ?? chainId,\n    connector: parameters.connector ?? connector,\n    query: parameters.query,\n  })\n  return useQuery(options) as any\n}\n", "'use client'\nimport type {\n  Config,\n  GetStorageAtErrorType,\n  ResolvedRegister,\n} from '@wagmi/core'\nimport type { Compute } from '@wagmi/core/internal'\nimport {\n  type GetStorageAtData,\n  type GetStorageAtOptions,\n  getStorageAtQueryOptions,\n} from '@wagmi/core/query'\nimport type { ConfigParameter } from '../types/properties.js'\nimport { type UseQueryReturnType, useQuery } from '../utils/query.js'\nimport { useChainId } from './useChainId.js'\nimport { useConfig } from './useConfig.js'\n\nexport type UseStorageAtParameters<\n  config extends Config = Config,\n  selectData = GetStorageAtData,\n> = Compute<GetStorageAtOptions<config, selectData> & ConfigParameter<config>>\n\nexport type UseStorageAtReturnType<selectData = GetStorageAtData> =\n  UseQueryReturnType<selectData, GetStorageAtErrorType>\n\n/** https://wagmi.sh/react/api/hooks/useStorageAt */\nexport function useStorageAt<\n  config extends Config = ResolvedRegister['config'],\n  selectData = GetStorageAtData,\n>(\n  parameters: UseStorageAtParameters<config, selectData> = {},\n): UseStorageAtReturnType<selectData> {\n  const config = useConfig(parameters)\n  const chainId = useChainId({ config })\n  const options = getStorageAtQueryOptions(config, {\n    ...parameters,\n    chainId: parameters.chainId ?? chainId,\n    query: parameters.query,\n  })\n  return useQuery(options)\n}\n", "'use client'\n\nimport { useMutation } from '@tanstack/react-query'\nimport type {\n  Config,\n  ResolvedRegister,\n  SwitchChainErrorType,\n} from '@wagmi/core'\nimport type { Compute } from '@wagmi/core/internal'\nimport {\n  type SwitchChainData,\n  type SwitchChainMutate,\n  type SwitchChainMutateAsync,\n  type SwitchChainVariables,\n  switchChainMutationOptions,\n} from '@wagmi/core/query'\n\nimport type { ConfigParameter } from '../types/properties.js'\nimport type {\n  UseMutationParameters,\n  UseMutationReturnType,\n} from '../utils/query.js'\nimport { useChains } from './useChains.js'\nimport { useConfig } from './useConfig.js'\n\nexport type UseSwitchChainParameters<\n  config extends Config = Config,\n  context = unknown,\n> = Compute<\n  ConfigParameter<config> & {\n    mutation?:\n      | UseMutationParameters<\n          SwitchChainData<config, config['chains'][number]['id']>,\n          SwitchChainErrorType,\n          SwitchChainVariables<config, config['chains'][number]['id']>,\n          context\n        >\n      | undefined\n  }\n>\n\nexport type UseSwitchChainReturnType<\n  config extends Config = Config,\n  context = unknown,\n> = Compute<\n  UseMutationReturnType<\n    SwitchChainData<config, config['chains'][number]['id']>,\n    SwitchChainErrorType,\n    SwitchChainVariables<config, config['chains'][number]['id']>,\n    context\n  > & {\n    /** @deprecated use `useChains` instead */\n    chains: config['chains']\n    mutate: SwitchChainMutate<config, context>\n    mutateAsync: SwitchChainMutateAsync<config, context>\n    /** @deprecated use `mutate` instead */\n    switchChain: SwitchChainMutate<config, context>\n    /** @deprecated use `mutateAsync` instead */\n    switchChainAsync: SwitchChainMutateAsync<config, context>\n  }\n>\n\n/** https://wagmi.sh/react/api/hooks/useSwitchChain */\nexport function useSwitchChain<\n  config extends Config = ResolvedRegister['config'],\n  context = unknown,\n>(\n  parameters: UseSwitchChainParameters<config, context> = {},\n): UseSwitchChainReturnType<config, context> {\n  const config = useConfig(parameters)\n  const mutationOptions = switchChainMutationOptions(config)\n  const mutation = useMutation({ ...parameters.mutation, ...mutationOptions })\n  type Return = UseSwitchChainReturnType<config, context>\n  return {\n    ...mutation,\n    mutate: mutation.mutate as Return['mutate'],\n    mutateAsync: mutation.mutateAsync as Return['mutateAsync'],\n    chains: useChains({ config }) as unknown as config['chains'],\n    switchChain: mutation.mutate as Return['mutate'],\n    switchChainAsync: mutation.mutateAsync as Return['mutateAsync'],\n  }\n}\n", "'use client'\n\nimport { useMutation } from '@tanstack/react-query'\nimport type {\n  Config,\n  Connector,\n  ResolvedRegister,\n  SwitchConnectionErrorType,\n} from '@wagmi/core'\nimport type { Compute } from '@wagmi/core/internal'\nimport {\n  type SwitchConnectionData,\n  type SwitchConnectionMutate,\n  type SwitchConnectionMutateAsync,\n  type SwitchConnectionVariables,\n  switchConnectionMutationOptions,\n} from '@wagmi/core/query'\n\nimport type { ConfigParameter } from '../types/properties.js'\nimport type {\n  UseMutationParameters,\n  UseMutationReturnType,\n} from '../utils/query.js'\nimport { useConfig } from './useConfig.js'\nimport { useConnections } from './useConnections.js'\n\nexport type UseSwitchConnectionParameters<\n  config extends Config = Config,\n  context = unknown,\n> = Compute<\n  ConfigParameter<config> & {\n    mutation?:\n      | UseMutationParameters<\n          SwitchConnectionData<config>,\n          SwitchConnectionErrorType,\n          SwitchConnectionVariables,\n          context\n        >\n      | undefined\n  }\n>\n\nexport type UseSwitchConnectionReturnType<\n  config extends Config = Config,\n  context = unknown,\n> = Compute<\n  UseMutationReturnType<\n    SwitchConnectionData<config>,\n    SwitchConnectionErrorType,\n    SwitchConnectionVariables,\n    context\n  > & {\n    /** @deprecated use `useConnections` instead */\n    connectors: readonly Connector[]\n    mutate: SwitchConnectionMutate<config, context>\n    mutateAsync: SwitchConnectionMutateAsync<config, context>\n    /** @deprecated use `mutate` instead */\n    switchAccount: SwitchConnectionMutate<config, context>\n    /** @deprecated use `mutateAsync` instead */\n    switchAccountAsync: SwitchConnectionMutateAsync<config, context>\n    /** @deprecated use `mutate` instead */\n    switchConnection: SwitchConnectionMutate<config, context>\n    /** @deprecated use `mutateAsync` instead */\n    switchConnectionAsync: SwitchConnectionMutateAsync<config, context>\n  }\n>\n\n/** https://wagmi.sh/react/api/hooks/useSwitchConnection */\nexport function useSwitchConnection<\n  config extends Config = ResolvedRegister['config'],\n  context = unknown,\n>(\n  parameters: UseSwitchConnectionParameters<config, context> = {},\n): UseSwitchConnectionReturnType<config, context> {\n  const config = useConfig(parameters)\n  const mutationOptions = switchConnectionMutationOptions(config)\n  const mutation = useMutation({ ...parameters.mutation, ...mutationOptions })\n  type Return = UseSwitchConnectionReturnType<config, context>\n  return {\n    ...mutation,\n    connectors: useConnections({ config }).map(\n      (connection) => connection.connector,\n    ),\n    mutate: mutation.mutate as Return['mutate'],\n    mutateAsync: mutation.mutateAsync as Return['mutateAsync'],\n    switchAccount: mutation.mutate as Return['mutate'],\n    switchAccountAsync: mutation.mutateAsync as Return['mutateAsync'],\n    switchConnection: mutation.mutate as Return['mutate'],\n    switchConnectionAsync: mutation.mutateAsync as Return['mutateAsync'],\n  }\n}\n", "'use client'\nimport type {\n  Config,\n  GetTransactionErrorType,\n  ResolvedRegister,\n} from '@wagmi/core'\nimport type { Compute } from '@wagmi/core/internal'\nimport {\n  type GetTransactionData,\n  type GetTransactionOptions,\n  getTransactionQueryOptions,\n} from '@wagmi/core/query'\nimport type { ConfigParameter } from '../types/properties.js'\nimport { type UseQueryReturnType, useQuery } from '../utils/query.js'\nimport { useChainId } from './useChainId.js'\nimport { useConfig } from './useConfig.js'\n\nexport type UseTransactionParameters<\n  config extends Config = Config,\n  chainId extends\n    config['chains'][number]['id'] = config['chains'][number]['id'],\n  selectData = GetTransactionData<config, chainId>,\n> = Compute<\n  GetTransactionOptions<config, chainId, selectData> & ConfigParameter<config>\n>\n\nexport type UseTransactionReturnType<\n  config extends Config = Config,\n  chainId extends\n    config['chains'][number]['id'] = config['chains'][number]['id'],\n  selectData = GetTransactionData<config, chainId>,\n> = UseQueryReturnType<selectData, GetTransactionErrorType>\n\n/** https://wagmi.sh/react/api/hooks/useTransaction */\nexport function useTransaction<\n  config extends Config = ResolvedRegister['config'],\n  chainId extends\n    config['chains'][number]['id'] = config['chains'][number]['id'],\n  selectData = GetTransactionData<config, chainId>,\n>(\n  parameters: UseTransactionParameters<config, chainId, selectData> = {},\n): UseTransactionReturnType<config, chainId, selectData> {\n  const config = useConfig(parameters)\n  const chainId = useChainId({ config })\n  const options = getTransactionQueryOptions(config, {\n    ...parameters,\n    chainId: parameters.chainId ?? chainId,\n    query: parameters.query,\n  })\n  return useQuery(options) as any\n}\n", "'use client'\nimport type {\n  Config,\n  GetTransactionConfirmationsErrorType,\n  ResolvedRegister,\n} from '@wagmi/core'\nimport {\n  type GetTransactionConfirmationsData,\n  type GetTransactionConfirmationsOptions,\n  getTransactionConfirmationsQueryOptions,\n} from '@wagmi/core/query'\nimport type { ConfigParameter } from '../types/properties.js'\nimport { type UseQueryReturnType, useQuery } from '../utils/query.js'\nimport { useChainId } from './useChainId.js'\nimport { useConfig } from './useConfig.js'\n\nexport type UseTransactionConfirmationsParameters<\n  config extends Config = Config,\n  chainId extends config['chains'][number]['id'] | undefined = undefined,\n  selectData = GetTransactionConfirmationsData,\n> = GetTransactionConfirmationsOptions<config, chainId, selectData> &\n  ConfigParameter<config>\n\nexport type UseTransactionConfirmationsReturnType<\n  selectData = GetTransactionConfirmationsData,\n> = UseQueryReturnType<selectData, GetTransactionConfirmationsErrorType>\n\n/** https://wagmi.sh/react/api/hooks/useTransactionConfirmations */\nexport function useTransactionConfirmations<\n  config extends Config = ResolvedRegister['config'],\n  chainId extends config['chains'][number]['id'] | undefined = undefined,\n  selectData = GetTransactionConfirmationsData,\n>(\n  parameters: UseTransactionConfirmationsParameters<\n    config,\n    chainId,\n    selectData\n  > = {} as any,\n): UseTransactionConfirmationsReturnType<selectData> {\n  const config = useConfig(parameters)\n  const chainId = useChainId({ config })\n  const options = getTransactionConfirmationsQueryOptions(config, {\n    ...parameters,\n    chainId: parameters.chainId ?? chainId,\n    query: parameters.query,\n  })\n  return useQuery(options) as any\n}\n", "'use client'\nimport type {\n  Config,\n  GetTransactionCountErrorType,\n  ResolvedRegister,\n} from '@wagmi/core'\nimport type { Compute } from '@wagmi/core/internal'\nimport {\n  type GetTransactionCountData,\n  type GetTransactionCountOptions,\n  getTransactionCountQueryOptions,\n} from '@wagmi/core/query'\nimport type { ConfigParameter } from '../types/properties.js'\nimport { type UseQueryReturnType, useQuery } from '../utils/query.js'\nimport { useChainId } from './useChainId.js'\nimport { useConfig } from './useConfig.js'\n\nexport type UseTransactionCountParameters<\n  config extends Config = Config,\n  selectData = GetTransactionCountData,\n> = Compute<\n  GetTransactionCountOptions<config, selectData> & ConfigParameter<config>\n>\n\nexport type UseTransactionCountReturnType<\n  selectData = GetTransactionCountData,\n> = UseQueryReturnType<selectData, GetTransactionCountErrorType>\n\n/** https://wagmi.sh/react/api/hooks/useTransactionCount */\nexport function useTransactionCount<\n  config extends Config = ResolvedRegister['config'],\n  selectData = GetTransactionCountData,\n>(\n  parameters: UseTransactionCountParameters<config, selectData> = {},\n): UseTransactionCountReturnType<selectData> {\n  const config = useConfig(parameters)\n  const chainId = useChainId({ config })\n  const options = getTransactionCountQueryOptions(config, {\n    ...parameters,\n    chainId: parameters.chainId ?? chainId,\n    query: parameters.query,\n  })\n  return useQuery(options)\n}\n", "'use client'\nimport type {\n  Config,\n  GetTransactionReceiptErrorType,\n  ResolvedRegister,\n} from '@wagmi/core'\nimport type { Compute } from '@wagmi/core/internal'\nimport {\n  type GetTransactionReceiptData,\n  type GetTransactionReceiptOptions,\n  getTransactionReceiptQueryOptions,\n} from '@wagmi/core/query'\nimport type { ConfigParameter } from '../types/properties.js'\nimport { type UseQueryReturnType, useQuery } from '../utils/query.js'\nimport { useChainId } from './useChainId.js'\nimport { useConfig } from './useConfig.js'\n\nexport type UseTransactionReceiptParameters<\n  config extends Config = Config,\n  chainId extends\n    config['chains'][number]['id'] = config['chains'][number]['id'],\n  selectData = GetTransactionReceiptData<config, chainId>,\n> = Compute<\n  GetTransactionReceiptOptions<config, chainId, selectData> &\n    ConfigParameter<config>\n>\n\nexport type UseTransactionReceiptReturnType<\n  config extends Config = Config,\n  chainId extends\n    config['chains'][number]['id'] = config['chains'][number]['id'],\n  selectData = GetTransactionReceiptData<config, chainId>,\n> = UseQueryReturnType<selectData, GetTransactionReceiptErrorType>\n\n/** https://wagmi.sh/react/api/hooks/useTransactionReceipt */\nexport function useTransactionReceipt<\n  config extends Config = ResolvedRegister['config'],\n  chainId extends\n    config['chains'][number]['id'] = config['chains'][number]['id'],\n  selectData = GetTransactionReceiptData<config, chainId>,\n>(\n  parameters: UseTransactionReceiptParameters<config, chainId, selectData> = {},\n): UseTransactionReceiptReturnType<config, chainId, selectData> {\n  const config = useConfig(parameters)\n  const chainId = useChainId({ config })\n  const options = getTransactionReceiptQueryOptions(config, {\n    ...parameters,\n    chainId: parameters.chainId ?? chainId,\n    query: parameters.query,\n  })\n  return useQuery(options) as any\n}\n", "'use client'\nimport type {\n  Config,\n  ResolvedRegister,\n  VerifyMessageErrorType,\n} from '@wagmi/core'\nimport type { Compute } from '@wagmi/core/internal'\nimport {\n  type VerifyMessageData,\n  type VerifyMessageOptions,\n  verifyMessageQueryOptions,\n} from '@wagmi/core/query'\nimport type { ConfigParameter } from '../types/properties.js'\nimport { type UseQueryReturnType, useQuery } from '../utils/query.js'\nimport { useChainId } from './useChainId.js'\nimport { useConfig } from './useConfig.js'\n\nexport type UseVerifyMessageParameters<\n  config extends Config = Config,\n  selectData = VerifyMessageData,\n> = Compute<VerifyMessageOptions<config, selectData> & ConfigParameter<config>>\n\nexport type UseVerifyMessageReturnType<selectData = VerifyMessageData> =\n  UseQueryReturnType<selectData, VerifyMessageErrorType>\n\n/** https://wagmi.sh/react/api/hooks/useVerifyMessage */\nexport function useVerifyMessage<\n  config extends Config = ResolvedRegister['config'],\n  selectData = VerifyMessageData,\n>(\n  parameters: UseVerifyMessageParameters<config, selectData> = {},\n): UseVerifyMessageReturnType<selectData> {\n  const config = useConfig(parameters)\n  const chainId = useChainId({ config })\n  const options = verifyMessageQueryOptions(config, {\n    ...parameters,\n    chainId: parameters.chainId ?? chainId,\n    query: parameters.query,\n  })\n  return useQuery(options)\n}\n", "'use client'\nimport type {\n  Config,\n  ResolvedRegister,\n  VerifyTypedDataErrorType,\n} from '@wagmi/core'\nimport {\n  type VerifyTypedDataData,\n  type VerifyTypedDataOptions,\n  verifyTypedDataQueryOptions,\n} from '@wagmi/core/query'\nimport type { TypedData } from 'viem'\nimport type { ConfigParameter } from '../types/properties.js'\nimport { type UseQueryReturnType, useQuery } from '../utils/query.js'\nimport { useChainId } from './useChainId.js'\nimport { useConfig } from './useConfig.js'\n\nexport type UseVerifyTypedDataParameters<\n  typedData extends TypedData | Record<string, unknown> = TypedData,\n  primaryType extends keyof typedData | 'EIP712Domain' = keyof typedData,\n  config extends Config = Config,\n  selectData = VerifyTypedDataData,\n> = VerifyTypedDataOptions<typedData, primaryType, config, selectData> &\n  ConfigParameter<config>\n\nexport type UseVerifyTypedDataReturnType<selectData = VerifyTypedDataData> =\n  UseQueryReturnType<selectData, VerifyTypedDataErrorType>\n\n/** https://wagmi.sh/react/api/hooks/useVerifyTypedData */\nexport function useVerifyTypedData<\n  const typedData extends TypedData | Record<string, unknown>,\n  primaryType extends keyof typedData | 'EIP712Domain',\n  config extends Config = ResolvedRegister['config'],\n  selectData = VerifyTypedDataData,\n>(\n  parameters: UseVerifyTypedDataParameters<\n    typedData,\n    primaryType,\n    config,\n    selectData\n  > = {} as any,\n): UseVerifyTypedDataReturnType<selectData> {\n  const config = useConfig(parameters)\n  const chainId = useChainId({ config })\n  const options = verifyTypedDataQueryOptions(config, {\n    ...(parameters as any),\n    chainId: parameters.chainId ?? chainId,\n    query: parameters.query,\n  })\n  return useQuery(options) as any\n}\n", "'use client'\nimport type {\n  Config,\n  ResolvedRegister,\n  WaitForCallsStatusErrorType,\n} from '@wagmi/core'\nimport type { Compute } from '@wagmi/core/internal'\nimport {\n  type WaitForCallsStatusData,\n  type WaitForCallsStatusOptions,\n  waitForCallsStatusQueryOptions,\n} from '@wagmi/core/query'\nimport type { ConfigParameter } from '../types/properties.js'\nimport { type UseQueryReturnType, useQuery } from '../utils/query.js'\nimport { useConfig } from './useConfig.js'\nimport { useConnection } from './useConnection.js'\n\nexport type UseWaitForCallsStatusParameters<\n  config extends Config = Config,\n  selectData = WaitForCallsStatusData,\n> = Compute<WaitForCallsStatusOptions<selectData> & ConfigParameter<config>>\n\nexport type UseWaitForCallsStatusReturnType<\n  selectData = WaitForCallsStatusData,\n> = UseQueryReturnType<selectData, WaitForCallsStatusErrorType>\n\n/** https://wagmi.sh/react/api/hooks/useWaitForCallsStatus */\nexport function useWaitForCallsStatus<\n  config extends Config = ResolvedRegister['config'],\n  selectData = WaitForCallsStatusData,\n>(\n  parameters: UseWaitForCallsStatusParameters<config, selectData>,\n): UseWaitForCallsStatusReturnType<selectData> {\n  const config = useConfig(parameters)\n  const { connector } = useConnection({ config })\n  const options = waitForCallsStatusQueryOptions(config, {\n    ...parameters,\n    connector: parameters.connector ?? connector,\n    query: parameters.query,\n  })\n  return useQuery(options)\n}\n", "'use client'\nimport type {\n  Config,\n  ResolvedRegister,\n  WaitForTransactionReceiptErrorType,\n} from '@wagmi/core'\nimport type { Compute } from '@wagmi/core/internal'\nimport {\n  type WaitForTransactionReceiptData,\n  type WaitForTransactionReceiptOptions,\n  waitForTransactionReceiptQueryOptions,\n} from '@wagmi/core/query'\nimport type { ConfigParameter } from '../types/properties.js'\nimport { type UseQueryReturnType, useQuery } from '../utils/query.js'\nimport { useChainId } from './useChainId.js'\nimport { useConfig } from './useConfig.js'\n\nexport type UseWaitForTransactionReceiptParameters<\n  config extends Config = Config,\n  chainId extends\n    config['chains'][number]['id'] = config['chains'][number]['id'],\n  selectData = WaitForTransactionReceiptData<config, chainId>,\n> = Compute<\n  WaitForTransactionReceiptOptions<config, chainId, selectData> &\n    ConfigParameter<config>\n>\n\nexport type UseWaitForTransactionReceiptReturnType<\n  config extends Config = Config,\n  chainId extends\n    config['chains'][number]['id'] = config['chains'][number]['id'],\n  selectData = WaitForTransactionReceiptData<config, chainId>,\n> = UseQueryReturnType<selectData, WaitForTransactionReceiptErrorType>\n\n/** https://wagmi.sh/react/api/hooks/useWaitForTransactionReceipt */\nexport function useWaitForTransactionReceipt<\n  config extends Config = ResolvedRegister['config'],\n  chainId extends\n    config['chains'][number]['id'] = config['chains'][number]['id'],\n  selectData = WaitForTransactionReceiptData<config, chainId>,\n>(\n  parameters: UseWaitForTransactionReceiptParameters<\n    config,\n    chainId,\n    selectData\n  > = {},\n): UseWaitForTransactionReceiptReturnType<config, chainId, selectData> {\n  const config = useConfig(parameters)\n  const chainId = useChainId({ config })\n  const options = waitForTransactionReceiptQueryOptions(config, {\n    ...parameters,\n    chainId: parameters.chainId ?? chainId,\n    query: parameters.query,\n  })\n  return useQuery(options) as any\n}\n", "'use client'\n// Almost identical implementation to `useConnectorClient` (except for return type)\n// Should update both in tandem\nimport { useQueryClient } from '@tanstack/react-query'\nimport type {\n  Config,\n  GetWalletClientErrorType,\n  ResolvedRegister,\n} from '@wagmi/core'\nimport type { Compute } from '@wagmi/core/internal'\nimport {\n  type GetWalletClientData,\n  type GetWalletClientOptions,\n  getWalletClientQueryOptions,\n} from '@wagmi/core/query'\nimport { useEffect, useRef } from 'react'\nimport type { ConfigParameter } from '../types/properties.js'\nimport { type UseQueryReturnType, useQuery } from '../utils/query.js'\nimport { useChainId } from './useChainId.js'\nimport { useConfig } from './useConfig.js'\nimport { useConnection } from './useConnection.js'\n\nexport type UseWalletClientParameters<\n  config extends Config = Config,\n  chainId extends\n    config['chains'][number]['id'] = config['chains'][number]['id'],\n  selectData = GetWalletClientData<config, chainId>,\n> = Compute<\n  GetWalletClientOptions<config, chainId, selectData> & ConfigParameter<config>\n>\n\nexport type UseWalletClientReturnType<\n  config extends Config = Config,\n  chainId extends\n    config['chains'][number]['id'] = config['chains'][number]['id'],\n  selectData = GetWalletClientData<config, chainId>,\n> = UseQueryReturnType<selectData, GetWalletClientErrorType>\n\n/** https://wagmi.sh/react/api/hooks/useWalletClient */\nexport function useWalletClient<\n  config extends Config = ResolvedRegister['config'],\n  chainId extends\n    config['chains'][number]['id'] = config['chains'][number]['id'],\n  selectData = GetWalletClientData<config, chainId>,\n>(\n  parameters: UseWalletClientParameters<config, chainId, selectData> = {},\n): UseWalletClientReturnType<config, chainId, selectData> {\n  const config = useConfig(parameters)\n  const chainId = useChainId({ config })\n  const { address, connector } = useConnection({ config })\n  const options = getWalletClientQueryOptions(config, {\n    ...parameters,\n    chainId: parameters.chainId ?? chainId,\n    connector: parameters.connector ?? connector,\n    query: parameters.query as any,\n  })\n\n  const addressRef = useRef(address)\n  const queryClient = useQueryClient()\n  // biome-ignore lint/correctness/useExhaustiveDependencies: `queryKey` not required\n  useEffect(() => {\n    const previousAddress = addressRef.current\n    if (!address && previousAddress) {\n      // remove when account is disconnected\n      queryClient.removeQueries({ queryKey: options.queryKey })\n      addressRef.current = undefined\n    } else if (address !== previousAddress) {\n      // invalidate when address changes\n      queryClient.invalidateQueries({ queryKey: options.queryKey })\n      addressRef.current = address\n    }\n  }, [address, queryClient])\n\n  return useQuery(options) as any\n}\n", "'use client'\n\nimport { useMutation } from '@tanstack/react-query'\nimport type { WatchAssetErrorType } from '@wagmi/core'\nimport type { Compute } from '@wagmi/core/internal'\nimport {\n  type WatchAssetData,\n  type WatchAssetMutate,\n  type WatchAssetMutateAsync,\n  type WatchAssetVariables,\n  watchAssetMutationOptions,\n} from '@wagmi/core/query'\n\nimport type { ConfigParameter } from '../types/properties.js'\nimport type {\n  UseMutationParameters,\n  UseMutationReturnType,\n} from '../utils/query.js'\nimport { useConfig } from './useConfig.js'\n\nexport type UseWatchAssetParameters<context = unknown> = Compute<\n  ConfigParameter & {\n    mutation?:\n      | UseMutationParameters<\n          WatchAssetData,\n          WatchAssetErrorType,\n          WatchAssetVariables,\n          context\n        >\n      | undefined\n  }\n>\n\nexport type UseWatchAssetReturnType<context = unknown> = Compute<\n  UseMutationReturnType<\n    WatchAssetData,\n    WatchAssetErrorType,\n    WatchAssetVariables,\n    context\n  > & {\n    mutate: WatchAssetMutate<context>\n    mutateAsync: WatchAssetMutateAsync<context>\n    /** @deprecated use `mutate` instead */\n    watchAsset: WatchAssetMutate<context>\n    /** @deprecated use `mutateAsync` instead */\n    watchAssetAsync: WatchAssetMutateAsync<context>\n  }\n>\n\n/** https://wagmi.sh/react/api/hooks/useWatchAsset */\nexport function useWatchAsset<context = unknown>(\n  parameters: UseWatchAssetParameters<context> = {},\n): UseWatchAssetReturnType<context> {\n  const config = useConfig(parameters)\n  const mutationOptions = watchAssetMutationOptions(config)\n  const mutation = useMutation({ ...parameters.mutation, ...mutationOptions })\n  return {\n    ...mutation,\n    watchAsset: mutation.mutate,\n    watchAssetAsync: mutation.mutateAsync,\n  }\n}\n", "'use client'\n\nimport {\n  type Config,\n  type ResolvedRegister,\n  type WatchContractEventParameters,\n  watchContractEvent,\n} from '@wagmi/core'\nimport type { UnionCompute, UnionExactPartial } from '@wagmi/core/internal'\nimport { useEffect } from 'react'\nimport type { Abi, ContractEventName } from 'viem'\n\nimport type { ConfigParameter, EnabledParameter } from '../types/properties.js'\nimport { useChainId } from './useChainId.js'\nimport { useConfig } from './useConfig.js'\n\nexport type UseWatchContractEventParameters<\n  abi extends Abi | readonly unknown[] = Abi,\n  eventName extends ContractEventName<abi> = ContractEventName<abi>,\n  strict extends boolean | undefined = undefined,\n  config extends Config = Config,\n  chainId extends\n    config['chains'][number]['id'] = config['chains'][number]['id'],\n> = UnionCompute<\n  UnionExactPartial<\n    WatchContractEventParameters<abi, eventName, strict, config, chainId>\n  > &\n    ConfigParameter<config> &\n    EnabledParameter\n>\n\nexport type UseWatchContractEventReturnType = void\n\n/** https://wagmi.sh/react/api/hooks/useWatchContractEvent */\nexport function useWatchContractEvent<\n  const abi extends Abi | readonly unknown[],\n  eventName extends ContractEventName<abi>,\n  strict extends boolean | undefined = undefined,\n  config extends Config = ResolvedRegister['config'],\n  chainId extends\n    config['chains'][number]['id'] = config['chains'][number]['id'],\n>(\n  parameters: UseWatchContractEventParameters<\n    abi,\n    eventName,\n    strict,\n    config,\n    chainId\n  > = {} as any,\n): UseWatchContractEventReturnType {\n  const { enabled = true, onLogs, config: _, ...rest } = parameters\n\n  const config = useConfig(parameters)\n  const configChainId = useChainId({ config })\n  const chainId = parameters.chainId ?? configChainId\n\n  // TODO(react@19): cleanup\n  // biome-ignore lint/correctness/useExhaustiveDependencies: `rest` changes every render so only including properties in dependency array\n  useEffect(() => {\n    if (!enabled) return\n    if (!onLogs) return\n    return watchContractEvent(config, {\n      ...(rest as any),\n      chainId,\n      onLogs,\n    })\n  }, [\n    chainId,\n    config,\n    enabled,\n    onLogs,\n    ///\n    rest.abi,\n    rest.address,\n    rest.args,\n    rest.batch,\n    rest.eventName,\n    rest.fromBlock,\n    rest.onError,\n    rest.poll,\n    rest.pollingInterval,\n    rest.strict,\n    rest.syncConnectedChain,\n  ])\n}\n", "'use client'\n\nimport {\n  type Config,\n  type ResolvedRegister,\n  type WatchPendingTransactionsParameters,\n  watchPendingTransactions,\n} from '@wagmi/core'\nimport type { UnionCompute, UnionExactPartial } from '@wagmi/core/internal'\nimport { useEffect } from 'react'\n\nimport type { ConfigParameter, EnabledParameter } from '../types/properties.js'\nimport { useChainId } from './useChainId.js'\nimport { useConfig } from './useConfig.js'\n\nexport type UseWatchPendingTransactionsParameters<\n  config extends Config = Config,\n  chainId extends\n    config['chains'][number]['id'] = config['chains'][number]['id'],\n> = UnionCompute<\n  UnionExactPartial<WatchPendingTransactionsParameters<config, chainId>> &\n    ConfigParameter<config> &\n    EnabledParameter\n>\n\nexport type UseWatchPendingTransactionsReturnType = void\n\n/** https://wagmi.sh/react/api/hooks/useWatchPendingTransactions */\nexport function useWatchPendingTransactions<\n  config extends Config = ResolvedRegister['config'],\n  chainId extends\n    config['chains'][number]['id'] = config['chains'][number]['id'],\n>(\n  parameters: UseWatchPendingTransactionsParameters<\n    config,\n    chainId\n  > = {} as any,\n): UseWatchPendingTransactionsReturnType {\n  const { enabled = true, onTransactions, config: _, ...rest } = parameters\n\n  const config = useConfig(parameters)\n  const configChainId = useChainId({ config })\n  const chainId = parameters.chainId ?? configChainId\n\n  // TODO(react@19): cleanup\n  // biome-ignore lint/correctness/useExhaustiveDependencies: `rest` changes every render so only including properties in dependency array\n  useEffect(() => {\n    if (!enabled) return\n    if (!onTransactions) return\n    return watchPendingTransactions(config, {\n      ...(rest as any),\n      chainId,\n      onTransactions,\n    })\n  }, [\n    chainId,\n    config,\n    enabled,\n    onTransactions,\n    ///\n    rest.batch,\n    rest.onError,\n    rest.poll,\n    rest.pollingInterval,\n    rest.syncConnectedChain,\n  ])\n}\n", "'use client'\n\nimport { useMutation } from '@tanstack/react-query'\nimport type {\n  Config,\n  ResolvedRegister,\n  WriteContractErrorType,\n} from '@wagmi/core'\nimport {\n  type WriteContractData,\n  type WriteContractMutate,\n  type WriteContractMutateAsync,\n  type WriteContractVariables,\n  writeContractMutationOptions,\n} from '@wagmi/core/query'\nimport type { Abi } from 'viem'\n\nimport type { ConfigParameter } from '../types/properties.js'\nimport type {\n  UseMutationParameters,\n  UseMutationReturnType,\n} from '../utils/query.js'\nimport { useConfig } from './useConfig.js'\n\nexport type UseWriteContractParameters<\n  config extends Config = Config,\n  context = unknown,\n> = ConfigParameter<config> & {\n  mutation?:\n    | UseMutationParameters<\n        WriteContractData,\n        WriteContractErrorType,\n        WriteContractVariables<\n          Abi,\n          string,\n          readonly unknown[],\n          config,\n          config['chains'][number]['id']\n        >,\n        context\n      >\n    | undefined\n}\n\nexport type UseWriteContractReturnType<\n  config extends Config = Config,\n  context = unknown,\n> = UseMutationReturnType<\n  WriteContractData,\n  WriteContractErrorType,\n  WriteContractVariables<\n    Abi,\n    string,\n    readonly unknown[],\n    config,\n    config['chains'][number]['id']\n  >,\n  context\n> & {\n  mutate: WriteContractMutate<config, context>\n  mutateAsync: WriteContractMutateAsync<config, context>\n  /** @deprecated use `mutate` instead */\n  writeContract: WriteContractMutate<config, context>\n  /** @deprecated use `mutateAsync` instead */\n  writeContractAsync: WriteContractMutateAsync<config, context>\n}\n\n/** https://wagmi.sh/react/api/hooks/useWriteContract */\nexport function useWriteContract<\n  config extends Config = ResolvedRegister['config'],\n  context = unknown,\n>(\n  parameters: UseWriteContractParameters<config, context> = {},\n): UseWriteContractReturnType<config, context> {\n  const config = useConfig(parameters)\n  const mutationOptions = writeContractMutationOptions(config)\n  const mutation = useMutation({ ...parameters.mutation, ...mutationOptions })\n  type Return = UseWriteContractReturnType<config, context>\n  return {\n    ...mutation,\n    mutate: mutation.mutate as Return['mutate'],\n    mutateAsync: mutation.mutateAsync as Return['mutateAsync'],\n    writeContract: mutation.mutate as Return['mutate'],\n    writeContractAsync: mutation.mutateAsync as Return['mutateAsync'],\n  }\n}\n"],
  "mappings": "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",
  "names": ["useEffect", "useSyncExternalStore", "useRef", "useEffect", "useMemo", "import_react", "BaseError", "BaseError", "structuralSharing", "_a", "_a", "_a", "_a", "useQuery", "useInfiniteQuery", "import_react", "import_react", "useQuery", "import_react", "useQuery", "import_react", "useQuery", "useQuery", "useQuery", "useQuery", "import_react", "isPlainObject", "useQuery", "useQuery", "import_react", "import_with_selector", "import_react", "import_react", "import_react", "import_react", "import_react", "useQuery", "useQuery", "useQuery", "useQuery", "useQuery", "useQuery", "useQuery", "useQuery", "useQuery", "useQuery", "useQuery", "useInfiniteQuery", "useQuery", "useQuery", "import_with_selector", "useQuery", "import_react", "useQuery", "useQuery", "useQuery", "useQuery", "useQuery", "useQuery", "useQuery", "useQuery", "useQuery", "useQuery", "useQuery", "import_react", "useQuery", "import_react", "import_react"]
}
